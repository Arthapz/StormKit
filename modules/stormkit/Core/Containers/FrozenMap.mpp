// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <frozen/unordered_map.h>
#include <frozen/unordered_set.h>

export module stormkit.Core:Containers.FrozenMap;

import std;

import :Utils.Numerics;
import :Meta.Concepts;

export namespace stormkit::core {
    template<IsHashable Key, class Value, RangeExtent N>
    constexpr auto makeFrozenMap(const std::pair<Key, Value> (&items)[N]) noexcept;

    template<IsHashable Key,
             class Value,
             RangeExtent N,
             IsHashFunc<Value> Hasher,
             IsBinaryPredicate<Value> Equal>
    constexpr auto makeFrozenMap(const std::pair<Key, Value> (&items)[N],
                                 const Hasher& hash,
                                 const Equal& equal) noexcept;

    template<IsHashable Key, class Value, RangeExtent N>
    constexpr auto makeFrozenMap(const std::array<std::pair<Key, Value>, N>& items) noexcept;

    template<IsHashable Key,
             class Value,
             RangeExtent N,
             IsHashFunc<Value> Hasher,
             IsBinaryPredicate<Value> Equal>
    constexpr auto makeFrozenMap(const std::array<std::pair<Key, Value>, N>& items,
                                 const Hasher& hash,
                                 const Equal& equal) noexcept;
} // namespace stormkit::core

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
    template<IsHashable Key, class Value, RangeExtent N>
    constexpr auto makeFrozenMap(const std::pair<Key, Value> (&items)[N]) noexcept {
        return frozen::make_unordered_map<Key, Value, N>(items);
    }

    template<IsHashable Key,
             class Value,
             RangeExtent N,
             IsHashFunc<Value> Hasher,
             IsBinaryPredicate<Value> Equal>
    constexpr auto makeFrozenMap(const std::pair<Key, Value> (&items)[N],
                                 const Hasher& hash,
                                 const Equal& equal) noexcept {
        return frozen::make_unordered_map<Key, Value, N, Hasher, Equal>(items, hash, equal);
    }

    template<IsHashable Key, class Value, RangeExtent N>
    constexpr auto makeFrozenMap(const std::array<std::pair<Key, Value>, N>& items) noexcept {
        return frozen::make_unordered_map<Key, Value, N>(items);
    }

    template<IsHashable Key,
             class Value,
             RangeExtent N,
             IsHashFunc<Value> Hasher,
             IsBinaryPredicate<Value> Equal>
    constexpr auto makeFrozenMap(const std::array<std::pair<Key, Value>, N>& items,
                                 const Hasher& hash,
                                 const Equal& equal) noexcept {
        return frozen::make_unordered_map<Key, Value, N, Hasher, Equal>(items, hash, equal);
    }
} // namespace stormkit::core