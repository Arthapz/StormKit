// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <frozen/unordered_map.h>
#include <frozen/unordered_set.h>

export module stormkit.Core:Containers.FrozenMap;

import std;

import <stormkit/Core/PlatformMacro.hpp>;

import :Utils.Numerics;
import :Utils.AsCast;
import :Meta.Concepts;

export namespace stormkit::core {
    template<IsHashable Key, class Value, RangeExtent N>
    [[nodiscard]] constexpr auto makeFrozenMap(const std::pair<Key, Value> (&items)[N]) noexcept;

    template<IsHashable Key,
             class Value,
             RangeExtent              N,
             IsHashFunc<Value>        Hasher,
             IsBinaryPredicate<Value> Equal>
    [[nodiscard]] constexpr auto makeFrozenMap(const std::pair<Key, Value> (&items)[N],
                                               const Hasher& hash,
                                               const Equal & equal) noexcept;

    // template<IsHashable Key, class Value, RangeExtent N>
    // constexpr auto makeFrozenMap(const std::array<std::pair<Key, Value>, N>& items) noexcept;
    //
    // template<IsHashable Key,
    //          class Value,
    //          RangeExtent N,
    //          IsHashFunc<Value> Hasher,
    //          IsBinaryPredicate<Value> Equal>
    // constexpr auto makeFrozenMap(const std::array<std::pair<Key, Value>, N>& items,
    //                              const Hasher& hash,
    //                              const Equal& equal) noexcept;
} // namespace stormkit::core

export namespace frozen {
    using frozen::elsa;

    template<stormkit::core::IsEnumeration T>
    struct elsa<T> {
        [[nodiscard]] constexpr auto operator()(const T                    & value,
                                                [[maybe_unused]] std::size_t seed) const noexcept
            -> std::size_t;
    };
} // namespace frozen

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
    template<IsHashable Key, class Value, RangeExtent N>
    STORMKIT_FORCE_INLINE constexpr auto
        makeFrozenMap(const std::pair<Key, Value> (&items)[N]) noexcept {
        return frozen::make_unordered_map<Key, Value, N>(items);
    }

    template<IsHashable Key,
             class Value,
             RangeExtent              N,
             IsHashFunc<Value>        Hasher,
             IsBinaryPredicate<Value> Equal>
    STORMKIT_FORCE_INLINE constexpr auto makeFrozenMap(const std::pair<Key, Value> (&items)[N],
                                                       const Hasher& hash,
                                                       const Equal & equal) noexcept {
        return frozen::make_unordered_map<Key, Value, N, Hasher, Equal>(items, hash, equal);
    }

    // template<IsHashable Key, class Value, RangeExtent N>
    // constexpr auto makeFrozenMap(const std::array<std::pair<Key, Value>, N>& items) noexcept {
    //     return frozen::make_unordered_map<Key, Value, N>(items);
    // }
    //
    // template<IsHashable Key,
    //          class Value,
    //          RangeExtent N,
    //          IsHashFunc<Value> Hasher,
    //          IsBinaryPredicate<Value> Equal>
    // constexpr auto makeFrozenMap(const std::array<std::pair<Key, Value>, N>& items,
    //                              const Hasher& hash,
    //                              const Equal& equal) noexcept {
    //     return frozen::make_unordered_map<Key, Value, N, Hasher, Equal>(items, hash, equal);
    // }
} // namespace stormkit::core

namespace frozen {
    template<stormkit::core::IsEnumeration T>
    STORMKIT_FORCE_INLINE constexpr auto
        elsa<T>::operator()(const T& value, [[maybe_unused]] std::size_t seed) const noexcept
        -> std::size_t {
        using namespace stormkit::core;
        return as<Underlying>(value);
    }
} // namespace frozen
