// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

export module stormkit.Core:Containers.Utils;

import std;

import :Meta.Traits;
import :Meta.Concepts;

import :Utils.Byte;

export namespace stormkit::core {
    template<std::ranges::range T, std::ranges::range... U>
    constexpr auto merge(T& output, const U&...ranges) noexcept -> void;

    template<std::ranges::range T, std::ranges::range... U>
    constexpr auto concat(const T& first, const U&...others) noexcept -> std::vector<RangeType<T>>;

    template<class T, typename... Args>
        requires((core::Is<T, Args> and ...) or (std::convertible_to<T, Args> and ...) or
                 (std::constructible_from<T, Args> and ...))
    constexpr auto makeStaticArray(T&& first, Args&&...args) noexcept -> decltype(auto);

    template<class T, typename... Args>
        requires((core::Is<T, Args> and ...) or (std::convertible_to<T, Args> and ...) or
                 (std::constructible_from<T, Args> and ...))
    constexpr auto makeArray(T&& first, Args&&...args) noexcept -> decltype(auto);

    template<std::ranges::range T>
    constexpr auto viewAsBytes(T& data) -> decltype(auto);

    template<typename T>
    constexpr auto viewAs(std::span<core::LikeCVType<T, core::Byte>> data) -> decltype(auto);
} // namespace stormkit::core

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
    ////////////////////////////////////////
    ////////////////////////////////////////
    template<std::ranges::range T, std::ranges::range... U>
    constexpr auto merge(T& output, const U&...ranges) noexcept -> void {
        output.reserve(std::size(output) + (std::ranges::size(ranges) + ...));
        (std::ranges::copy(ranges, std::back_inserter(output)), ...);
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<std::ranges::range T, std::ranges::range... U>
    constexpr auto concat(const T& first, const U&...others) noexcept -> std::vector<RangeType<T>> {
        auto output = std::vector<RangeType<T>> {};
        merge(output, first, others...);

        return output;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class T, typename... Args>
        requires((core::Is<T, Args> and ...) or (std::convertible_to<T, Args> and ...) or
                 (std::constructible_from<T, Args> and ...))
    constexpr auto makeStaticArray(T&& first, Args&&...args) noexcept -> decltype(auto) {
        return std::array { std::forward<T>(first), static_cast<T>(std::forward<Args>(args))... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class T, typename... Args>
        requires((core::Is<T, Args> and ...) or (std::convertible_to<T, Args> and ...) or
                 (std::constructible_from<T, Args> and ...))
    constexpr auto makeArray(T&& first, Args&&...args) noexcept -> decltype(auto) {
        return std::vector { std::forward<T>(first), static_cast<T>(std::forward<Args>(args))... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::ranges::range T>
    constexpr auto viewAsBytes(T& data) -> decltype(auto) {
        using Byte = core::LikeCVType<typename T::value_type, core::Byte>;
        return std::span<Byte> { std::bit_cast<Byte *>(std::ranges::data(data)),
                                 std::ranges::size(data) * sizeof(T) };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto viewAs(std::span<core::LikeCVType<T, core::Byte>> data) -> decltype(auto) {
        return std::span<T> { std::bit_cast<T *>(std::ranges::data(data)),
                              std::ranges::size(data) / sizeof(T) };
    }
} // namespace stormkit::core