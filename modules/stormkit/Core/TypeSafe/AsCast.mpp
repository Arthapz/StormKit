// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/PlatformMacro.hpp>

export module stormkit.Core:TypeSafe.AsCast;

import std;

import :Utils.Assert;
import :TypeSafe.Borrowed;
import :Meta.Concepts;
import :Meta.Traits;
import :TypeSafe.Boolean;

export namespace stormkit::core { inline namespace casts {
    template<typename To, typename From>
    struct IsQueryer {
        IsQueryer()                      = delete;
        IsQueryer(const IsQueryer&)      = delete;
        auto operator=(const IsQueryer&) = delete;
        IsQueryer(IsQueryer&&)           = delete;
        auto operator=(IsQueryer&&)      = delete;

        static constexpr auto
            operator()(const From&) noexcept -> Boolean
                                                = delete("No IsQueryer defined for this type");
    };

    template<typename To, typename From>
    concept IsQueryerable = requires(const From& from) {
        { IsQueryer<To, PureType<From>>::operator()(from) } -> IsBooleanTestable;
    };

    template<typename To, typename From>
        requires IsQueryerable<To, From>
    [[nodiscard]] constexpr auto is(const From& from) noexcept -> Boolean;

    template<typename To, typename From>
    struct AsCaster {
        AsCaster()                      = delete;
        AsCaster(const AsCaster&)       = delete;
        auto operator=(const AsCaster&) = delete;
        AsCaster(AsCaster&&)            = delete;
        auto operator=(AsCaster&&)      = delete;

        static constexpr auto
            operator()(From&&) noexcept -> decltype(auto)
                                           = delete("No AsCaster defined for this type");
    };

    template<typename To, typename From>
    concept IsAsCastable
        = requires(From&& from) { AsCaster<To, From>::operator()(std::forward<From>(from)); };

    template<typename To, typename From>
        requires IsAsCastable<To, From>
    [[nodiscard]] constexpr auto as(From&& from) noexcept -> decltype(auto);

    template<typename To, typename From>
    struct NarrowCaster {
        NarrowCaster()                      = delete;
        NarrowCaster(const NarrowCaster&)   = delete;
        auto operator=(const NarrowCaster&) = delete;
        NarrowCaster(NarrowCaster&&)        = delete;
        auto operator=(NarrowCaster&&)      = delete;

        static constexpr auto
            operator()(From) noexcept -> decltype(auto)
                                         = delete("No NarrowCaster defined for this type");
    };

    template<typename To, typename From>
    [[nodiscard]] constexpr auto narrow(From&& from) noexcept -> To;

    template<typename To, typename From>
        requires Is<To, PureType<From>>
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From&& from) noexcept -> decltype(auto);
    };

    // variants
    template<IsNotReference To, typename From>
        requires IsVariantType<From>
    struct IsQueryer<To, From> {
        [[nodiscard]] static constexpr auto operator()(const From& variant) noexcept -> Boolean;
    };

    template<IsNotReference To, typename From>
        requires(IsVariantType<PureType<From>>)
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From&& variant) noexcept -> decltype(auto);
    };

    // polymorphic
    template<IsPolymorphic To, IsNotPointer From>
        requires(IsPolymorphic<From> and Is<To, From>)
    struct IsQueryer<To, From> {
        [[nodiscard]] static constexpr auto operator()(const From& value) noexcept -> Boolean;
    };

    template<IsPolymorphic To, IsPointer From>
        requires(IsPolymorphicPointer<From> and Is<To, ElementType<From>>)
    struct IsQueryer<To, From> {
        [[nodiscard]] static constexpr auto operator()(const From& value) noexcept -> Boolean;
    };

    template<IsPolymorphic To, typename From>
        requires(IsPolymorphicPointer<PureType<From>> and Is<To, ElementType<PureType<From>>>)
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto
            operator()(From&& value) noexcept -> Borrowed<LikeCVType<ElementType<From>, To>>;
    };

    template<IsPolymorphic To, typename From>
        requires(not IsPointer<From> and IsPolymorphic<PureType<From>> and Is<To, PureType<From>>)
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto
            operator()(From&& value) noexcept -> LikeCVType<From, To&>;
    };

    // std::byte* / char*
    template<IsPointer To, IsIndirection From>
        requires(IsByte<ElementType<To>> and not IsRValueReference<From>)
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From&& value) noexcept -> To;
    };

    template<IsPointer To, typename From>
        requires(IsPointer<PureType<From>> and IsByte<ElementType<PureType<From>>>)
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From&& value) noexcept -> To;
    };

    // enumerations
    template<IsEnumeration To, typename From>
        requires(IsIntegral<PureType<From>> and Is<PureType<From>, UnderlyingType<To>>)
    struct AsCaster<To, From> {
        static constexpr auto PASS_BY_REF = sizeof(To) > sizeof(void*);
        using Arg                         = std::conditional_t<PASS_BY_REF, From&&, PureType<From>>;

        [[nodiscard]] static constexpr auto operator()(Arg value) noexcept -> To;
    };

    template<IsEnumeration To, typename From>
    // clang-format off
        requires(IsEnumeration<PureType<From>>
                 and Is<UnderlyingType<To>, UnderlyingType<PureType<From>>>)
    // clang-format on
    struct AsCaster<To, From> {
        static constexpr auto PASS_BY_REF = sizeof(To) > sizeof(void*);
        using Arg                         = std::conditional_t<PASS_BY_REF, From&&, PureType<From>>;

        [[nodiscard]] static constexpr auto operator()(Arg value) noexcept -> To;
    };

    template<IsIntegral To, typename From>
        requires(IsEnumeration<PureType<From>> and Is<To, UnderlyingType<PureType<From>>>)
    struct AsCaster<To, From> {
        static constexpr auto PASS_BY_REF = sizeof(To) > sizeof(void*);
        using Arg                         = std::conditional_t<PASS_BY_REF, From&&, PureType<From>>;
        [[nodiscard]] static constexpr auto operator()(Arg value) noexcept -> To;
    };

    struct Underlying {};

    template<Is<Underlying> To, typename From>
        requires IsEnumeration<PureType<From>>
    struct AsCaster<To, From> {
        static constexpr auto PASS_BY_REF = sizeof(To) > sizeof(void*);
        using Arg                         = std::conditional_t<PASS_BY_REF, From&&, PureType<From>>;
        [[nodiscard]] static constexpr auto
            operator()(Arg value) noexcept -> UnderlyingType<PureType<From>>;
    };

    // safe numeric types
    template<IsArithmetic To, typename From>
    constexpr auto isNarrowing(From&& value) -> Boolean;

    template<IsArithmetic To, typename From>
    // clang-format off
        requires(IsArithmetic<PureType<From>>
                 and not Is<PureType<From>, To>
                 and not IsNarrowing<To, PureType<From>>)
    // clang-format on
    struct AsCaster<To, From> {
        static constexpr auto PASS_BY_REF = sizeof(To) > sizeof(void*);
        using Arg                         = std::conditional_t<PASS_BY_REF, From&&, PureType<From>>;
        [[nodiscard]] static constexpr auto operator()(Arg value) noexcept -> To;
    };

    // std::byte
    template<IsIntegral To, IsByte From>
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    template<typename T>
    concept IsSafeCastableToByte = IsOneOf<T, char, unsigned char, signed char>;

    template<IsByte To, IsSafeCastableToByte From>
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    // explicit casts
    template<typename To, typename From>
    // clang-format off
        requires(IsExplicitConvertibleTo<From, To>
                 and not IsByte<To>
                 and not Is<PureType<From>, To>
                 and not IsEnumeration<PureType<From>>
                 and not IsArithmetic<PureType<From>>
                 and not IsByte<PureType<From>>)
    // clang-format on
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From&& from) noexcept -> To;
    };

    // narrowing
    template<IsIntegral To, typename From>
        requires(IsIntegral<PureType<From>>)
    struct NarrowCaster<To, From> {
        static constexpr auto PASS_BY_REF = sizeof(To) > sizeof(void*);
        using Arg                         = std::conditional_t<PASS_BY_REF, From&&, PureType<From>>;
        [[nodiscard]] static constexpr auto operator()(Arg value) noexcept -> To;
    };

    template<IsFloatingPoint To, typename From>
        requires(IsIntegral<PureType<From>>)
    struct NarrowCaster<To, From> {
        static constexpr auto PASS_BY_REF = sizeof(To) > sizeof(void*);
        using Arg                         = std::conditional_t<PASS_BY_REF, From&&, PureType<From>>;
        [[nodiscard]] static constexpr auto operator()(Arg value) noexcept -> To;
    };

    template<IsFloatingPoint To, typename From>
        requires(IsFloatingPoint<PureType<From>>)
    struct NarrowCaster<To, From> {
        static constexpr auto PASS_BY_REF = sizeof(To) > sizeof(void*);
        using Arg                         = std::conditional_t<PASS_BY_REF, From&&, PureType<From>>;
        [[nodiscard]] static constexpr auto operator()(Arg value) noexcept -> To;
    };

    template<IsIntegral To, typename From>
        requires(IsFloatingPoint<PureType<From>>)
    struct NarrowCaster<To, From> {
        static constexpr auto PASS_BY_REF = sizeof(To) > sizeof(void*);
        using Arg                         = std::conditional_t<PASS_BY_REF, From&&, PureType<From>>;
        [[nodiscard]] static constexpr auto operator()(Arg value) noexcept -> To;
    };

    template<IsEnumeration To, typename From>
        requires(IsIntegral<PureType<From>>)
    struct NarrowCaster<To, From> {
        static constexpr auto PASS_BY_REF = sizeof(To) > sizeof(void*);
        using Arg                         = std::conditional_t<PASS_BY_REF, From&&, PureType<From>>;
        [[nodiscard]] static constexpr auto operator()(Arg value) noexcept -> To;
    };

    template<IsEnumeration To, typename From>
        requires(IsEnumeration<PureType<From>>)
    struct NarrowCaster<To, From> {
        static constexpr auto PASS_BY_REF = sizeof(To) > sizeof(void*);
        using Arg                         = std::conditional_t<PASS_BY_REF, From&&, PureType<From>>;
        [[nodiscard]] static constexpr auto operator()(Arg value) noexcept -> To;
    };

    template<IsIntegral To, typename From>
        requires(IsEnumeration<PureType<From>>)
    struct NarrowCaster<To, From> {
        static constexpr auto PASS_BY_REF = sizeof(To) > sizeof(void*);
        using Arg                         = std::conditional_t<PASS_BY_REF, From&&, PureType<From>>;
        [[nodiscard]] static constexpr auto operator()(Arg value) noexcept -> To;
    };

    template<IsByte To, typename From>
        requires(IsIntegral<PureType<From>> and not IsSafeCastableToByte<PureType<From>>)
    struct NarrowCaster<To, From> {
        static constexpr auto PASS_BY_REF = sizeof(To) > sizeof(void*);
        using Arg                         = std::conditional_t<PASS_BY_REF, From&&, PureType<From>>;
        [[nodiscard]] static constexpr auto operator()(Arg value) noexcept -> To;
    };
}} // namespace stormkit::core::casts

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core { inline namespace casts {
    /////////////////////////////////////
    /////////////////////////////////////
    template<typename To, typename From>
        requires Is<To, PureType<From>>
    STORMKIT_FORCE_INLINE constexpr auto
        AsCaster<To, From>::operator()(From&& from) noexcept -> decltype(auto) {
        return std::forward<From>(from);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNotReference To, typename From>
        requires IsVariantType<From>
    STORMKIT_FORCE_INLINE constexpr auto
        IsQueryer<To, From>::operator()(const From& variant) noexcept -> Boolean {
        return std::holds_alternative<To>(variant);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNotReference To, typename From>
        requires(IsVariantType<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        AsCaster<To, From>::operator()(From&& variant) noexcept -> decltype(auto) {
        expects(is<To>(variant));

        return std::get<To>(std::forward<From>(variant));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsPolymorphic To, IsNotPointer From>
        requires(IsPolymorphic<From> and Is<To, From>)
    STORMKIT_FORCE_INLINE constexpr auto
        IsQueryer<To, From>::operator()(const From& value) noexcept -> Boolean {
        return dynamic_cast<const To*>(&value) != nullptr;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsPolymorphic To, IsPointer From>
        requires(IsPolymorphicPointer<From> and Is<To, ElementType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        IsQueryer<To, From>::operator()(const From& value) noexcept -> Boolean {
        return dynamic_cast<const To*>(std::to_address(value)) != nullptr;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsPolymorphic To, typename From>
        requires(not IsPointer<From> and IsPolymorphic<PureType<From>> and Is<To, PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        AsCaster<To, From>::operator()(From&& value) noexcept -> LikeCVType<From, To&> {
        expects(is<To>(value));

        return static_cast<LikeCVType<From, To&>>(value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsPolymorphic To, typename From>
        requires(IsPolymorphicPointer<PureType<From>> and Is<To, ElementType<PureType<From>>>)
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From&& value) noexcept
        -> Borrowed<LikeCVType<ElementType<From>, To>> {
        expects(is<To>(value));

        return Borrowed { static_cast<LikeCVType<From, To>*>(std::to_address(value)) };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsPointer To, IsIndirection From>
        requires(IsByte<ElementType<To>> and not IsRValueReference<From>)
    STORMKIT_FORCE_INLINE constexpr auto
        AsCaster<To, From>::operator()(From&& value) noexcept -> To {
        using ByteType = ElementType<To>;
        if constexpr (IsPointer<PureType<From>>)
            return To { std::bit_cast<ByteType*>(std::to_address(std::forward<From>(value))) };
        else
            return To { std::bit_cast<ByteType*>(&value) };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsPointer To, typename From>
        requires(IsPointer<PureType<From>> and IsByte<ElementType<PureType<From>>>)
    STORMKIT_FORCE_INLINE constexpr auto
        AsCaster<To, From>::operator()(From&& value) noexcept -> To {
        using ByteType = ElementType<To>;
        return To { std::bit_cast<ByteType*>(std::to_address(std::forward<From>(value))) };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsEnumeration To, typename From>
        requires(IsIntegral<PureType<From>> and Is<PureType<From>, UnderlyingType<To>>)
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(Arg value) noexcept -> To {
        return static_cast<To>(std::forward<Arg>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsEnumeration To, typename From>
    // clang-format off
        requires(IsEnumeration<PureType<From>>
                 and Is<UnderlyingType<To>, UnderlyingType<PureType<From>>>)
    // clang-format on
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(Arg value) noexcept -> To {
        return as<To>(as<Underlying>(std::forward<Arg>(value)));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsIntegral To, typename From>
        requires(IsEnumeration<PureType<From>> and Is<To, UnderlyingType<PureType<From>>>)
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(Arg value) noexcept -> To {
        return as<Underlying>(std::forward<Arg>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<Is<Underlying> To, typename From>
        requires IsEnumeration<PureType<From>>
    STORMKIT_FORCE_INLINE constexpr auto
        AsCaster<To, From>::operator()(Arg value) noexcept -> UnderlyingType<PureType<From>> {
        using T = UnderlyingType<PureType<From>>;
        return static_cast<T>(std::forward<Arg>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsArithmetic To, typename From>
    STORMKIT_FORCE_INLINE constexpr auto isNarrowing(From&& value) -> Boolean {
        if constexpr (IsUnsigned<To> and not IsUnsigned<PureType<From>>) {
            if (value < 0) return true;
        }

        return IsNarrowing<To, From>;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsArithmetic To, typename From>
    // clang-format off
        requires(IsArithmetic<PureType<From>>
                 and not Is<PureType<From>, To>
                 and not IsNarrowing<To, PureType<From>>)
    // clang-format on
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(Arg value) noexcept -> To {
        expects(not isNarrowing<To>(value));
        return static_cast<To>(std::forward<Arg>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsIntegral To, IsByte From>
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From value) noexcept -> To {
        return static_cast<To>(value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsByte To, IsSafeCastableToByte From>
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From value) noexcept -> To {
        return static_cast<To>(value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename To, typename From>
    // clang-format off
        requires(IsExplicitConvertibleTo<From, To>
                 and not IsByte<To>
                 and not Is<PureType<From>, To>
                 and not IsEnumeration<PureType<From>>
                 and not IsArithmetic<PureType<From>>
                 and not IsByte<PureType<From>>)
    // clang-format on
    STORMKIT_FORCE_INLINE constexpr auto
        AsCaster<To, From>::operator()(From&& from) noexcept -> To {
        return static_cast<To>(std::forward<From>(from));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsIntegral To, typename From>
        requires(IsIntegral<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(Arg value) noexcept -> To {
        using Type = SafeNarrowHelperType<To, PureType<From>>;
        if constexpr (Is<PureType<From>, To>) {
            expects(std::numeric_limits<To>::lowest() <= value);
            expects(std::numeric_limits<To>::max() > value);
        } else {
            if constexpr (std::signed_integral<To> and std::unsigned_integral<From>) {
                expects(static_cast<Type>(std::numeric_limits<To>::max())
                        > static_cast<Type>(value));
            } else {
                expects(static_cast<Type>(std::numeric_limits<To>::lowest())
                        <= static_cast<Type>(value));
                expects(static_cast<Type>(std::numeric_limits<To>::max())
                        > static_cast<Type>(value));
            }
        }

        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsFloatingPoint To, typename From>
        requires(IsIntegral<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(Arg value) noexcept -> To {
        expects(std::numeric_limits<To>::lowest() < value);
        expects(std::numeric_limits<To>::max() > value);

        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsFloatingPoint To, typename From>
        requires(IsFloatingPoint<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(Arg value) noexcept -> To {
        using Type = SafeNarrowHelperType<To, PureType<From>>;

        expects(static_cast<Type>(std::numeric_limits<To>::lowest()) < static_cast<Type>(value));
        expects(static_cast<Type>(std::numeric_limits<To>::max()) > static_cast<Type>(value));

        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsIntegral To, typename From>
        requires(IsFloatingPoint<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(Arg value) noexcept -> To {
        using Type = SafeNarrowHelperType<To, PureType<From>>;

        expects(static_cast<Type>(std::numeric_limits<To>::lowest()) < static_cast<Type>(value));
        expects(static_cast<Type>(std::numeric_limits<To>::max()) > static_cast<Type>(value));

        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsEnumeration To, typename From>
        requires(IsIntegral<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(Arg value) noexcept -> To {
        using T = UnderlyingType<To>;
        return as<To, T>(narrow<T>(std::forward<From>(value)));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsEnumeration To, typename From>
        requires(IsEnumeration<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(Arg value) noexcept -> To {
        using T = UnderlyingType<To>;
        return as<To, T>(narrow<T>(as<Underlying>(std::forward<From>(value))));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsIntegral To, typename From>
        requires(IsEnumeration<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(Arg value) noexcept -> To {
        return narrow<To>(as<Underlying>(std::forward<From>(value)));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsByte To, typename From>
        requires(IsIntegral<PureType<From>> and not IsSafeCastableToByte<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(Arg value) noexcept -> To {
        expects(value < std::numeric_limits<std::byte>::max());
        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename To, typename From>
        requires IsQueryerable<To, From>
    STORMKIT_FORCE_INLINE constexpr auto is(const From& from) noexcept -> Boolean {
        return IsQueryer<To, PureType<From>>::operator()(from);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename To, typename From>
        requires IsAsCastable<To, From>
    STORMKIT_FORCE_INLINE constexpr auto as(From&& from) noexcept -> decltype(auto) {
        return AsCaster<To, From>::operator()(std::forward<From>(from));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename To, typename From>
    STORMKIT_FORCE_INLINE constexpr auto narrow(From&& from) noexcept -> To {
        // return NarrowCaster<To, From>::operator()(std::forward<From>(from));
        return static_cast<To>(std::forward<From>(from));
    }
}} // namespace stormkit::core::casts
