// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/PlatformMacro.hpp>

export module stormkit.Core:TypeSafe.AsCast;

import std;
import magic_enum;

import :Utils.Assert;
import :TypeSafe.Byte;
import :Utils.FunctionRef;
import :TypeSafe.Ref;
import :Meta.Concepts;
import :Meta.Algorithms;
import :Meta.Traits;
import :Meta.PriorityTag;
import :TypeSafe.Boolean;
import :TypeSafe.Integer;
import :TypeSafe.Float;

export namespace stormkit::core {
    template<typename To, typename From>
    concept IsSignNarrowing
        = (IsSigned<From> ? !IsSigned<To> : IsSigned<To> and sizeof(From) == sizeof(To));

    template<typename To, typename From>
    concept IsByteNarrowing
        = ((IsArithmetic<To> and IsByte<From>) or (IsByte<To> and IsArithmetic<From>))
          and (IsByte<To> and sizeof(To) != sizeof(From));

    template<typename To, typename From>
    concept IsNarrowing
        = (IsFloatingPoint<From> and IsIntegral<To>)
          or (IsFloatingPoint<From> and IsFloatingPoint<To> and sizeof(From) > sizeof(To))
          or (IsIntegralOrEnumeration<From> and IsFloatingPoint<To>)
          or (IsIntegral<From> and IsIntegral<To>
              and (sizeof(From) > sizeof(To) or IsSignNarrowing<To, From>))
          or (IsEnumeration<From> and IsIntegral<To>
              and (sizeof(From) > sizeof(To) or IsSignNarrowing<UnderlyingType<From>, From>))
          or (IsPointer<From> and Is<To, bool>);

    template<typename To, typename From>
    concept IsUnsafePointerConvertion
        = IsPointer<To> and IsPointer<From> and not requires(To to, From from) { to = from; };

    template<typename To, typename From>
    constexpr auto isSafeNarrowing(const From& from) noexcept -> Boolean {
        if constexpr ((IsArithmetic<From> and IsByte<To>) or (IsByte<From> and IsArithmetic<To>))
            return (static_cast<From>(static_cast<To>(from)) == from);
        else if constexpr (IsArithmetic<From> and IsArithmetic<To>)
            return (static_cast<From>(static_cast<To>(from)) == from)
                   or (IsSigned<To> != IsUnsigned<From>
                       and ((static_cast<To>(from) < To {}) == (from < From {})));
        else
            static_assert(
                false,
                "isSafeNarrowing called with argument that are not bytes or arithmetic types");
        std::unreachable();
    }

    template<typename To, auto from>
    concept IsSafeNarrowing = IsArithmetic<To> and IsArithmetic<CanonicalTypeOf<from>>
                              and not isSafeNarrowing<To>(from);

    struct Underlying {};

    namespace casts {
        // Templates
        template<template<typename...> class T1, class T2>
        [[nodiscard]] constexpr auto is(T2&&) noexcept -> decltype(auto);

        template<template<typename, auto...> class T1, class T2>
        [[nodiscard]] constexpr auto is(T2&&) noexcept -> decltype(auto);

        // Types
        template<typename To, typename From>
        [[nodiscard]] constexpr auto is(const From& from) noexcept -> decltype(auto);

        // values
        template<typename T1, typename T2>
        [[nodiscard]] constexpr auto is(const T1& first, T2&& second) noexcept -> Boolean;

        template<typename T1, IsUnaryPredicate<T1> T2>
        [[nodiscard]] constexpr auto is(const T1& first, T2&& second) noexcept -> Boolean;

        template<IsArrayType T1, IsArrayType T2>
        [[nodiscard]] constexpr auto is(const T1& first, T2&& second) noexcept -> Boolean;

        template<typename T1, HasEqualityOperator<T1> T2>
        [[nodiscard]] constexpr auto is(const T1& first, T2&& second) noexcept -> Boolean;

        template<IsArithmetic To, auto From>
            requires(IsArithmetic<decltype(From)> and IsSafeNarrowing<To, From>)
        [[nodiscard]] constexpr auto as(const std::source_location& location
                                        = std::source_location::current()) noexcept -> To;

        template<typename To, typename From>
        constexpr auto as(From&&                      value,
                          const std::source_location& location
                          = std::source_location::current()) noexcept -> void;

        // exact same type
        template<typename To, typename From>
            requires(IsStrict<To, CanonicalType<From>>)
        [[nodiscard]] constexpr auto as(From&&                      value,
                                        const std::source_location& location
                                        = std::source_location::current()) noexcept
            -> ForwardLike<From, To>;

        // safe narrowing
        template<IsFloatingPoint T1, IsFloatingPoint T2>
            requires(IsFloatingPoint<CanonicalType<T2>>)
        [[nodiscard]] constexpr auto is(const T1& first, const T2& second) noexcept -> Boolean;

        template<typename To, typename From>
            requires((IsArithmetic<To> or IsByte<To>)
                     and (IsArithmetic<CanonicalType<From>> or IsByte<CanonicalType<From>>)
                     and not IsStrict<To, CanonicalType<From>>)
        [[nodiscard]] constexpr auto as(From&&                      value,
                                        const std::source_location& location
                                        = std::source_location::current()) noexcept -> To;

        // enumerations
        template<IsStrict<Underlying> To, typename From>
            requires(IsEnumeration<CanonicalType<From>>)
        [[nodiscard]] constexpr auto as(From&&                      value,
                                        const std::source_location& location
                                        = std::source_location::current()) noexcept
            -> UnderlyingType<CanonicalType<From>>;

        template<IsIntegral To, typename From>
            requires(IsEnumeration<CanonicalType<From>>)
        [[nodiscard]] constexpr auto as(From&&                      value,
                                        const std::source_location& location
                                        = std::source_location::current()) noexcept -> To;

        template<IsEnumeration To, typename From>
            requires(IsIntegral<CanonicalType<From>>)
        [[nodiscard]] constexpr auto as(From&&                      value,
                                        const std::source_location& location
                                        = std::source_location::current()) noexcept -> To;

        // to / from byte(s)
        template<IsStrictOneOf<ByteView, MutableByteView> To, typename From>
            requires(not IsPointer<CanonicalType<From>>)
        [[nodiscard]] constexpr auto as(STORMKIT_LIFETIMEBOUND From& value,
                                        const std::source_location&  location
                                        = std::source_location::current()) noexcept -> To;

        template<IsStrictOneOf<ByteView, MutableByteView> To, typename From>
            requires(IsPointer<CanonicalType<From>> and not IsMovedFancyPointer<From>)
        [[nodiscard]] constexpr auto as(From&&                      value,
                                        const std::source_location& location
                                        = std::source_location::current()) noexcept -> To;

        template<IsViewPointer To, typename From>
            requires(IsStrictOneOf<CanonicalType<From>, ByteView, MutableByteView>)
        [[nodiscard]] constexpr auto as(From&&                      value,
                                        const std::source_location& location
                                        = std::source_location::current()) noexcept
            -> std::conditional_t<IsRawPointer<To>, Ref<ElementType<To>>, To>;

        template<IsLValueReference To, typename From>
            requires(IsStrictOneOf<CanonicalType<From>, ByteView, MutableByteView>)
        [[nodiscard]] constexpr auto as(From&&                      value,
                                        const std::source_location& location
                                        = std::source_location::current()) noexcept -> To;

        // polymorphism
        template<IsPolymorphicIndirection To, typename From>
            requires(IsPolymorphicPointer<CanonicalType<From>> and not IsMovedFancyPointer<From>)
        [[nodiscard]] constexpr auto as(From&&                      value,
                                        const std::source_location& location
                                        = std::source_location::current()) noexcept
            -> decltype(auto);

        template<IsPolymorphicIndirection To, typename From>
            requires(IsPolymorphic<CanonicalType<From>> and not IsRValueReference<From>)
        [[nodiscard]] constexpr auto as(From&&                      value,
                                        const std::source_location& location
                                        = std::source_location::current()) noexcept
            -> decltype(auto);

        // predicate
        template<typename T>
        [[nodiscard]] constexpr auto is(const T& value, FunctionRef<const T&> predicate) noexcept
            -> Boolean;

        // std::variant
        template<typename T1, IsVariantType T2>
        [[nodiscard]] constexpr auto is(const T2& variant) noexcept -> Boolean;

        template<typename T1, IsVariantType T2>
        [[nodiscard]] constexpr auto is(const T2& variant, T1&& value) noexcept -> Boolean;

        template<typename To, IsVariantType From>
        [[nodiscard]] constexpr auto as(From&&                      variant,
                                        const std::source_location& location
                                        = std::source_location::current()) noexcept
            -> ForwardLike<From, To>;

        // std::optional
        template<typename T1, IsOptionalType T2>
        [[nodiscard]] constexpr auto is(const T2& optional) noexcept -> Boolean;

        template<typename T1, IsOptionalType T2>
        [[nodiscard]] constexpr auto is(const T2& optional, T1&& value) noexcept -> Boolean;

        template<typename To, IsOptionalType From>
        [[nodiscard]] constexpr auto as(From&&                      optional,
                                        const std::source_location& location
                                        = std::source_location::current()) noexcept
            -> ForwardLike<From, To>;

        // std::string
        template<IsStrictOneOf<std::string, std::string_view> To, IsEnumeration From>
        [[nodiscard]] constexpr auto as(const From& value) -> To;

        template<IsStrictOneOf<std::string, std::string_view> To, IsArithmetic From>
        [[nodiscard]] constexpr auto as(const From& value) -> To;

        template<typename To, typename From>
        [[nodiscard]] constexpr auto narrow(From&& value) noexcept -> To;
    } // namespace casts
} // namespace stormkit::core

export namespace stormkit::casts {
    template<typename T, typename U>
    struct IsQueryer {
        template<typename V>
        static constexpr auto operator()(const V&) noexcept -> void = delete;
    };

    template<typename T, typename U>
    struct AsCaster {
        template<typename V>
        static constexpr auto operator()(V&&) noexcept -> void = delete;
    };

    template<typename T, typename U>
    struct NarrowCaster {
        template<typename V>
        static constexpr auto operator()(V&&) noexcept -> void = delete;
    };
} // namespace stormkit::casts

namespace stormkit::core::details {
    template<typename T, typename U>
    concept HasCustomIsQueryer = requires(const U& value) {
        { stormkit::casts::IsQueryer<T, U>::operator()(value) } -> Is<Boolean>;
    };

    template<typename T, typename U>
    concept HasCustomAsCast = requires(const U& value) {
        {
            stormkit::casts::AsCaster<T, U>::operator()(value, std::source_location::current())
        } -> IsStrict<T>;
    };

    template<typename T, typename U>
    concept HasCustomNarrowCast = requires(const U& value) {
        { stormkit::casts::NarrowCaster<T, U>::operator()(value) } -> IsStrict<T>;
    };
} // namespace stormkit::core::details

export namespace stormkit::core {
    template<typename T, typename U>
    constexpr auto is(T&& first, U&& second) noexcept -> decltype(auto);

    template<typename T, typename U>
    constexpr auto is(U&& value) noexcept -> decltype(auto);

    template<typename T, typename U>
    constexpr auto as(U&&                         value,
                      const std::source_location& location
                      = std::source_location::current()) noexcept -> decltype(auto);

    template<typename T, typename U>
    constexpr auto narrow(U&& value) noexcept -> decltype(auto);
} // namespace stormkit::core

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T, typename U>
    constexpr auto is(T&& first, U&& second) noexcept -> decltype(auto) {
        if constexpr (details::HasCustomIsQueryer<CanonicalType<T>, CanonicalType<U>>)
            return stormkit::casts::IsQueryer<CanonicalType<T>, CanonicalType<U>>::operator()(
                std::forward<T>(first),
                std::forward<U>(second));
        else
            return stormkit::core::casts::is<CanonicalType<T>>(std::forward<T>(first), std::forward<U>(second));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T, typename U>
    constexpr auto is(U&& value) noexcept -> decltype(auto) {
        if constexpr (details::HasCustomIsQueryer<T, CanonicalType<U>>)
            return stormkit::casts::IsQueryer<T, CanonicalType<U>>::operator()(
                std::forward<U>(value));
        else
            return stormkit::core::casts::is<T>(std::forward<U>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T, typename U>
    constexpr auto as(U&& value, const std::source_location& location) noexcept -> decltype(auto) {
        if constexpr (details::HasCustomAsCast<T, CanonicalType<U>>)
            return stormkit::casts::AsCaster<T, CanonicalType<U>>::operator()(std::forward<U>(
                                                                                  value),
                                                                              location);
        else
            return stormkit::core::casts::as<T>(std::forward<U>(value), location);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T, typename U>
    constexpr auto narrow(U&& value) noexcept -> decltype(auto) {
        if constexpr (details::HasCustomNarrowCast<T, CanonicalType<U>>)
            return stormkit::casts::NarrowCaster<T, CanonicalType<U>>::operator()(
                std::forward<U>(value));
        else
            return stormkit::core::casts::narrow<T>(std::forward<U>(value));
    }

    namespace casts {
        // Templates
        /////////////////////////////////////
        /////////////////////////////////////
        template<template<typename...> class T1, class T2>
        STORMKIT_FORCE_INLINE constexpr auto is(const T2&) noexcept -> decltype(auto) {
            if constexpr (IsSpecializationOf<T2, T1>) return std::true_type {};
            else
                return std::false_type {};
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<template<typename, auto...> class T1, class T2>
        STORMKIT_FORCE_INLINE constexpr auto is(const T2&) noexcept -> decltype(auto) {
            if constexpr (IsSpecializationWithNTTPOf<T2, T1>) return std::true_type {};
            else
                return std::false_type {};
        }

        // Types
        /////////////////////////////////////
        /////////////////////////////////////
        template<typename To, typename From>
        STORMKIT_FORCE_INLINE constexpr auto is(const From& value) noexcept -> decltype(auto) {
            if constexpr (IsStrict<To, From>) return std::true_type {};
            else if constexpr (IsPolymorphicPointer<From> and IsPolymorphic<To>)
                return dynamic_cast<const To* const>(std::to_address(value)) != nullptr;
            else if constexpr (IsPolymorphic<From> and IsPolymorphic<To>)
                return dynamic_cast<const To* const>(&value) != nullptr;
            else if constexpr ((Is<From, std::nullptr_t> or requires {
                                   *value;
                                   From {};
                               }) and Is<To, void>)
                return value == From {};
            else if constexpr (IsPointer<From> and IsPointer<To>) {
                if (value != nullptr) return bool { is<DecayType<To>>(*value) };
                return false;
            } else
                return std::false_type {};
        }

        // values
        /////////////////////////////////////
        /////////////////////////////////////
        template<typename T1, typename T2>
        STORMKIT_FORCE_INLINE constexpr auto is(const T1&, T2&&) noexcept -> Boolean {
            return false;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<typename T1, IsUnaryPredicate<T1> T2>
        STORMKIT_FORCE_INLINE constexpr auto is(const T1& first, T2&& second) noexcept -> Boolean {
            return std::forward<T2>(second)(first);
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<IsArrayType T1, IsArrayType T2>
        STORMKIT_FORCE_INLINE constexpr auto is(const T1& first, T2&& second) noexcept -> Boolean {
            if (std::ssize(first) == std::ssize(second)) return std::ranges::equal(first, second);
            return false;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<typename T1, HasEqualityOperator<T1> T2>
        STORMKIT_FORCE_INLINE constexpr auto is(const T1& first, T2&& second) noexcept -> Boolean {
            using CanonicalT2 = CanonicalType<T2>;
            if constexpr (IsFloatingPoint<T1> and IsFloatingPoint<CanonicalT2>) {
                using T            = SafeNarrowHelperType<T1, CanonicalT2>;
                using TO           = SafeNarrowHelperOtherType<T1, CanonicalT2>;
                const auto first_  = as<T>(first);
                const auto second_ = as<T>(second);
                const auto epsilon = as<T>(Epsilon<TO>);
                return std::abs(first_ - second_)
                       <= epsilon * std::max({ T { 1 }, std::abs(first_), std::abs(second_) });
            } else if constexpr ((IsFloatingPoint<T1> and IsIntegral<CanonicalT2>)
                                 or (IsIntegral<T1> and IsFloatingPoint<CanonicalT2>)) {
                using T = std::conditional_t<IsFloatingPoint<T1>, T1, CanonicalT2>;

                return is(as<T>(first), as<T>(second));
            } else if constexpr (IsIntegral<T1> and IsIntegral<CanonicalT2>) {
                if (not(isSafeNarrowing<T1>(second) or isSafeNarrowing<CanonicalT2>(first)))
                    return false;

                using T = SafeNarrowHelperType<T1, CanonicalT2>;
                return as<T>(first) == as<T>(std::forward<T2>(second));
            } else
                return first == std::forward<T2>(second);
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<typename To, typename From>
        STORMKIT_FORCE_INLINE constexpr auto
            as([[maybe_unused]] From&&                      value,
               [[maybe_unused]] const std::source_location& location) noexcept -> void {
            static_assert(false, "no as caster for this type !");
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<IsArithmetic To, auto from>
            requires(IsArithmetic<decltype(from)> and IsSafeNarrowing<To, from>)
        STORMKIT_FORCE_INLINE constexpr auto as(const std::source_location& location) noexcept
            -> To {
            expects(IsSafeNarrowing<To, from>,
                    "Lossy narrowing detected, please use narrow() only if you really want unsafe "
                    "narrowing",
                    location);

            return static_cast<To>(from);
        }

        // exact same type
        /////////////////////////////////////
        /////////////////////////////////////
        template<typename To, typename From>
            requires(IsStrict<To, CanonicalType<From>>)
        STORMKIT_FORCE_INLINE constexpr auto
            as(From&& value, [[maybe_unused]] const std::source_location& location) noexcept
            -> ForwardLike<From, To> {
            return std::forward<From>(value);
        }

        // safe narrowing
        /////////////////////////////////////
        /////////////////////////////////////
        template<typename To, typename From>
            requires((IsArithmetic<To> or IsByte<To>)
                     and (IsArithmetic<CanonicalType<From>> or IsByte<CanonicalType<From>>)
                     and not IsStrict<To, CanonicalType<From>>)
        STORMKIT_FORCE_INLINE constexpr auto as(From&&                      value,
                                                const std::source_location& location) noexcept
            -> To {
            if constexpr (IsNarrowing<To, CanonicalType<From>>
                          or IsByteNarrowing<To, CanonicalType<From>>)
                expects(
                    isSafeNarrowing<To>(value),
                    "Lossy narrowing detected, please use narrow() only if you really want unsafe "
                    "narrowing",
                    location);

            return static_cast<To>(value);
        }

        // enumerations
        /////////////////////////////////////
        /////////////////////////////////////
        template<IsStrict<Underlying> To, typename From>
            requires(IsEnumeration<CanonicalType<From>>)
        STORMKIT_FORCE_INLINE constexpr auto
            as(From&& value, [[maybe_unused]] const std::source_location& location) noexcept
            -> UnderlyingType<CanonicalType<From>> {
            return static_cast<UnderlyingType<CanonicalType<From>>>(value);
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<IsIntegral To, typename From>
            requires(IsEnumeration<CanonicalType<From>>)
        STORMKIT_FORCE_INLINE constexpr auto as(From&&                      value,
                                                const std::source_location& location) noexcept
            -> To {
            if constexpr (IsStrict<To, UnderlyingType<CanonicalType<From>>>)
                return static_cast<To>(std::forward<From>(value));
            else
                return as<To>(as<Underlying>(std::forward<From>(value), location), location);
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<IsEnumeration To, typename From>
            requires(IsIntegral<CanonicalType<From>>)
        STORMKIT_FORCE_INLINE constexpr auto as(From&&                      value,
                                                const std::source_location& location) noexcept
            -> To {
            if constexpr (IsStrict<From, UnderlyingType<CanonicalType<To>>>)
                return static_cast<To>(std::forward<From>(value));
            else
                return static_cast<To>(as<UnderlyingType>(std::forward<From>(value), location));
        }

        // to / from byte(s)
        /////////////////////////////////////
        /////////////////////////////////////
        template<IsStrictOneOf<ByteView, MutableByteView> To, typename From>
            requires(not IsPointer<CanonicalType<From>>)
        STORMKIT_FORCE_INLINE constexpr auto as(From&                       value,
                                                const std::source_location& location) noexcept
            -> To {
            return as<To>(&value, location);
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<IsStrictOneOf<ByteView, MutableByteView> To, typename From>
            requires(IsPointer<CanonicalType<From>> and not IsMovedFancyPointer<From>)
        STORMKIT_FORCE_INLINE constexpr auto as(From&&                      value,
                                                const std::source_location& location) noexcept
            -> To {
            using CanonicalFrom = CanonicalType<From>;
            using ElementFrom   = ElementType<CanonicalFrom>;
            using BytePtr       = ConstnessLike<ElementFrom, Byte>* const;

            static_assert(not(IsStrict<To, MutableByteView>
                              and IsConst<ElementType<CanonicalFrom>>),
                          "as<MutableByteView, Pointer> call with a pointer of const type");
            expects(value != nullptr, "as<Bytes, Pointer> called with a null pointer", location);

            return To { std::bit_cast<BytePtr>(std::to_address(value)),
                        sizeof(Byte) * sizeof(ElementFrom) };
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<IsViewPointer To, typename From>
            requires(IsStrictOneOf<CanonicalType<From>, ByteView, MutableByteView>)
        STORMKIT_FORCE_INLINE constexpr auto
            as(From&& value, [[maybe_unused]] const std::source_location& location) noexcept
            -> std::conditional_t<IsRawPointer<To>, Ref<ElementType<To>>, To> {
            using Type    = ElementType<To>;
            using Pointer = Type*;
            using To_     = std::conditional_t<IsRawPointer<To>, Ref<ElementType<To>>, To>;

            return To_ { std::bit_cast<Pointer>(std::data(std::forward<From>(value))) };
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<IsLValueReference To, typename From>
            requires(IsStrictOneOf<CanonicalType<From>, ByteView, MutableByteView>)
        STORMKIT_FORCE_INLINE constexpr auto
            as(From&& value, [[maybe_unused]] const std::source_location& location) noexcept -> To {
            using Type    = RemoveIndirectionsType<To>;
            using Pointer = Type*;

            return To { *std::bit_cast<Pointer>(std::data(std::forward<From>(value))) };
        }

        // polymorphism
        template<IsPolymorphicIndirection To, typename From>
            requires(IsPolymorphicPointer<CanonicalType<From>> and not IsMovedFancyPointer<From>)
        STORMKIT_FORCE_INLINE constexpr auto
            as(From&& value, [[maybe_unused]] const std::source_location& location) noexcept
            -> decltype(auto) {
            using CanonicalFrom = std::remove_reference_t<From>;

            const auto ptr = std::to_address(value);

            if constexpr (IsPointer<To>) {
                using PointerElement = ElementType<CanonicalFrom>;
                using ToPointerType  = PointerType<To>;
                using ToElementType  = ElementType<To>;
                using To_            = std::conditional_t<IsRawPointer<To>, Ref<ToElementType>, To>;
                static_assert(Is<PointerElement, ToElementType>, "Invalid Polymorphic cast !");

                return To_ { static_cast<ToPointerType>(ptr) };
            } else {
                static_assert(Is<CanonicalFrom, CanonicalType<To>>, "Invalid Polymorphic cast !");

                return static_cast<To>(*ptr);
            }
        }

        template<IsPolymorphicIndirection To, typename From>
            requires(IsPolymorphic<CanonicalType<From>> and not IsRValueReference<From>)
        STORMKIT_FORCE_INLINE constexpr auto
            as(From&& value, [[maybe_unused]] const std::source_location& location) noexcept
            -> decltype(auto) {
            using CanonicalFrom = std::remove_reference_t<From>;

            if constexpr (IsPointer<To>) {
                using ToPointerType = PointerType<To>;
                using ToElementType = ElementType<To>;
                using To_           = std::conditional_t<IsRawPointer<To>, Ref<ToElementType>, To>;
                static_assert(Is<CanonicalFrom, ToElementType>, "Invalid Polymorphic cast !");

                return To_ { static_cast<ToPointerType>(&value) };
            } else {
                static_assert(Is<CanonicalFrom, CanonicalType<To>>, "Invalid Polymorphic cast !");

                return static_cast<To>(value);
            }
        }

        // predicate
        /////////////////////////////////////
        /////////////////////////////////////
        template<typename T>
        STORMKIT_FORCE_INLINE constexpr auto is(const T&                       value,
                                                FunctionRef<Boolean(const T&)> predicate) noexcept
            -> Boolean {
            return predicate(value);
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<typename T1, IsVariantType T2>
        STORMKIT_FORCE_INLINE constexpr auto is(const T2& variant) noexcept -> Boolean {
            return std::holds_alternative<T1>(variant);
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<typename T1, IsVariantType T2>
        STORMKIT_FORCE_INLINE constexpr auto is(const T2& variant, T1&& value) noexcept -> Boolean {
            return variantTypeFindIf(variant, [&]<auto Index>() noexcept {
                if (variant.index() == Index) {
                    if constexpr (IsUnaryPredicate<CanonicalType<T1>,
                                                   decltype(std::get<Index>(variant))>)
                        return value(std::get<Index>(variant));
                    else if constexpr (requires {
                                           {
                                               std::get<Index>(variant) == value
                                           } -> IsBooleanTestable;
                                       })
                        return is(std::get<Index>(variant), value);

                    return false;
                }

                return false;
            });
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<typename To, IsVariantType From>
        STORMKIT_FORCE_INLINE constexpr auto as(From&&                      variant,
                                                const std::source_location& location) noexcept
            -> ForwardLike<From, To> {
            /*using PtrType = ConstnessLike<From, To>*;*/
            /*auto ptr      = PtrType { nullptr };*/
            /**/
            /*variantTypeFindIf(variant, [&]<auto Index, typename T>() noexcept {*/
            /*    if constexpr (IsStrict<To, T>)*/
            /*        if (variant.index() == Index) {*/
            /*            ptr = &std::get<Index>(variant);*/
            /*            return true;*/
            /*        }*/
            /*    return false;*/
            /*});*/

            ensures(is<To>(variant), "Bad variant access detected", location);

            /*return std::forward_like<From>(*ptr);*/
            return std::forward_like<From>(std::get<To>(std::forward<From>(variant)));
        }

        // std::optional
        /////////////////////////////////////
        /////////////////////////////////////
        template<typename T1, IsOptionalType T2>
        STORMKIT_FORCE_INLINE constexpr auto is(const T2& optional) noexcept -> Boolean {
            if (not optional.has_value()) return false;

            if constexpr (requires { static_cast<const T1&>(*optional); }) return true;

            return false;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<typename T1, typename T2>
        STORMKIT_FORCE_INLINE constexpr auto is(const std::optional<T2>& optional,
                                                T1&& value) noexcept -> Boolean {
            if constexpr (IsUnaryPredicate<CanonicalType<T1>, T2>)
                return std::forward<T1>(value)(optional);
            else if constexpr (requires {
                                   { optional.value() == value } -> IsBooleanTestable;
                               })
                return optional.has_value() and optional.value() == value();

            return false;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<typename To, IsOptionalType From>
        STORMKIT_FORCE_INLINE constexpr auto as(From&&                      optional,
                                                const std::source_location& location) noexcept
            -> ForwardLike<From, To> {
            expects(is<To>(optional), "Bad optional access detected", location);

            return std::forward<From>(optional).value();
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<IsStrict<std::string> To, IsEnumeration From>
        [[nodiscard]] constexpr auto as(const From& value) -> To {
            return magic_enum::enum_name(value);
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<IsStrict<std::string> To, IsArithmetic From>
        [[nodiscard]] constexpr auto as(const From& value) -> To {
            static thread_local auto buf    = std::array<char, 20> {};
            const auto               result = std::to_chars(std::begin(buf), std::end(buf), value);
            ensures(result.ec != std::errc {}, std::make_error_code(result.ec).message());
            return To { std::begin(buf), static_cast<std::size_t>(result.ptr - std::begin(buf)) };
        }

        /////////////////////////////////////
        /////////////////////////////////////
        template<typename To, typename From>
        STORMKIT_FORCE_INLINE constexpr auto narrow(From&& value) noexcept -> To {
            return static_cast<To>(std::forward<From>(value));
        }
    } // namespace casts
} // namespace stormkit::core
