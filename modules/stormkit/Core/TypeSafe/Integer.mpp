// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/PlatformMacro.hpp>

export module stormkit.Core:TypeSafe.Integer;

import std;

import :Meta.Concepts;

export {
    namespace stormkit::core {
        template<IsIntegral T>
        class Integer {
          public:
            using Type = T;

            Integer() = delete;

            constexpr Integer(T value);

          private:
            T m_value;
        };

        template<IsIntegral T>
        Integer(T) -> Integer<T>;
    } // namespace stormkit::core

    template<class T, class CharT>
    struct std::formatter<stormkit::core::Integer<T>, CharT>: std::formatter<T, CharT> {
        template<class FormatContext>
        auto format(stormkit::core::Integer<T> data,
                    FormatContext&             ctx) const noexcept -> decltype(ctx.out());
    };
}

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
}

/////////////////////////////////////
/////////////////////////////////////
template<class T, class CharT>
template<class FormatContext>
STORMKIT_FORCE_INLINE auto std::formatter<stormkit::core::Integer<T>, CharT>::format(
    stormkit::core::Integer<T> data,
    FormatContext&             ctx) const noexcept -> decltype(ctx.out()) {
    return std::formatter<T, CharT>::format(static_cast<T>(data), ctx);
}
