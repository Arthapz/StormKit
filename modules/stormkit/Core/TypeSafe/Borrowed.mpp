// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/PlatformMacro.hpp>

export module stormkit.Core:TypeSafe.Borrowed;

import std;

import :Meta.Concepts;
import :Meta.Traits;
import :Utils.Assert;

export namespace stormkit::core {
    template<typename T>
    class [[nodiscard]] Borrowed {
      public:
        using ElementType   = T;
        using PointerType   = ElementType*;
        using ReferenceType = ElementType&;

        // STL compatible
        using element_type   = ElementType;
        using pointer_type   = PointerType;
        using reference_type = ReferenceType;

        constexpr Borrowed(ReferenceType value) noexcept;
        constexpr Borrowed(PointerType value) noexcept;
        constexpr ~Borrowed() noexcept;

        constexpr Borrowed(const Borrowed&) noexcept;
        constexpr Borrowed(Borrowed&&) noexcept;

        constexpr auto operator=(const Borrowed&) noexcept -> Borrowed&;
        constexpr auto operator=(Borrowed&&) noexcept -> Borrowed&;

        constexpr auto get() const noexcept -> PointerType;
        constexpr auto operator->() const noexcept -> PointerType;
        constexpr auto operator*() const noexcept -> ReferenceType;

        constexpr explicit operator bool() const noexcept;
        constexpr auto     hasValue() const noexcept -> bool;

        // template<typename Self>
        // constexpr operator std::conditional_t<std::is_const_v<Self>, const T&, T&>(
        //     this Self&& self) noexcept;
        //
        // template<typename Self>
        // constexpr operator std::enable_if<not std::is_const_v<T>, Borrowed<const T>>(
        //     this Self&& self) noexcept;

        constexpr operator ReferenceType() const noexcept;

      private:
        PointerType m_value;
    };

    template<typename T>
    using MaybeBorrowed = std::optional<Borrowed<T>>;

    template<IsRawPointer T>
    [[nodiscard]] constexpr auto borrow(T value) noexcept -> decltype(auto);

    template<IsFancyPointer T>
    [[nodiscard]] constexpr auto borrow(T& value) noexcept -> decltype(auto);

    template<typename T>
    // clang-format off
        requires(not IsRawPointer<PureType<T>> 
                 and not IsFancyPointer<PureType<T>> 
                 and not IsRValueReference<T>)
    // clang-format on
    [[nodiscard]] constexpr auto borrow(T&& value) noexcept -> decltype(auto);

    template<template<typename...> typename Out, typename... Args>
        requires(AreIndirections<Args...>)
    [[nodiscard]] constexpr auto borrows(Args&&... args) noexcept -> decltype(auto);
    template<template<typename, std::size_t> typename Out = std::array, typename... Args>
        requires(AreIndirections<Args...>)
    [[nodiscard]] constexpr auto borrows(Args&&... args) noexcept -> decltype(auto);

    template<template<typename...> class Out = std::vector, std::ranges::range T>
        requires(std::ranges::range<Out<typename T::value_type>>)
    [[nodiscard]] constexpr auto toBorroweds(T& args) noexcept -> decltype(auto);
} // namespace stormkit::core

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr Borrowed<T>::Borrowed(ReferenceType value) noexcept : m_value { &value } {
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr Borrowed<T>::Borrowed(PointerType value) noexcept : m_value { value } {
        core::expects(m_value != nullptr);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr Borrowed<T>::~Borrowed() noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr Borrowed<T>::Borrowed(const Borrowed&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr Borrowed<T>::Borrowed(Borrowed&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto Borrowed<T>::operator=(const Borrowed&) noexcept -> Borrowed& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto Borrowed<T>::operator=(Borrowed&&) noexcept -> Borrowed& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    [[nodiscard]] constexpr auto Borrowed<T>::get() const noexcept -> PointerType {
        return m_value;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto Borrowed<T>::operator->() const noexcept -> PointerType {
        return get();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto Borrowed<T>::operator*() const noexcept -> ReferenceType {
        return *get();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr Borrowed<T>::operator bool() const noexcept {
        return m_value != nullptr;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto Borrowed<T>::hasValue() const noexcept -> bool {
        return operator bool();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr Borrowed<T>::operator Borrowed<T>::ReferenceType() const noexcept {
        return *m_value;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsRawPointer T>
    constexpr auto borrow(T value) noexcept -> decltype(auto) {
        return Borrowed { *value };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsFancyPointer T>
    constexpr auto borrow(T& value) noexcept -> decltype(auto) {
        return borrow(value.get());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    // clang-format off
        requires(not IsRawPointer<PureType<T>> 
                 and not IsFancyPointer<PureType<T>>
                 and not IsRValueReference<T>)
    // clang-format on
    constexpr auto borrow(T&& value) noexcept -> decltype(auto) {
        return borrow(&value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<template<typename...> typename Out, typename... Args>
        requires(AreIndirections<Args...>)
    constexpr auto borrows(Args&&... args) noexcept -> decltype(auto) {
        return Out { borrow(std::forward<Args>(args))... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<template<typename, std::size_t> typename Out = std::array, typename... Args>
        requires(AreIndirections<Args...>)
    constexpr auto borrows(Args&&... args) noexcept -> decltype(auto) {
        return Out { borrow(std::forward<Args>(args))... };
    }

    template<template<typename...> class Out = std::vector, std::ranges::range T>
        requires(std::ranges::range<Out<typename T::value_type>>)
    constexpr auto toBorroweds(T& args) noexcept -> decltype(auto) {
        // clang-format off
        return args
               | std::views::transform([]<class U>(U&& val) static noexcept -> decltype(auto) {
                   return borrow(std::forward<U>(val));
               }) 
               | std::ranges::to<Out>();
        // clang-format on
    }

    //
    // /////////////////////////////////////
    // /////////////////////////////////////
    // template<template<typename, std::size_t> typename Out = std::array, std::ranges::range T>
    //     requires std::ranges::range<Out<int, 1>>
    // constexpr auto toBorroweds(T& args) -> decltype(auto) {
    //     // clang-format off
    //     return args
    //            | std::views::transform([]<class U>(U&& val) static noexcept -> decltype(auto) {
    //                return borrow(std::forward<U>(val));
    //            })
    //            | std::ranges::to<Out>();
    //     // clang-format on
    // }
} // namespace stormkit::core
