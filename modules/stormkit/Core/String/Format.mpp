// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

export module stormkit.Core:String.Format;

import std;
import magic_enum;

import :Meta;
import :TypeSafe.Integer;
import :TypeSafe.AsCast;
import :Utils.Time;
import :Utils.Math;

export namespace stormkit::core {
    template<IsEnumeration T>
    inline constexpr auto DisableDefaultFormaterForEnum = false;
}

export namespace std {
    template<IsStrict<std::byte> T, class CharT>
    struct formatter<T, CharT>: formatter<int, CharT> {
        template<class FormatContext>
        auto format(T data, FormatContext& ctx) const -> decltype(ctx.out());
    };

    template<class CharT>
    struct formatter<stormkit::core::Secondf, CharT>: formatter<float, CharT> {
        template<class FormatContext>
        auto format(const stormkit::core::Secondf& data, FormatContext& ctx) const
            -> decltype(ctx.out());
    };

    template<stormkit::core::math::IsVectorType T, typename CharT>
    struct formatter<T, CharT>: public formatter<basic_string<CharT>, CharT> {
        template<class ParseContext>
        constexpr auto parse(ParseContext& ctx) noexcept;

        template<class FormatContext>
        auto format(const T& data, FormatContext& ctx) const -> decltype(ctx.out());
    };

    template<stormkit::core::math::IsExtentLike T, typename CharT>
    struct formatter<T, CharT>: public formatter<basic_string<CharT>, CharT> {
        template<class ParseContext>
        constexpr auto parse(ParseContext& ctx) noexcept;

        template<class FormatContext>
        auto format(const T& data, FormatContext& ctx) const -> decltype(ctx.out());
    };

    template<stormkit::core::IsEnumeration T, typename CharT>
        requires(not stormkit::core::DisableDefaultFormaterForEnum<T>)
    struct formatter<T, CharT>: public formatter<basic_string_view<CharT>, CharT> {
        template<class FormatContext>
        auto format(const T& data, FormatContext& ctx) const -> decltype(ctx.out());
    };
} // namespace std

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace std {
    /////////////////////////////////////
    /////////////////////////////////////
    template<IsStrict<std::byte> T, class CharT>
    template<class FormatContext>
    auto formatter<T, CharT>::format(T data, FormatContext& ctx) const -> decltype(ctx.out()) {
        return formatter<int, CharT>::format(static_cast<int>(data), ctx);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class CharT>
    template<class FormatContext>
    auto formatter<stormkit::core::Secondf, CharT>::format(const stormkit::core::Secondf& data,
                                                           FormatContext&                 ctx) const
        -> decltype(ctx.out()) {
        return formatter<float, CharT>::format(data.count(), ctx);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<stormkit::core::math::IsVectorType T, typename CharT>
    template<class ParseContext>
    constexpr auto formatter<T, CharT>::parse(ParseContext& ctx) noexcept {
        return ctx.begin();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<stormkit::core::math::IsVectorType T, typename CharT>
    template<class FormatContext>
    auto formatter<T, CharT>::format(const T& data, FormatContext& ctx) const
        -> decltype(ctx.out()) {
        return std::format_to(ctx.out(), "{}", stormkit::core::as<std::string>(data));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<stormkit::core::math::IsExtentLike T, typename CharT>
    template<class ParseContext>
    constexpr auto formatter<T, CharT>::parse(ParseContext& ctx) noexcept {
        return ctx.begin();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<stormkit::core::math::IsExtentLike T, typename CharT>
    template<class FormatContext>
    auto formatter<T, CharT>::format(const T& data, FormatContext& ctx) const
        -> decltype(ctx.out()) {
        return std::format_to(ctx.out(), "{}", stormkit::core::as<std::string>(data));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<stormkit::core::IsEnumeration T, typename CharT>
        requires(not stormkit::core::DisableDefaultFormaterForEnum<T>)
    template<class FormatContext>
    auto formatter<T, CharT>::format(const T& data, FormatContext& ctx) const
        -> decltype(ctx.out()) {
        return formatter<basic_string_view<CharT>, CharT>::format(magic_enum::enum_name(data), ctx);
    }
} // namespace std
