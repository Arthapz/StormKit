// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

export module stormkit.Core:Utils.Borrowed;

import std;

import :Meta.Concepts;
import :Meta.Traits;
import :Utils.Assert;

export namespace stormkit::core {
    template<typename T>
    class [[nodiscard]] Borrowed {
      public:
        using ElementType   = T;
        using PointerType   = ElementType*;
        using ReferenceType = ElementType&;

        // STL compatible
        using element_type   = ElementType;
        using pointer_type   = PointerType;
        using reference_type = ReferenceType;

        constexpr Borrowed(ReferenceType value) noexcept;
        constexpr Borrowed(PointerType value) noexcept;
        constexpr ~Borrowed() noexcept;

        constexpr Borrowed(const Borrowed&) noexcept;
        constexpr Borrowed(Borrowed&&) noexcept;

        constexpr auto operator=(const Borrowed&) noexcept -> Borrowed&;
        constexpr auto operator=(Borrowed&&) noexcept -> Borrowed&;

        constexpr auto get(this auto&& self) noexcept -> decltype(auto);
        constexpr auto operator->(this auto&& self) noexcept -> decltype(auto);
        constexpr auto operator*(this auto&& self) noexcept -> decltype(auto);

        constexpr explicit operator bool() const noexcept;
        constexpr auto     hasValue() const noexcept -> bool;

        template<typename Self>
        constexpr operator std::conditional_t<std::is_const_v<Self>, const T&, T&>(
            this Self&& self) noexcept;

        template<typename Self>
        constexpr operator std::enable_if<not std::is_const_v<T>, Borrowed<const T>>(
            this Self&& self) noexcept;

      private:
        PointerType m_value;
    };

    template<typename T>
    using MaybeBorrowed = std::optional<Borrowed<T>>;

    template<IsRawIndirection T>
        requires(not IsRValueReference<T> and not IsFancyPointer<PureType<T>>)
    [[nodiscard]] constexpr auto borrow(T&& value) noexcept -> decltype(auto);
    template<typename T>
        requires(not IsFancyPointer<PureType<T>>)
    [[nodiscard]] constexpr auto borrow(const Borrowed<T>& value) noexcept -> decltype(auto);
    template<typename T>
        requires IsFancyPointer<PureType<T>>
    [[nodiscard]] constexpr auto borrow(T&& value) noexcept -> decltype(auto);

    template<template<typename...> typename Out = std::vector, typename... Args>
        requires(AreIndirections<Args...>)
    [[nodiscard]] constexpr auto borrows(Args&&... args) -> decltype(auto);
    template<template<typename, std::size_t> typename Out, typename... Args>
        requires(AreIndirections<Args...>)
    [[nodiscard]] constexpr auto borrows(Args&&... args) -> decltype(auto);

    template<template<typename...> typename Out = std::vector>
        requires std::ranges::range<Out<int>>
    [[nodiscard]] constexpr auto toBorroweds(std::ranges::range auto&& args) -> decltype(auto);
    template<template<typename, std::size_t> typename Out>
        requires std::ranges::range<Out<int, 1>>
    [[nodiscard]] constexpr auto toBorroweds(std::ranges::range auto&& args) -> decltype(auto);
} // namespace stormkit::core

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr Borrowed<T>::Borrowed(ReferenceType value) noexcept : m_value { &value } {
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr Borrowed<T>::Borrowed(PointerType value) noexcept : m_value { value } {
        core::expects(m_value != nullptr);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr Borrowed<T>::~Borrowed() noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr Borrowed<T>::Borrowed(const Borrowed&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr Borrowed<T>::Borrowed(Borrowed&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto Borrowed<T>::operator=(const Borrowed&) noexcept -> Borrowed& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto Borrowed<T>::operator=(Borrowed&&) noexcept -> Borrowed& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    [[nodiscard]] constexpr auto Borrowed<T>::get(this auto&& self) noexcept -> decltype(auto) {
        return *std::forward_like<decltype(self)>(self.m_value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto Borrowed<T>::operator->(this auto&& self) noexcept -> decltype(auto) {
        return std::forward_like<decltype(self)>(self.m_value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto Borrowed<T>::operator*(this auto&& self) noexcept -> decltype(auto) {
        return std::forward_like<decltype(self)>(self.get());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr Borrowed<T>::operator bool() const noexcept {
        return m_value != nullptr;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto Borrowed<T>::hasValue() const noexcept -> bool {
        return operator bool();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    template<typename Self>
    constexpr Borrowed<T>::operator std::conditional_t<std::is_const_v<Self>, const T&, T&>(
        this Self &&
            self) noexcept {
        return std::forward_like<decltype(self)>(self.get());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    template<typename Self>
    constexpr Borrowed<T>::operator std::enable_if<not std::is_const_v<T>,
                                                   Borrowed<const T>>(this Self && self) noexcept {
        return { std::as_const(self.m_value) };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsRawIndirection T>
        requires(not IsRValueReference<T> and not IsFancyPointer<PureType<T>>)
    constexpr auto borrow(T&& value) noexcept -> decltype(auto) {
        using PureT = PureType<T>;
        using Out =
            std::conditional_t<std::is_const_v<T>, Borrowed<PureT>, const Borrowed<const PureT>>;
        return Out { value };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
        requires(not IsFancyPointer<PureType<T>>)
    constexpr auto borrow(const Borrowed<T>& value) noexcept -> decltype(auto) {
        return auto { value };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
        requires IsFancyPointer<PureType<T>>
    constexpr auto borrow(T&& value) noexcept -> decltype(auto) {
        using PureT = PureType<typename PureType<T>::element_type>;
        using Out =
            std::conditional_t<std::is_const_v<T>, Borrowed<PureT>, const Borrowed<const PureT>>;
        return Out { *value };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<template<typename...> typename Out = std::vector, typename... Args>
        requires(AreIndirections<Args...>)
    constexpr auto borrows(Args&&... args) -> decltype(auto) {
        return Out { borrow(std::forward<Args>(args))... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<template<typename, std::size_t> typename Out, typename... Args>
        requires(AreIndirections<Args...>)
    constexpr auto borrows(Args&&... args) -> decltype(auto) {
        return Out { borrow(std::forward<Args>(args))... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<template<typename...> typename Out = std::vector>
        requires std::ranges::range<Out<int>>
    constexpr auto toBorroweds(std::ranges::range auto&& args) -> decltype(auto) {
        return args | std::views::transform([](auto&& val) static noexcept -> decltype(auto) {
                   return borrow(std::forward<decltype(val)>(val));
               }) |
               std::ranges::to<Out>();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<template<typename, std::size_t> typename Out>
        requires std::ranges::range<Out<int, 1>>
    constexpr auto toBorroweds(std::ranges::range auto&& args) -> decltype(auto) {
        return args | std::views::transform([](auto&& val) static noexcept -> decltype(auto) {
                   return borrow(std::forward<decltype(val)>(val));
               }) |
               std::ranges::to<Out>();
    }
} // namespace stormkit::core
