// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

export module stormkit.Core:Utils.Byte;

import std;

import :Meta;
import :Utils.Numerics;

export namespace stormkit::core {
    using Byte = std::byte;

    [[nodiscard]] constexpr auto byteSwap(auto value) noexcept;

    [[nodiscard]] constexpr auto asByteView(std::ranges::range auto& container);

    [[nodiscard]] constexpr auto asByteView(IsRawPointer auto ptr, RangeExtent size);

    template<class T>
        requires(not std::ranges::range<T> and not IsRawPointer<T>)
    [[nodiscard]] constexpr auto asByteView(T& value);

    [[nodiscard]] constexpr auto makeStaticByteArray(auto... bytes) noexcept -> decltype(auto);

    namespace literals {
        [[nodiscard]] constexpr auto operator"" _b(unsigned long long int value) noexcept;

        [[nodiscard]] constexpr auto operator""_kb(unsigned long long x) noexcept -> core::UInt64;

        [[nodiscard]] constexpr auto operator""_mb(unsigned long long x) noexcept -> core::UInt64;

        [[nodiscard]] constexpr auto operator""_gb(unsigned long long x) noexcept -> core::UInt64;

        [[nodiscard]] constexpr auto operator""_kib(unsigned long long x) noexcept -> core::UInt64;

        [[nodiscard]] constexpr auto operator""_mib(unsigned long long x) noexcept -> core::UInt64;

        [[nodiscard]] constexpr auto operator""_gib(unsigned long long x) noexcept -> core::UInt64;

    } // namespace literals
} // namespace stormkit::core

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto byteSwap(auto value) noexcept {
        auto repr = std::bit_cast<std::array<Byte, sizeof(value)>>(value);

        std::ranges::reverse(repr);

        return std::bit_cast<decltype(value)>(repr);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto asByteView(std::ranges::range auto& container) {
        using T = decltype(container);

        using ByteType  = std::conditional_t<IsConst<T>, const Byte, Byte>;
        using ValueType = typename PureType<T>::value_type;

        return std::span<ByteType> { std::bit_cast<ByteType *>(std::data(container)),
                                     std::size(container) * sizeof(ValueType) };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto asByteView(IsRawPointer auto ptr, RangeExtent size) {
        using Ptr = decltype(ptr);

        using value_type = std::decay_t<Ptr>;
        using ByteType   = std::conditional_t<IsConst<Ptr>, const Byte, Byte>;

        constexpr auto byte_count = []() {
            if constexpr (Is<value_type, void>) return 1;
            else
                return sizeof(value_type);
        }();

        return std::span<Byte> { std::bit_cast<ByteType *>(ptr), size * byte_count };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class T>
        requires(not std::ranges::range<T> and not IsRawPointer<T>)
    constexpr auto asByteView(T& value) {
        return asByteView(std::to_address(value), 1);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto makeStaticByteArray(auto... bytes) noexcept -> decltype(auto) {
        return std::array { static_cast<Byte>(bytes)... };
    }

    namespace literals {
        /////////////////////////////////////
        /////////////////////////////////////
        constexpr auto operator"" _b(unsigned long long int value) noexcept {
            return static_cast<Byte>(value);
        }

        /////////////////////////////////////
        /////////////////////////////////////
        constexpr auto operator""_kb(unsigned long long x) noexcept -> core::UInt64 {
            return 1000ULL * x;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        constexpr auto operator""_mb(unsigned long long x) noexcept -> core::UInt64 {
            return 1000ULL * 1000ULL * x;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        constexpr auto operator""_gb(unsigned long long x) noexcept -> core::UInt64 {
            return 1000ULL * 1000ULL * 1000ULL * x;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        constexpr auto operator""_kib(unsigned long long x) noexcept -> core::UInt64 {
            return 1024ULL * x;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        constexpr auto operator""_mib(unsigned long long x) noexcept -> core::UInt64 {
            return 1024ULL * 1024ULL * x;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        constexpr auto operator""_gib(unsigned long long x) noexcept -> core::UInt64 {
            return 1024ULL * 1000ULL * 1024ULL * x;
        }
    } // namespace literals
} // namespace stormkit::core