// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/PlatformMacro.hpp>

export module stormkit.Core:Utils.ErrorHandling;

import std;

import :Meta.Concepts;
import :Meta.Traits;

import :Console;
import :Utils.Stacktrace;

export namespace stormkit::core {
    template<typename T>
    [[nodiscard]] constexpr auto expectsWithMessage(std::string&&        message,
                                                    std::source_location location
                                                    = std::source_location::current()) noexcept
        -> decltype(auto); // optional overload

    template<typename T>
    [[nodiscard]] constexpr auto expects(std::source_location location
                                         = std::source_location::current()) noexcept
        -> decltype(auto); // optional overload

    [[nodiscard]] constexpr auto expectsWithMessage(std::string&&        message,
                                                    std::source_location location
                                                    = std::source_location::current()) noexcept
        -> decltype(auto);

    [[nodiscard]] constexpr auto expects(std::source_location location
                                         = std::source_location::current()) noexcept
        -> decltype(auto);

    [[nodiscard]] constexpr auto log(std::invocable auto&& logger, std::string&& message) noexcept
        -> decltype(auto);

    [[nodiscard]] constexpr auto throwError() noexcept -> decltype(auto);
} // namespace stormkit::core

#ifdef STORMKIT_COMPILER_CLANG
    #define NORETURN_LAMBDA [[noreturn]]
#else
    #define NORETURN_LAMBDA
#endif

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
    ////////////////////////////////////////
    ////////////////////////////////////////
    template<typename T>
    constexpr auto expectsWithMessage(std::string&& message, std::source_location location) noexcept
        -> decltype(auto) {
        return [message  = std::move(message),
                location = std::move(location)] NORETURN_LAMBDA() -> std::optional<T> {
            std::println(getSTDErr(),
                         "{} failed in \n"
                         "    > file:     {}\n"
                         "      line:     {}\n"
                         "      function: {}\n"
                         "      reason:  {}",
                         ConsoleStyle { .fg        = ConsoleColor::Red,
                                        .modifiers = StyleModifier::Bold | StyleModifier::Inverse }
                             | "[Ensures]",
                         ConsoleStyle { .fg = ConsoleColor::Yellow } | location.file_name(),
                         ConsoleStyle { .fg = ConsoleColor::Blue } | location.line(),
                         ConsoleStyle { .fg = ConsoleColor::Green } | location.function_name(),
                         ConsoleStyle { .fg = ConsoleColor::Red, .modifiers = StyleModifier::Bold }
                             | std::move(message));

            std::terminate();
        };
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<typename T>
    constexpr auto expects(std::source_location location) noexcept -> decltype(auto) {
        return [location = std::move(location)] NORETURN_LAMBDA(auto&& error) -> std::optional<T> {
            std::println(getSTDErr(),
                         "{} failed in \n"
                         "    > file:     {}\n"
                         "      line:     {}\n"
                         "      function: {}\n"
                         "      error value:  {}",
                         ConsoleStyle { .fg        = ConsoleColor::Red,
                                        .modifiers = StyleModifier::Bold | StyleModifier::Inverse }
                             | "[Ensures]",
                         ConsoleStyle { .fg = ConsoleColor::Yellow } | location.file_name(),
                         ConsoleStyle { .fg = ConsoleColor::Blue } | location.line(),
                         ConsoleStyle { .fg = ConsoleColor::Green } | location.function_name(),
                         ConsoleStyle { .fg = ConsoleColor::Red, .modifiers = StyleModifier::Bold }
                             | std::forward<decltype(error)>(error));

            std::terminate();
        };
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    constexpr auto expectsWithMessage(std::string&& message, std::source_location location) noexcept
        -> decltype(auto) {
        return [message = std::move(message), location = std::move(location)] NORETURN_LAMBDA(
                   auto&& error) -> std::expected<void, CanonicalType<decltype(error)>> {
            std::println(getSTDErr(),
                         "{} failed in \n"
                         "    > file:     {}\n"
                         "      line:     {}\n"
                         "      function: {}\n"
                         "      message:  {}\n",
                         "      error value:  {}",
                         ConsoleStyle { .fg        = ConsoleColor::Red,
                                        .modifiers = StyleModifier::Bold | StyleModifier::Inverse }
                             | "[Ensures]",
                         ConsoleStyle { .fg = ConsoleColor::Yellow } | location.file_name(),
                         ConsoleStyle { .fg = ConsoleColor::Blue } | location.line(),
                         ConsoleStyle { .fg = ConsoleColor::Green } | location.function_name(),
                         ConsoleStyle { .fg = ConsoleColor::Red, .modifiers = StyleModifier::Bold }
                             | message,
                         ConsoleStyle { .fg = ConsoleColor::Red, .modifiers = StyleModifier::Bold }
                             | std::forward<decltype(error)>(error));

            std::terminate();
        };
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    constexpr auto expects(std::source_location location) noexcept -> decltype(auto) {
        return [location = std::move(location)] NORETURN_LAMBDA(
                   auto&& error) -> std::expected<void, CanonicalType<decltype(error)>> {
            std::println(getSTDErr(),
                         "{} failed in \n"
                         "    > file:     {}\n"
                         "      line:     {}\n"
                         "      function: {}\n"
                         "      error value:  {}",
                         ConsoleStyle { .fg        = ConsoleColor::Red,
                                        .modifiers = StyleModifier::Bold | StyleModifier::Inverse }
                             | "[Ensures]",
                         ConsoleStyle { .fg = ConsoleColor::Yellow } | location.file_name(),
                         ConsoleStyle { .fg = ConsoleColor::Blue } | location.line(),
                         ConsoleStyle { .fg = ConsoleColor::Green } | location.function_name(),
                         ConsoleStyle { .fg = ConsoleColor::Red, .modifiers = StyleModifier::Bold }
                             | std::forward<decltype(error)>(error));

            std::terminate();
        };
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    constexpr auto log(std::invocable auto&& logger, std::string&& message) noexcept
        -> decltype(auto) {
        return [logger = std::forward<decltype(logger)>, message = std::move(message)](
                   auto&& error) -> std::expected<void, CanonicalType<decltype(error)>> {
            logger(message, error);

            return {};
        };
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    constexpr auto throwError() noexcept -> decltype(auto) {
        return [] NORETURN_LAMBDA(
                   auto&& error) static -> std::expected<void, CanonicalType<decltype(error)>> {
            throw std::forward<decltype(error)>(error);
        };
    }
} // namespace stormkit::core
