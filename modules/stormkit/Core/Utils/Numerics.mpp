// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/PlatformMacro.hpp>

#if not defined(__STDCPP_FLOAT32_T__) or not defined(__STDCPP_FLOAT64_T__) \
    or not defined(__STDCPP_FLOAT128_T__)
    #ifdef STORMKIT_LIBCXX
        #include <bits/floatn.h>
    #endif
#endif

export module stormkit.Core:Utils.Numerics;

import std;

import :Meta.Traits;
import :Meta.Concepts;
import :TypeSafe.AsCast;

import :Coroutines;

export namespace stormkit::core {
    using UInt8  = std::uint8_t;
    using UInt16 = std::uint16_t;
    using UInt32 = std::uint32_t;
    using UInt64 = std::uint64_t;
    using UInt   = std::uint_fast32_t;

    using Int8  = std::int8_t;
    using Int16 = std::int16_t;
    using Int32 = std::int32_t;
    using Int64 = std::int64_t;
    using Int   = std::int_fast32_t;

#ifdef __STDCPP_FLOAT16_T__
    using Float16 = std::float16_t;
#else
    using Float16 = _Float16;
#endif

#ifdef __STDCPP_FLOAT32_T__
    using Float32 = std::float32_t;
#else
    using Float32 = _Float32;
#endif
#ifdef __STDCPP_FLOAT64_T__
    using Float64 = std::float64_t;
#else
    using Float64 = _Float64;
#endif
#ifdef __STDCPP_FLOAT128_T__
    using Float128 = std::float128_t;
#else
    // using Float128 = _Float128; // TODO provide a fallback
#endif
    using Float = Float32;

    using RangeExtent = std::size_t;
    using RangeOffset = std::ptrdiff_t;

    using Secondf = std::chrono::duration<float, std::chrono::seconds::period>;

    template<typename First, typename Second>
    struct IsValueQueryer {
        IsValueQueryer()                      = delete;
        IsValueQueryer(const IsValueQueryer&) = delete;
        auto operator=(const IsValueQueryer&) = delete;
        IsValueQueryer(IsValueQueryer&&)      = delete;
        auto operator=(IsValueQueryer&&)      = delete;

        static constexpr auto operator()(const First&, const Second&) noexcept -> Boolean
            = delete("No IsValueQueryer defined for this type");
    };

    template<typename First, typename Second>
    concept IsValueQueryerable = requires(const First& first, const Second& second) {
        { IsValueQueryer<First, Second>::operator()(first, second) } -> IsBooleanTestable;
    };

    template<typename First, typename Second>
        requires IsValueQueryerable<First, Second>
    [[nodiscard]] constexpr auto is(const First& first, const Second&) noexcept -> Boolean;

    template<typename First, std::equality_comparable_with<First> Second>
        requires(not(IsFloatingPoint<First> and IsFloatingPoint<Second>)
                 and not(IsIntegral<First> and IsIntegral<Second> and not Is<First, Second>))
    struct IsValueQueryer<First, Second> {
        [[nodiscard]] static constexpr auto operator()(const First&  first,
                                                       const Second& second) noexcept -> Boolean;
    };

    template<IsFloatingPoint T>
    inline constexpr auto Epsilon = std::numeric_limits<T>::epsilon();

    template<IsFloatingPoint First, IsFloatingPoint Second>
        requires(Is<First, Second>)
    struct IsValueQueryer<First, Second> {
        [[nodiscard]] static constexpr auto operator()(const First&  first,
                                                       const Second& second,
                                                       const First&  epsilon
                                                       = Epsilon<First>) noexcept -> Boolean;
    };

    template<IsFloatingPoint First, IsFloatingPoint Second>
        requires(not Is<First, Second>)
    struct IsValueQueryer<First, Second> {
        using EpsilonT = SafeNarrowHelperOtherType<First, Second>;
        [[nodiscard]] static constexpr auto operator()(const First&    first,
                                                       const Second&   second,
                                                       const EpsilonT& epsilon
                                                       = Epsilon<EpsilonT>) noexcept -> Boolean;
    };

    template<IsIntegral First, IsIntegral Second>
        requires(not Is<First, Second>)
    struct IsValueQueryer<First, Second> {
        [[nodiscard]] static constexpr auto operator()(const First&  first,
                                                       const Second& second) noexcept -> Boolean;
    };

    template<IsArithmetic U, IsArithmetic T>
    [[nodiscard]] constexpr auto map(const T& x,
                                     const T& in_min,
                                     const T& in_max,
                                     const U& out_min,
                                     const U& out_max) noexcept -> U;

    template<IsArithmetic T>
    struct NumericsRange {
        using RangeType = T;
        T begin;
        T end;
        T step = T { 1 };
    };

    template<class T>
    concept IsNumericsRange = requires(const T& t) {
        t.begin;
        t.end;
        t.step;
        typename T::RangeType;
    };

    template<class T>
    concept IsNumericsRangePure = IsNumericsRange<PureType<T>>;

    template<IsArithmetic T>
    [[nodiscard]] constexpr auto range(const T& end) noexcept -> decltype(auto);

    template<IsArithmetic T, IsArithmetic U, IsArithmetic V = U>
    [[nodiscard]] constexpr auto
        range(const T& begin, const U& end, const V& step = V { 1 }) noexcept -> decltype(auto);

    [[nodiscard]] constexpr auto range(IsNumericsRangePure auto&& range) noexcept -> decltype(auto);

    template<IsArithmetic... Args>
    [[nodiscard]] constexpr auto multiRange(const Args&... args) noexcept -> decltype(auto);

    template<IsNumericsRangePure... Args>
    [[nodiscard]] constexpr auto multiRange(Args&&... args) noexcept -> decltype(auto);
} // namespace stormkit::core

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
#define FOR(a, b)  for (auto a = b.begin; a < b.end; a += b.step)
#define YIELD(...) co_yield { __VA_ARGS__ };

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNumericsRange T, IsNumericsRange U>
    auto rangeImplementation(T a, U b) noexcept
        -> std::generator<std::tuple<decltype(a.begin), decltype(b.begin)>> {
        FOR(i, a)
        FOR(j, b)
        YIELD(i, j)
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNumericsRange T, IsNumericsRange U, IsNumericsRange V>
    auto rangeImplementation(T a, U b, V c) noexcept
        -> std::generator<std::tuple<decltype(a.begin), decltype(b.begin), decltype(c.begin)>> {
        FOR(i, a)
        FOR(j, b)
        FOR(k, c)
        YIELD(i, j, k)
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNumericsRange T, IsNumericsRange U, IsNumericsRange V, IsNumericsRange W>
    auto rangeImplementation(T a, U b, V c, W d) noexcept -> std::generator<
        std::tuple<decltype(a.begin), decltype(b.begin), decltype(c.begin), decltype(d.begin)>> {
        FOR(i, a)
        FOR(j, b)
        FOR(k, c)
        FOR(l, d)
        YIELD(i, j, k, l)
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNumericsRange T,
             IsNumericsRange U,
             IsNumericsRange V,
             IsNumericsRange W,
             IsNumericsRange X>
    auto rangeImplementation(T a, U b, V c, W d, X e) noexcept
        -> std::generator<std::tuple<decltype(a.begin),
                                     decltype(b.begin),
                                     decltype(c.begin),
                                     decltype(d.begin),
                                     decltype(e.begin)>> {
        FOR(i, a)
        FOR(j, b)
        FOR(k, c)
        FOR(l, d)
        FOR(m, e)
        YIELD(i, j, k, l, m)
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNumericsRange T,
             IsNumericsRange U,
             IsNumericsRange V,
             IsNumericsRange W,
             IsNumericsRange X,
             IsNumericsRange Y>
    auto rangeImplementation(T a, U b, V c, W d, X e, Y f) noexcept
        -> std::generator<std::tuple<decltype(a.begin),
                                     decltype(b.begin),
                                     decltype(c.begin),
                                     decltype(d.begin),
                                     decltype(e.begin),
                                     decltype(f.begin)>> {
        FOR(i, a)
        FOR(j, b)
        FOR(k, c)
        FOR(l, d)
        FOR(m, e)
        FOR(n, f)
        YIELD(i, j, k, l, m, n)
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNumericsRange T,
             IsNumericsRange U,
             IsNumericsRange V,
             IsNumericsRange W,
             IsNumericsRange X,
             IsNumericsRange Y,
             IsNumericsRange Z>
    auto rangeImplementation(T a, U b, V c, W d, X e, Y f, Z g) noexcept
        -> std::generator<std::tuple<decltype(a.begin),
                                     decltype(b.begin),
                                     decltype(c.begin),
                                     decltype(d.begin),
                                     decltype(e.begin),
                                     decltype(f.begin),
                                     decltype(g.begin)>> {
        FOR(i, a)
        FOR(j, b)
        FOR(k, c)
        FOR(l, d)
        FOR(m, e)
        FOR(n, f)
        FOR(o, g)
        YIELD(i, j, k, l, m, n, g)
    }

#undef FOR
#undef YIELD

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename First, std::equality_comparable_with<First> Second>
        requires(not(IsFloatingPoint<First> and IsFloatingPoint<Second>)
                 and not(IsIntegral<First> and IsIntegral<Second> and not Is<First, Second>))
    STORMKIT_FORCE_INLINE constexpr auto
        IsValueQueryer<First, Second>::operator()(const First& first, const Second& second) noexcept
        -> Boolean {
        return first == second;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsFloatingPoint First, IsFloatingPoint Second>
        requires(Is<First, Second>)
    STORMKIT_FORCE_INLINE constexpr auto
        IsValueQueryer<First, Second>::operator()(const First&  first,
                                                  const Second& second,
                                                  const First&  epsilon) noexcept -> Boolean {
        const auto diff   = std::abs(first - second);
        const auto max_ab = std::max(std::abs(first), std::abs(second));

        if (max_ab >= First { 1 }) return diff <= (epsilon * max_ab);
        else if (max_ab > First { 0 })
            return (diff / max_ab) <= epsilon;

        return false;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsFloatingPoint First, IsFloatingPoint Second>
        requires(not Is<First, Second>)
    STORMKIT_FORCE_INLINE constexpr auto
        IsValueQueryer<First, Second>::operator()(const First&    first,
                                                  const Second&   second,
                                                  const EpsilonT& epsilon) noexcept -> Boolean {
        using Type = SafeNarrowHelperType<First, Second>;
        return IsValueQueryer<Type, Type>::operator()(narrow<Type>(first),
                                                      narrow<Type>(second),
                                                      narrow<Type>(epsilon));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsIntegral First, IsIntegral Second>
        requires(not Is<First, Second>)
    STORMKIT_FORCE_INLINE constexpr auto
        IsValueQueryer<First, Second>::operator()(const First& first, const Second& second) noexcept
        -> Boolean {
        using Type = SafeNarrowHelperType<First, Second>;

        return IsValueQueryer<Type, Type>::operator()(narrow<Type>(first), narrow<Type>(second));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsArithmetic U, IsArithmetic T>
    STORMKIT_FORCE_INLINE constexpr auto map(const T& x,
                                             const T& in_min,
                                             const T& in_max,
                                             const U& out_min,
                                             const U& out_max) noexcept -> U {
        return narrow<U>((x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min);
    }

    template<typename T>
    struct Range {
        using Type = typename T::RangeType;

        struct Iterator {
            Iterator(Type val, Type step) noexcept : m_val { val }, m_step { step } {}

            auto operator+(std::size_t index) -> decltype(auto) {
                auto cpy = auto(*this);
                for (auto i = 0u; i < index; ++i) ++cpy;
                return cpy;
            }

            auto operator++() -> decltype(auto) {
                m_val += m_step;
                return *this;
            }

            auto operator++(int) -> decltype(auto) {
                auto old = auto(*this);
                m_val += m_step;
                return old;
            }

            auto operator--() -> decltype(auto) {
                m_val -= m_step;
                return *this;
            }

            auto operator--(int) -> decltype(auto) {
                auto old = auto(*this);
                m_val -= m_step;
                return old;
            }

            auto operator==(const Iterator& other) const noexcept { return m_val == other.m_val; }

            auto operator!=(const Iterator& other) const noexcept { return m_val != other.m_val; }

            template<typename Self>
            auto operator*(this Self&& self) noexcept -> decltype(auto) {
                return std::forward_like<Self>(self.m_val);
            }

          private:
            Type m_val;
            Type m_step;
        };

        constexpr explicit Range(T&& range)
            : m_begin { range.begin, range.step }, m_end { range.end, range.step } {}

        template<typename Self>
        constexpr auto begin(this Self&& self) noexcept -> decltype(auto) {
            return std::forward_like<Self>(self.m_begin);
        }

        constexpr auto cbegin() const noexcept -> const Iterator& { return m_begin; }

        template<typename Self>
        constexpr auto end(this Self&& self) noexcept -> decltype(auto) {
            return std::forward_like<Self>(self.m_end);
        }

        constexpr auto cend() const noexcept -> const Iterator& { return m_end; }

        template<typename Self>
        auto operator[](this Self&& self, std::size_t index) noexcept -> decltype(auto) {
            return *(std::forward<Self>(self).begin() + index);
        }

      private:
        Iterator m_begin;
        Iterator m_end;
    };

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr auto range(IsNumericsRangePure auto&& range) noexcept
        -> decltype(auto) {
        // return ranges::views::iota(range.begin, range.end) | ranges::view::stride(range.step);
        return Range { std::forward<decltype(range)>(range) };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsArithmetic T, IsArithmetic U, IsArithmetic V>
    STORMKIT_FORCE_INLINE constexpr auto range(const T& begin, const U& end, const V& step) noexcept
        -> decltype(auto) {
        using Type = SafeNarrowHelperType<SafeNarrowHelperType<T, U>, V>;
        return range(NumericsRange<Type> { .begin = narrow<Type>(begin),
                                           .end   = narrow<Type>(end),
                                           .step  = narrow<Type>(step) });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsArithmetic T>
    STORMKIT_FORCE_INLINE constexpr auto range(const T& end) noexcept -> decltype(auto) {
        return range(T { 0 }, end);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsArithmetic... Args>
    STORMKIT_FORCE_INLINE constexpr auto multiRange(const Args&... args) noexcept
        -> decltype(auto) {
        return rangeImplementation(NumericsRange<Args> { .begin = 0, .end = args }...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNumericsRangePure... Args>
    STORMKIT_FORCE_INLINE constexpr auto multiRange(Args&&... args) noexcept -> decltype(auto) {
        return rangeImplementation(std::forward<Args>(args)...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename First, typename Second>
        requires IsValueQueryerable<First, Second>
    STORMKIT_FORCE_INLINE constexpr auto is(const First& first, const Second& second) noexcept
        -> Boolean {
        return IsValueQueryer<First, Second>::operator()(first, second);
    }

} // namespace stormkit::core
