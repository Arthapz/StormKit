// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

export module stormkit.Core:Utils.AsCast;

import std;

import <stormkit/Core/PlatformMacro.hpp>;

import :Utils.Assert;
import :Meta.Concepts;
import :Meta.Traits;

export namespace stormkit::core {
    template<IsNotReference To, typename... Args>
    [[nodiscard]] constexpr auto is(const std::variant<Args...>& variant) noexcept -> bool;

    template<IsPolymorphic To, IsIndirection From>
        requires(IsPolymorphic<RawType<From>> and Is<To, RawType<From>>)
    [[nodiscard]] constexpr auto is(From&& value) noexcept -> bool;

    // variants
    template<IsNotReference To, typename... Args>
    [[nodiscard]] constexpr auto as(std::variant<Args...>& variant) noexcept -> decltype(auto);

    template<IsNotReference To, typename... Args>
    [[nodiscard]] constexpr auto as(std::variant<Args...>&& variant) noexcept -> decltype(auto);

    template<IsNotReference To, typename... Args>
    [[nodiscard]] constexpr auto as(const std::variant<Args...>& variant) noexcept
        -> decltype(auto);

    template<IsNotReference To, typename... Args>
    [[nodiscard]] constexpr auto as(const std::variant<Args...>&& variant) noexcept
        -> decltype(auto);

    // polymorphic
    template<IsRawIndirection To, IsRawIndirection From>
        requires(IsPolymorphic<RawType<From>> and IsPolymorphic<RawType<To>> and
                 Is<RawType<To>, RawType<From>>)
    [[nodiscard]] constexpr auto as(From&& value) -> To;

    // std::byte* / char*
    template<IsRawPointer To, IsRawIndirection From>
        requires IsByte<RawType<To>>
    [[nodiscard]] constexpr auto as(From&& value) noexcept -> To;

    template<IsRawPointer To, IsRawIndirection From>
        requires IsByte<RawType<From>>
    [[nodiscard]] constexpr auto as(From&& value) noexcept -> To;

    // enumerations
    // template<IsEnumeration To, std::integral From>
    // [[nodiscard]] constexpr auto as(From&& value) noexcept -> To;

    template<IsEnumeration To, IsEnumeration From>
    [[nodiscard]] constexpr auto as(From&& value) noexcept -> To;

    template<std::integral To, IsEnumeration From>
    [[nodiscard]] constexpr auto as(From&& value) noexcept -> To;

    // explicit casts
    template<IsNot<std::string> To, IsBraceInitializableTo<To> From>
        requires IsNot<From, To>
    [[nodiscard]] constexpr auto as(From&& from) noexcept -> To;

    template<typename To, Is<To> From>
    [[nodiscard]] constexpr auto as(From&& from) noexcept -> To;

    // safe numeric types
    template<typename To, typename From>
    concept IsNarrowing =
        IsArithmetic<To> and IsArithmetic<From> and IsBraceInitializableTo<PureType<From>, To>;

    template<typename To, typename From>
    concept IsNarrowingWithError = [] {
        static_assert(IsNarrowing<To, From>,
                      "as cast only allow non-narrowing casts, use core::narrow to "
                      "explicitly narrow cast");
        return true;
    }();

    template<IsArithmetic To, IsArithmetic From>
        requires(IsNot<From, To> and not IsNarrowing<To, From>)
    [[nodiscard]] constexpr auto as(From&& value) noexcept -> To;

    // std::byte
    template<std::integral To, IsByte From>
    [[nodiscard]] constexpr auto as(From&& value) noexcept -> To;

    template<IsByte To, std::integral From>
    [[nodiscard]] constexpr auto as(From&& value) noexcept -> To;

    // else
    template<std::integral To, std::integral From>
    [[nodiscard]] constexpr auto narrow(From value) noexcept -> To;

    template<std::floating_point To, std::integral From>
    [[nodiscard]] constexpr auto narrow(From value) noexcept -> To;

    template<std::integral To, std::floating_point From>
    [[nodiscard]] constexpr auto narrow(From value) noexcept -> To;

    template<std::floating_point To, std::floating_point From>
    [[nodiscard]] constexpr auto narrow(From value) noexcept -> To;
    // template<class To, typename From>
    //     requires(not std::convertible_to<From, To> and not IsArithmetic<To> and
    //              not IsArithmetic<From>)
    // [[nodiscard]] constexpr auto as(From&& value) noexcept -> To;
} // namespace stormkit::core

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNotReference To, typename... Args>
    STORMKIT_FORCE_INLINE constexpr auto is(const std::variant<Args...>& variant) noexcept -> bool {
        return std::holds_alternative<To>(variant);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsPolymorphic To, IsIndirection From>
        requires(IsPolymorphic<RawType<From>> and Is<To, RawType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto is(From&& value) noexcept -> bool {
        if constexpr (IsLValueReference<From> and not IsPointer<std::remove_reference_t<From>>)
            return dynamic_cast<const To *>(&std::forward<From>(value)) != nullptr;
        else
            return dynamic_cast<const To *>(std::to_address(std::forward<From>(value))) != nullptr;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNotReference To, typename... Args>
    STORMKIT_FORCE_INLINE constexpr auto as(std::variant<Args...>& variant) noexcept
        -> decltype(auto) {
        expects(is<To, Args...>(variant));

        return std::get<To>(variant);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNotReference To, typename... Args>
    STORMKIT_FORCE_INLINE constexpr auto as(std::variant<Args...>&& variant) noexcept
        -> decltype(auto) {
        expects(is<To, Args...>(variant));

        return std::get<To>(std::move(variant));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNotReference To, typename... Args>
    STORMKIT_FORCE_INLINE constexpr auto as(const std::variant<Args...>& variant) noexcept
        -> decltype(auto) {
        expects(is<To, Args...>(variant));

        return std::get<To>(variant);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNotReference To, typename... Args>
    STORMKIT_FORCE_INLINE constexpr auto as(const std::variant<Args...>&& variant) noexcept
        -> decltype(auto) {
        expects(is<To, Args...>(variant));

        return std::get<To>(std::move(variant));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsRawIndirection To, IsRawIndirection From>
        requires(IsPolymorphic<RawType<From>> and IsPolymorphic<RawType<To>> and
                 Is<RawType<To>, RawType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto as(From&& value) -> To {
        expects(is<RawType<To>>(value));

        if constexpr (IsLValueReference<From>)
            if constexpr (IsLValueReference<To>) return static_cast<To>(value);
            else
                return static_cast<To>(&value);
        else {
            if constexpr (IsLValueReference<To>) return static_cast<To>(*value);
            else
                return static_cast<To>(value);
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsRawPointer To, IsRawIndirection From>
        requires IsByte<RawType<To>>
    STORMKIT_FORCE_INLINE constexpr auto as(From&& value) noexcept -> To {
        if constexpr (IsLValueReference<From> and not IsRawPointer<std::remove_reference_t<From>>)
            return std::bit_cast<To>(&value);
        else
            return std::bit_cast<To>(value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsRawPointer To, IsRawIndirection From>
        requires IsByte<RawType<From>>
    STORMKIT_FORCE_INLINE constexpr auto as(From&& value) noexcept -> To {
        if constexpr (IsLValueReference<From> and not IsRawPointer<std::remove_reference_t<From>>)
            return std::bit_cast<To>(&value);
        else
            return std::bit_cast<To>(value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsEnumeration To, IsEnumeration From>
    STORMKIT_FORCE_INLINE constexpr auto as(From&& value) noexcept -> To {
        return as<To>(as<std::underlying_type_t<From>>(std::forward<From>(value)));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::integral To, IsEnumeration From>
    STORMKIT_FORCE_INLINE constexpr auto as(From&& value) noexcept -> To {
        return as<To>(static_cast<std::underlying_type_t<From>>(std::forward<From>(value)));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNot<std::string> To, IsBraceInitializableTo<To> From>
        requires IsNot<From, To>
    STORMKIT_FORCE_INLINE constexpr auto as(From&& from) noexcept -> To {
        return To { std::forward<From>(from) };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename To, Is<To> From>
    STORMKIT_FORCE_INLINE constexpr auto as(From&& from) noexcept -> To {
        return std::forward<From>(from);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsArithmetic To, IsArithmetic From>
        requires(IsNot<From, To> and not IsNarrowing<To, From>)
    STORMKIT_FORCE_INLINE constexpr auto as(From&& value) noexcept -> To {
        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::integral To, IsByte From>
    STORMKIT_FORCE_INLINE constexpr auto as(From&& value) noexcept -> To {
        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsByte To, std::integral From>
    STORMKIT_FORCE_INLINE constexpr auto as(From&& value) noexcept -> To {
        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::integral To, std::integral From>
    STORMKIT_FORCE_INLINE constexpr auto narrow(From value) noexcept -> To {
        if constexpr (Is<From, To>) {
            expects(std::numeric_limits<To>::lowest() <= value);
            expects(std::numeric_limits<To>::max() > value);
        } else {
            if constexpr (std::signed_integral<To> and std::unsigned_integral<From>) {
                using Type = SafeTypeHelperType<To, From>;

                expects(static_cast<Type>(std::numeric_limits<To>::max()) >
                        static_cast<Type>(value));
            } else {
                using Type = SafeTypeHelperType<To, From>;

                expects(static_cast<Type>(std::numeric_limits<To>::lowest()) <=
                        static_cast<Type>(value));
                expects(static_cast<Type>(std::numeric_limits<To>::max()) >
                        static_cast<Type>(value));
            }
        }

        return static_cast<To>(value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::floating_point To, std::floating_point From>
    STORMKIT_FORCE_INLINE constexpr auto narrow(From value) noexcept -> To {
        expects(std::numeric_limits<To>::lowest() < value);
        expects(std::numeric_limits<To>::max() > value);

        return static_cast<To>(value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::floating_point To, std::integral From>
    STORMKIT_FORCE_INLINE constexpr auto narrow(From value) noexcept -> To {
        using Type = SafeTypeHelperType<To, From>;

        expects(static_cast<Type>(std::numeric_limits<To>::lowest()) < static_cast<Type>(value));
        expects(static_cast<Type>(std::numeric_limits<To>::max()) > static_cast<Type>(value));

        return static_cast<To>(value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::integral To, std::floating_point From>
    STORMKIT_FORCE_INLINE constexpr auto narrow(From value) noexcept -> To {
        using Type = SafeTypeHelperType<To, From>;

        expects(static_cast<Type>(std::numeric_limits<To>::lowest()) < static_cast<Type>(value));
        expects(static_cast<Type>(std::numeric_limits<To>::max()) > static_cast<Type>(value));

        return static_cast<To>(value);
    }

} // namespace stormkit::core
