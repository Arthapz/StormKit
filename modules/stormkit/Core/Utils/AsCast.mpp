// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/PlatformMacro.hpp>

export module stormkit.Core:Utils.AsCast;

import std;

import :Utils.Assert;
import :Meta.Concepts;
import :Meta.Traits;

export namespace stormkit::core { inline namespace casts {
    // default
    template<typename To, typename Args>
    struct IsQueryer {
        IsQueryer()                      = delete;
        IsQueryer(const IsQueryer&)      = delete;
        auto operator=(const IsQueryer&) = delete;
    };

    template<typename To, typename From>
    concept IsQueryerable = requires(From&& from) { IsQueryer<To, From>::operator()(from); };

    template<typename To, typename From>
    [[nodiscard]] constexpr auto is(From&& from) noexcept -> bool;

    template<IsNotReference To, IsVariantType From>
    struct IsQueryer<To, From> {
        [[nodiscard]] static constexpr auto operator()(const From& variant) noexcept -> bool;
    };

    template<IsPolymorphic To, IsIndirection From>
        requires(IsPolymorphic<RawType<From>> and Is<To, RawType<From>>)
    struct IsQueryer<To, From> {
        [[nodiscard]] static constexpr auto operator()(const From &value) noexcept -> bool;
    };

    // default
    template<typename To, typename Args>
    struct AsCaster {
        AsCaster()                      = delete;
        AsCaster(const AsCaster&)       = delete;
        auto operator=(const AsCaster&) = delete;
    };

    template<typename To, typename From>
    concept IsAsCastable = requires(From&& from) { AsCaster<To, From>::operator()(from); };

    template<typename To, typename From>
        requires IsAsCastable<To, From>
    [[nodiscard]] constexpr auto as(From&& from) noexcept -> decltype(auto);

    // variants
    template<IsNotReference To, typename From>
        requires(IsVariantType<PureType<From>>)
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From variant) noexcept -> decltype(auto);
    };

    // polymorphic
    template<IsRawIndirection To, IsRawIndirection From>
        requires(IsPolymorphic<RawType<From>> and IsPolymorphic<RawType<To>> and
                 Is<RawType<To>, RawType<From>>)
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) -> To;
    };

    // std::byte* / char*
    template<IsRawPointer To, IsRawIndirection From>
        requires IsByte<RawType<To>>
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    template<IsRawPointer To, IsRawIndirection From>
        requires IsByte<RawType<From>>
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    // enumerations
    template<IsEnumeration To, typename From>
        requires IsIntegral<PureType<From>> and Is<PureType<From>, UnderlyingType<To>>
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    template<IsEnumeration To, typename From>
        requires IsEnumeration<PureType<From>> and
                 Is<UnderlyingType<To>, UnderlyingType<PureType<From>>>
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    template<IsIntegral To, typename From>
        requires IsEnumeration<PureType<From>> and Is<To, UnderlyingType<PureType<From>>>
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    struct Underlying {};

    template<Is<Underlying> To, typename From>
        requires IsEnumeration<PureType<From>>
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto
            operator()(From value) noexcept -> UnderlyingType<PureType<From>>;
    };

    // explicit casts
    template<IsNot<std::string> To, typename From>
        requires(IsBraceInitializableTo<PureType<From>, To> and not IsPure<From, To> and
                 not IsEnumerationPure<To> and not IsEnumerationPure<From> and
                 not IsBytePure<To> and not IsBytePure<From>)
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From from) noexcept -> To;
    };

    template<typename To, IsPure<To> From>
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From from) noexcept -> To;
    };

    // safe numeric types
    template<IsArithmetic To, typename From>
        requires(IsArithmetic<PureType<From>> and not Is<PureType<From>, To> and
                 not IsNarrowing<To, PureType<From>>)
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    // std::byte
    template<IsIntegral To, typename From>
        requires IsBytePure<From>
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    template<typename T>
    concept IsSafeCastableToByte =
        IsOneOf<PureType<T>, char, unsigned char, signed char, std::byte>;

    template<IsByte To, typename From>
        requires IsSafeCastableToByte<PureType<From>>
    struct AsCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    // default
    template<typename To, typename Args>
    struct NarrowCaster {
        NarrowCaster()                      = delete;
        NarrowCaster(const NarrowCaster&)   = delete;
        auto operator=(const NarrowCaster&) = delete;
    };

    template<typename To, typename From>
    [[nodiscard]] constexpr auto narrow(From&& from) noexcept -> decltype(auto);

    // narrowing
    template<IsIntegral To, typename From>
        requires(IsIntegral<PureType<From>>)
    struct NarrowCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    template<IsFloatingPoint To, typename From>
        requires(IsIntegral<PureType<From>>)
    struct NarrowCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    template<IsFloatingPoint To, typename From>
        requires(IsFloatingPoint<PureType<From>>)
    struct NarrowCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    template<IsIntegral To, typename From>
        requires(IsFloatingPoint<PureType<From>>)
    struct NarrowCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    template<IsEnumeration To, typename From>
        requires(IsIntegral<PureType<From>>)
    struct NarrowCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    template<IsEnumeration To, typename From>
        requires(IsEnumeration<PureType<From>>)
    struct NarrowCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    template<IsIntegral To, typename From>
        requires(IsEnumeration<PureType<From>>)
    struct NarrowCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    template<IsByte To, typename From>
        requires(IsIntegral<PureType<From>> and not IsSafeCastableToByte<PureType<From>>)
    struct NarrowCaster<To, From> {
        [[nodiscard]] static constexpr auto operator()(From value) noexcept -> To;
    };

    // template<class To, typename From>
    //     requires(not std::convertible_to<From, To> and not IsArithmetic<To> and
    //              not IsArithmetic<From>)
    // [[nodiscard]] constexpr auto as(From&& value) noexcept -> To;
}} // namespace stormkit::core::casts

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core { inline namespace casts {
    /////////////////////////////////////
    /////////////////////////////////////
    template<typename To, typename From>
    STORMKIT_FORCE_INLINE constexpr auto is([[maybe_unused]] From&& from) noexcept -> bool {
        if constexpr (IsQueryerable<To, From>)
            return IsQueryer<To, PureType<From>>::operator()(std::forward<From>(from));
        else
            return Is<To, PureType<From>>;

        std::unreachable();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNotReference To, IsVariantType From>
    STORMKIT_FORCE_INLINE constexpr auto
        IsQueryer<To, From>::operator()(const From& variant) noexcept -> bool {
        return std::holds_alternative<To>(variant);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsPolymorphic To, IsIndirection From>
        requires(IsPolymorphic<RawType<From>> and Is<To, RawType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        IsQueryer<To, From>::operator()(const From &value) noexcept -> bool {
        if constexpr (IsLValueReference<From> and not IsPointer<PureType<From>>)
            return dynamic_cast<const To*>(&std::forward<From>(value)) != nullptr;
        else
            return dynamic_cast<const To*>(std::to_address(std::forward<From>(value))) != nullptr;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename To, typename From>
        requires IsAsCastable<To, From>
    STORMKIT_FORCE_INLINE constexpr auto as(From&& from) noexcept -> decltype(auto) {
        return AsCaster<To, From>::operator()(std::forward<From>(from));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNotReference To, typename From>
        requires(IsVariantType<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        AsCaster<To, From>::operator()(From variant) noexcept -> decltype(auto) {
        expects(is<To, From>(variant));

        return std::get<To>(std::forward<From>(variant));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsRawIndirection To, IsRawIndirection From>
        requires(IsPolymorphic<RawType<From>> and IsPolymorphic<RawType<To>> and
                 Is<RawType<To>, RawType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From value) -> To {
        expects(is<To>(value));

        if constexpr (IsLValueReference<From>)
            if constexpr (IsLValueReference<To>) return static_cast<To>(std::forward<From>(value));
            else
                return static_cast<To>(&std::forward<From>(value));
        else {
            if constexpr (IsLValueReference<To>) return static_cast<To>(*std::forward<From>(value));
            else
                return static_cast<To>(std::forward<From>(value));
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsRawPointer To, IsRawIndirection From>
        requires IsByte<RawType<To>>
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From value) noexcept -> To {
        if constexpr (IsLValueReference<From> and not IsRawPointer<PureType<From>>)
            return std::bit_cast<To>(&std::forward<From>(value));
        else
            return std::bit_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsRawPointer To, IsRawIndirection From>
        requires IsByte<RawType<From>>
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From value) noexcept -> To {
        if constexpr (IsLValueReference<From> and not IsRawPointer<PureType<From>>)
            return std::bit_cast<To>(&std::forward<From>(value));
        else
            return std::bit_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsEnumeration To, typename From>
        requires IsIntegral<PureType<From>> and Is<PureType<From>, UnderlyingType<To>>
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From value) noexcept -> To {
        return static_cast<To>(std::forward<From>(value));
    } // namespace stormkit::core

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsEnumeration To, typename From>
        requires IsEnumeration<PureType<From>> and
                     Is<UnderlyingType<To>, UnderlyingType<PureType<From>>>
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From value) noexcept -> To {
        return as<To>(as<Underlying>(std::forward<From>(value)));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsIntegral To, typename From>
        requires IsEnumeration<PureType<From>> and Is<To, UnderlyingType<PureType<From>>>
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From value) noexcept -> To {
        return as<Underlying>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<Is<Underlying> To, typename From>
        requires IsEnumeration<PureType<From>>
    STORMKIT_FORCE_INLINE constexpr auto
        AsCaster<To, From>::operator()(From value) noexcept -> UnderlyingType<PureType<From>> {
        using T = UnderlyingType<PureType<From>>;
        return static_cast<T>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNot<std::string> To, typename From>
        requires(IsBraceInitializableTo<PureType<From>, To> and not IsPure<From, To> and
                 not IsEnumerationPure<To> and not IsEnumerationPure<From> and
                 not IsBytePure<To> and not IsBytePure<From>)
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From from) noexcept -> To {
        return To { std::forward<From>(from) };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename To, IsPure<To> From>
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From from) noexcept -> To {
        return std::forward<From>(from);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsArithmetic To, typename From>
        requires(IsArithmetic<PureType<From>> and not Is<PureType<From>, To> and
                 not IsNarrowing<To, PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From value) noexcept -> To {
        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsIntegral To, typename From>
        requires IsBytePure<From>
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From value) noexcept -> To {
        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsByte To, typename From>
        requires IsSafeCastableToByte<PureType<From>>
    STORMKIT_FORCE_INLINE constexpr auto AsCaster<To, From>::operator()(From value) noexcept -> To {
        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsIntegral To, typename From>
        requires(IsIntegral<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(From value) noexcept -> To {
        using Type = SafeNarrowHelperType<To, From>;
        if constexpr (IsPure<From, To>) {
            expects(std::numeric_limits<To>::lowest() <= value);
            expects(std::numeric_limits<To>::max() > value);
        } else {
            if constexpr (std::signed_integral<To> and std::unsigned_integral<From>) {
                expects(static_cast<Type>(std::numeric_limits<To>::max()) >
                        static_cast<Type>(value));
            } else {
                expects(static_cast<Type>(std::numeric_limits<To>::lowest()) <=
                        static_cast<Type>(value));
                expects(static_cast<Type>(std::numeric_limits<To>::max()) >
                        static_cast<Type>(value));
            }
        }

        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsFloatingPoint To, typename From>
        requires(IsIntegral<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(From value) noexcept -> To {
        expects(std::numeric_limits<To>::lowest() < value);
        expects(std::numeric_limits<To>::max() > value);

        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsFloatingPoint To, typename From>
        requires(IsFloatingPoint<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(From value) noexcept -> To {
        using Type = SafeNarrowHelperType<To, From>;

        expects(static_cast<Type>(std::numeric_limits<To>::lowest()) < static_cast<Type>(value));
        expects(static_cast<Type>(std::numeric_limits<To>::max()) > static_cast<Type>(value));

        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsIntegral To, typename From>
        requires(IsFloatingPoint<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(From value) noexcept -> To {
        using Type = SafeNarrowHelperType<To, From>;

        expects(static_cast<Type>(std::numeric_limits<To>::lowest()) < static_cast<Type>(value));
        expects(static_cast<Type>(std::numeric_limits<To>::max()) > static_cast<Type>(value));

        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsEnumeration To, typename From>
        requires(IsIntegral<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(From value) noexcept -> To {
        using T = UnderlyingType<To>;
        return as<To, T>(narrow<T>(std::forward<From>(value)));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsEnumeration To, typename From>
        requires(IsEnumeration<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(From value) noexcept -> To {
        using T = UnderlyingType<To>;
        return as<To, T>(narrow<T>(as<Underlying>(std::forward<From>(value))));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsIntegral To, typename From>
        requires(IsEnumeration<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(From value) noexcept -> To {
        return narrow<To>(as<Underlying>(std::forward<From>(value)));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsByte To, typename From>
        requires(IsIntegral<PureType<From>> and not IsSafeCastableToByte<PureType<From>>)
    STORMKIT_FORCE_INLINE constexpr auto
        NarrowCaster<To, From>::operator()(From value) noexcept -> To {
        expects(value < std::numeric_limits<std::byte>::max());
        return static_cast<To>(std::forward<From>(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename To, typename From>
    STORMKIT_FORCE_INLINE constexpr auto narrow(From&& from) noexcept -> decltype(auto) {
        return NarrowCaster<To, From>::operator()(std::forward<From>(from));
    }

}} // namespace stormkit::core::casts

#define INSTANCIATE_NARROW(x)                                   \
    { auto _ = stormkit::core::narrow<char>(x); }               \
    { auto _ = stormkit::core::narrow<signed char>(x); }        \
    { auto _ = stormkit::core::narrow<unsigned char>(x); }      \
    { auto _ = stormkit::core::narrow<signed short>(x); }       \
    { auto _ = stormkit::core::narrow<unsigned short>(x); }     \
    { auto _ = stormkit::core::narrow<signed int>(x); }         \
    { auto _ = stormkit::core::narrow<unsigned int>(x); }       \
    { auto _ = stormkit::core::narrow<signed long>(x); }        \
    { auto _ = stormkit::core::narrow<unsigned long>(x); }      \
    { auto _ = stormkit::core::narrow<signed long long>(x); }   \
    { auto _ = stormkit::core::narrow<unsigned long long>(x); } \
    { auto _ = stormkit::core::narrow<float>(x); }              \
    { auto _ = stormkit::core::narrow<double>(x); }             \
    { auto _ = stormkit::core::narrow<long double>(x); }

#define INSTANCIATE_AS(x)                                   \
    { auto _ = stormkit::core::as<char>(x); }               \
    { auto _ = stormkit::core::as<signed char>(x); }        \
    { auto _ = stormkit::core::as<unsigned char>(x); }      \
    { auto _ = stormkit::core::as<signed short>(x); }       \
    { auto _ = stormkit::core::as<unsigned short>(x); }     \
    { auto _ = stormkit::core::as<signed int>(x); }         \
    { auto _ = stormkit::core::as<unsigned int>(x); }       \
    { auto _ = stormkit::core::as<signed long>(x); }        \
    { auto _ = stormkit::core::as<unsigned long>(x); }      \
    { auto _ = stormkit::core::as<signed long long>(x); }   \
    { auto _ = stormkit::core::as<unsigned long long>(x); } \
    { auto _ = stormkit::core::as<float>(x); }              \
    { auto _ = stormkit::core::as<double>(x); }             \
    { auto _ = stormkit::core::as<long double>(x); }

auto test() {
    using schar     = signed char;
    using uchar     = unsigned char;
    using sshort    = signed short;
    using ushort    = unsigned short;
    using sint      = signed int;
    using uint      = unsigned int;
    using slong     = signed long;
    using ulong     = unsigned long;
    using slonglong = signed long long;
    using ulonglong = unsigned long long;
    using ldouble   = long double;

    INSTANCIATE_NARROW(char {})
    INSTANCIATE_NARROW(schar {})
    INSTANCIATE_NARROW(uchar {})
    INSTANCIATE_NARROW(sshort {})
    INSTANCIATE_NARROW(ushort {})
    INSTANCIATE_NARROW(sint {})
    INSTANCIATE_NARROW(uint {})
    INSTANCIATE_NARROW(slong {})
    INSTANCIATE_NARROW(ulong {})
    INSTANCIATE_NARROW(slonglong {})
    INSTANCIATE_NARROW(ulonglong {})
    INSTANCIATE_NARROW(float {})
    INSTANCIATE_NARROW(double {})
    INSTANCIATE_NARROW(ldouble {})

    // INSTANCIATE_AS(char {})
    // INSTANCIATE_AS(schar {})
    // INSTANCIATE_AS(uchar {})
    // INSTANCIATE_AS(sshort {})
    // INSTANCIATE_AS(ushort {})
    // INSTANCIATE_AS(sint {})
    // INSTANCIATE_AS(uint {})
    // INSTANCIATE_AS(slong {})
    // INSTANCIATE_AS(ulong {})
    // INSTANCIATE_AS(slonglong {})
    // INSTANCIATE_AS(ulonglong {})
    // INSTANCIATE_AS(float {})
    // INSTANCIATE_AS(double {})
    // INSTANCIATE_AS(ldouble {})
}
