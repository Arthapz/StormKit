// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

export module stormkit.Core:Utils.NakedRef;

import std;

import :Meta.Concepts;
import :Meta.Traits;
import :Utils.Assert;

export namespace stormkit::core {
    template<typename T>
    class [[nodiscard]] NakedRef {
      public:
        using UnderlyingType = T;
        using PointerType    = UnderlyingType*;
        using ReferenceType  = UnderlyingType&;

        // STL compatible
        using value_type     = UnderlyingType;
        using pointer_type   = PointerType;
        using reference_type = ReferenceType;

        constexpr NakedRef(ReferenceType value) noexcept;
        constexpr NakedRef(PointerType value) noexcept;
        constexpr ~NakedRef() noexcept;

        constexpr NakedRef(const NakedRef&) noexcept;
        constexpr NakedRef(NakedRef&&) noexcept;

        constexpr auto operator=(const NakedRef&) noexcept -> NakedRef&;
        constexpr auto operator=(NakedRef&&) noexcept -> NakedRef&;

        constexpr auto get(this auto&& self) noexcept -> decltype(auto);
        constexpr auto operator->(this auto&& self) noexcept -> decltype(auto);
        constexpr auto operator*(this auto&& self) noexcept -> decltype(auto);

        constexpr explicit operator bool() const noexcept;
        constexpr auto     hasValue() const noexcept -> bool;

        template<typename Self>
        constexpr operator std::conditional_t<std::is_const_v<Self>, const T&, T&>(
            this Self&& self) noexcept;

        template<typename Self>
        constexpr operator std::enable_if<not std::is_const_v<T>, NakedRef<const T>>(
            this Self&& self) noexcept;

      private:
        PointerType m_value;
    };

    template<typename T>
    using OptionalRef = std::optional<NakedRef<T>>;

    template<IsRawIndirection T>
        requires(not IsRValueReference<T>)
    [[nodiscard]] constexpr auto makeNakedRef(T&& value) noexcept -> decltype(auto);
    template<IsFancyPointer T>
    [[nodiscard]] constexpr auto makeNakedRef(T& value) noexcept -> decltype(auto);

    template<template<typename...> typename Out = std::vector, typename... Args>
        requires(AreIndirections<Args...>)
    [[nodiscard]] constexpr auto makeNakedRefs(Args&&... args) -> decltype(auto);
    template<template<typename, std::size_t> typename Out, typename... Args>
        requires(AreIndirections<Args...>)
    [[nodiscard]] constexpr auto makeNakedRefs(Args&&... args) -> decltype(auto);

    template<template<typename...> typename Out = std::vector>
        requires std::ranges::range<Out<int>>
    [[nodiscard]] constexpr auto toNakedRefs(std::ranges::range auto&& args) -> decltype(auto);
    template<template<typename, std::size_t> typename Out>
        requires std::ranges::range<Out<int, 1>>
    [[nodiscard]] constexpr auto toNakedRefs(std::ranges::range auto&& args) -> decltype(auto);
} // namespace stormkit::core

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr NakedRef<T>::NakedRef(ReferenceType value) noexcept : m_value { &value } {
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr NakedRef<T>::NakedRef(PointerType value) noexcept : m_value { value } {
        core::expects(m_value != nullptr);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr NakedRef<T>::~NakedRef() noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr NakedRef<T>::NakedRef(const NakedRef&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr NakedRef<T>::NakedRef(NakedRef&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto NakedRef<T>::operator=(const NakedRef&) noexcept -> NakedRef& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto NakedRef<T>::operator=(NakedRef&&) noexcept -> NakedRef& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    [[nodiscard]] constexpr auto NakedRef<T>::get(this auto&& self) noexcept -> decltype(auto) {
        return *std::forward_like<decltype(self)>(self.m_value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto NakedRef<T>::operator->(this auto&& self) noexcept -> decltype(auto) {
        return std::forward_like<decltype(self)>(self.m_value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto NakedRef<T>::operator*(this auto&& self) noexcept -> decltype(auto) {
        return std::forward_like<decltype(self)>(self.get());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr NakedRef<T>::operator bool() const noexcept {
        return m_value != nullptr;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    constexpr auto NakedRef<T>::hasValue() const noexcept -> bool {
        return operator bool();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    template<typename Self>
    constexpr NakedRef<T>::operator std::conditional_t<std::is_const_v<Self>, const T&, T&>(
        this Self &&
            self) noexcept {
        return std::forward_like<decltype(self)>(self.get());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T>
    template<typename Self>
    constexpr NakedRef<T>::operator std::enable_if<not std::is_const_v<T>,
                                                   NakedRef<const T>>(this Self && self) noexcept {
        return { std::as_const(self.m_value) };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsRawIndirection T>
        requires(not IsRValueReference<T>)
    constexpr auto makeNakedRef(T&& value) noexcept -> decltype(auto) {
        using PureT = PureType<T>;
        using Out =
            std::conditional_t<std::is_const_v<T>, NakedRef<PureT>, const NakedRef<const PureT>>;
        return Out { value };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsFancyPointer T>
    constexpr auto makeNakedRef(T& value) noexcept -> decltype(auto) {
        using PureT = PureType<typename PureType<T>::value_type>;
        using Out =
            std::conditional_t<std::is_const_v<T>, NakedRef<PureT>, const NakedRef<const PureT>>;
        return Out { value.get() };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<template<typename...> typename Out = std::vector, typename... Args>
        requires(AreIndirections<Args...>)
    constexpr auto makeNakedRefs(Args&&... args) -> decltype(auto) {
        return Out { makeNakedRef(std::forward<Args>(args))... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<template<typename, std::size_t> typename Out, typename... Args>
        requires(AreIndirections<Args...>)
    constexpr auto makeNakedRefs(Args&&... args) -> decltype(auto) {
        return Out { makeNakedRef(std::forward<Args>(args))... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<template<typename...> typename Out = std::vector>
        requires std::ranges::range<Out<int>>
    constexpr auto toNakedRefs(std::ranges::range auto&& args) -> decltype(auto) {
        return args | std::views::transform([](auto&& val) static noexcept -> decltype(auto) {
                   return makeNakedRef(std::forward<decltype(val)>(val));
               }) |
               std::ranges::to<Out>();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<template<typename, std::size_t> typename Out>
        requires std::ranges::range<Out<int, 1>>
    constexpr auto toNakedRefs(std::ranges::range auto&& args) -> decltype(auto) {
        return args | std::views::transform([](auto&& val) static noexcept -> decltype(auto) {
                   return makeNakedRef(std::forward<decltype(val)>(val));
               }) |
               std::ranges::to<Out>();
    }
} // namespace stormkit::core
