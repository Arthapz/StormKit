// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/PlatformMacro.hpp>

#ifndef STORMKIT_ASSERT
    #define STORMKIT_ASSERT 1
#endif

export module stormkit.Core:Utils.Assert;

import std;
import frozen;

import :Console;
import :Utils.Stacktrace;
import :Meta.Concepts;

export namespace stormkit::core {
    enum class AssertType {
        Assertion,
        PreCondition,
        PostCondition
    };

    auto assertBase(bool                        cond,
                    AssertType                  type,
                    std::string_view            message,
                    const std::source_location& location = std::source_location::current()) noexcept
        -> void;

    consteval auto compileTimeAssertBase(bool             cond,
                                         AssertType       type,
                                         std::string_view message) noexcept -> void;

    constexpr auto assert(bool                        cond,
                          std::string_view            message,
                          const std::source_location& location
                          = std::source_location::current()) noexcept -> void;

    constexpr auto assert(bool                        cond,
                          const std::source_location& location
                          = std::source_location::current()) noexcept -> void;

    constexpr auto expects(bool                        cond,
                           std::string_view            message,
                           const std::source_location& location
                           = std::source_location::current()) noexcept -> void;

    constexpr auto expects(bool                        cond,
                           const std::source_location& location
                           = std::source_location::current()) noexcept -> void;

    constexpr auto ensures(bool                        cond,
                           std::string_view            message,
                           const std::source_location& location
                           = std::source_location::current()) noexcept -> void;

    constexpr auto ensures(bool                        cond,
                           const std::source_location& location
                           = std::source_location::current()) noexcept -> void;
} // namespace stormkit::core

export namespace stormkit::core::casts {
    template<core::IsStrictOneOf<std::string, std::string_view> To>
    [[nodiscard]] constexpr auto as(core::AssertType t) noexcept -> To;
}

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

using namespace std::literals;
using namespace frozen::string_literals;

namespace stormkit::core::casts {
    namespace {
        constexpr auto AssertTypeToString
            = frozen::make_unordered_map<core::AssertType, frozen::string>({
                { core::AssertType::Assertion,     "Assertion"_s },
                { core::AssertType::PreCondition,  "Expects"_s   },
                { core::AssertType::PostCondition, "Ensures"_s   },
        });
    } // namespace

    /////////////////////////////////////
    /////////////////////////////////////
    template<core::IsStrictOneOf<std::string, std::string_view> To>
    constexpr auto as(core::AssertType t) noexcept -> To {
        const auto val = AssertTypeToString.at(t);
        return { std::ranges::cbegin(val), std::ranges::cend(val) };
    }
} // namespace stormkit::casts

namespace stormkit::core {
    namespace {
        std::mutex mutex;
    } // namespace

    struct StringLiteral {
        std::array<char, 512> buff;
        std::size_t           size;

        consteval auto view() noexcept -> std::string_view { return { std::data(buff), size }; }
    };

    auto constevalFailure(StringLiteral) -> void;

    /////////////////////////////////////
    /////////////////////////////////////
    consteval auto generateConstevalMessage(AssertType type, std::string_view message) noexcept
        -> StringLiteral {
        auto       result = StringLiteral {};
        const auto str    = "["s + casts::as<std::string>(type) + "] " + std::string { message };
        std::ranges::copy(str, std::begin(result.buff));
        result.size = std::size(str);
        return result;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_INLINE auto assertBase(bool                        cond,
                                    AssertType                  type,
                                    std::string_view            message,
                                    const std::source_location& location) noexcept -> void {
        if constexpr (STORMKIT_ASSERT == 1) {
            if (not cond) [[unlikely]] {
                auto lock = std::unique_lock { mutex };
                std::println(getSTDErr(),
                             "{} failed in \n"
                             "    > file:     {}\n"
                             "      line:     {}\n"
                             "      function: {}\n"
                             "      reason:  {}",
                             ConsoleStyle { .fg = ConsoleColor::Bright_Red,
                                            .modifiers
                                            = StyleModifier::Bold | StyleModifier::Inverse }
                                 | "["s + casts::as<std::string>(type) + "]",
                             ConsoleStyle { .fg = ConsoleColor::Yellow } | location.file_name(),
                             ConsoleStyle { .fg = ConsoleColor::Blue } | location.line(),
                             ConsoleStyle { .fg = ConsoleColor::Green } | location.function_name(),
                             ConsoleStyle { .fg        = ConsoleColor::Red,
                                            .modifiers = StyleModifier::Bold }
                                 | message);

                std::terminate();
            }
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE consteval auto
        compileTimeAssertBase(bool cond, AssertType type, std::string_view message) noexcept
        -> void {
        if (not cond) [[unlikely]] { constevalFailure(generateConstevalMessage(type, message)); }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr auto
        assert(bool                                         cond,
               std::string_view                             message,
               [[maybe_unused]] const std::source_location& location) noexcept -> void {
#ifdef STORMKIT_COMPILER_MSVC
        if constexpr (std::is_constant_evaluated()) {
#else
        if consteval {
#endif
            compileTimeAssertBase(cond, AssertType::Assertion, message);
        } else {
            assertBase(cond, AssertType::Assertion, message, location);
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr auto assert(bool                        cond,
                                                const std::source_location& location) noexcept
        -> void {
        assert(cond, "Condition check failed", location);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr auto
        expects(bool cond, std::string_view message, const std::source_location& location) noexcept
        -> void {
#ifdef STORMKIT_COMPILER_MSVC
        if constexpr (std::is_constant_evaluated()) {
#else
        if consteval {
#endif
            compileTimeAssertBase(cond, AssertType::PreCondition, message);
        } else {
            assertBase(cond, AssertType::PreCondition, message, location);
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr auto expects(bool                        cond,
                                                 const std::source_location& location) noexcept
        -> void {
        expects(cond, "Pre Condition check failed", location);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr auto
        ensures(bool cond, std::string_view message, const std::source_location& location) noexcept
        -> void {
#ifdef STORMKIT_COMPILER_MSVC
        if constexpr (std::is_constant_evaluated()) {
#else
        if consteval {
#endif
            compileTimeAssertBase(cond, AssertType::PostCondition, message);
        } else {
            assertBase(cond, AssertType::PostCondition, message, location);
        }
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE constexpr auto ensures(bool                        cond,
                                                 const std::source_location& location) noexcept
        -> void {
        ensures(cond, "Post Condition check failed", location);
    }
} // namespace stormkit::core
