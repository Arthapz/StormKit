// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/PlatformMacro.hpp>

export module stormkit.Engine:Renderer;

import std;

import stormkit.Core;
import stormkit.Wsi;
import stormkit.Gpu;

export import :Renderer.FrameGraph;

export {
    namespace stormkit::engine {
        class STORMKIT_API RenderSurface {
            struct Tag {};

          public:
            struct Frame {
                core::UInt32 current_frame;
                core::UInt32 image_index;

                core::NakedRef<const gpu::Semaphore> image_available;
                core::NakedRef<const gpu::Semaphore> render_finished;
                core::NakedRef<gpu::Fence>           in_flight;
            };

            RenderSurface(const gpu::Instance& instance,
                          const gpu::Device&   device,
                          const gpu::Queue&    raster_queue,
                          const wsi::Window&   window,
                          Tag);
            ~RenderSurface();

            RenderSurface(const RenderSurface&)                    = delete;
            auto operator=(const RenderSurface&) -> RenderSurface& = delete;

            RenderSurface(RenderSurface&&) noexcept;
            auto operator=(RenderSurface&&) noexcept -> RenderSurface&;

            static auto createFromWindow(const gpu::Instance& instance,
                                         const gpu::Device&   device,
                                         const gpu::Queue&    raster_queue,
                                         const wsi::Window&   window) noexcept
                -> gpu::Expected<RenderSurface>;
            static auto allocateFromWindow(const gpu::Instance& instance,
                                           const gpu::Device&   device,
                                           const gpu::Queue&    raster_queue,
                                           const wsi::Window&   window) noexcept
                -> gpu::Expected<std::unique_ptr<RenderSurface>>;

            [[nodiscard]] auto beginFrame(const gpu::Device& device) -> gpu::Expected<Frame>;
            [[nodiscard]] auto presentFrame(const gpu::Queue& queue,
                                            const Frame&      frame) -> gpu::Expected<void>;

            [[nodiscard]] auto bufferingCount() const noexcept -> core::UInt32;

          private:
            core::DeferInit<gpu::Surface>   m_surface;
            core::DeferInit<gpu::Swapchain> m_swapchain;
            std::optional<gpu::Swapchain>   m_old_swapchain;

            core::RangeExtent           m_current_frame = 0;
            std::vector<gpu::Semaphore> m_image_availables;
            std::vector<gpu::Semaphore> m_render_finisheds;
            std::vector<gpu::Fence>     m_in_flight_fences;

            bool m_need_recreate;
        };

        class STORMKIT_API Renderer final {
            struct Tag {};

          public:
            Renderer(std::string_view                                 application_name,
                     std::optional<core::NakedRef<const wsi::Window>> window,
                     Tag);
            ~Renderer();

            Renderer(const Renderer&)                    = delete;
            auto operator=(const Renderer&) -> Renderer& = delete;

            Renderer(Renderer&&) noexcept;
            auto operator=(Renderer&&) noexcept -> Renderer&;

            static auto create(std::string_view                                 application_name,
                               std::optional<core::NakedRef<const wsi::Window>> window) noexcept
                -> gpu::Expected<Renderer>;
            static auto allocate(std::string_view                                 application_name,
                                 std::optional<core::NakedRef<const wsi::Window>> window) noexcept
                -> gpu::Expected<std::unique_ptr<Renderer>>;

            auto startRendering() noexcept -> void;

          private:
            auto doInit(std::string_view, std::optional<core::NakedRef<const wsi::Window>>) noexcept
                -> gpu::Expected<void>;
            auto doInitInstance(std::string_view) noexcept -> gpu::Expected<void>;
            auto doInitDevice() noexcept -> gpu::Expected<void>;
            auto doInitRenderSurface(std::optional<core::NakedRef<const wsi::Window>>) noexcept
                -> gpu::Expected<void>;

            auto threadLoop(std::stop_token) noexcept -> void;
            auto doRender(RenderSurface::Frame&&) noexcept -> gpu::Expected<RenderSurface::Frame>;

            bool                              m_validation_layers_enabled = false;
            core::DeferInit<gpu::Instance>    m_instance;
            core::DeferInit<gpu::Device>      m_device;
            core::DeferInit<RenderSurface>    m_surface;
            core::DeferInit<gpu::Queue>       m_raster_queue;
            core::DeferInit<gpu::CommandPool> m_main_command_pool;

            std::vector<gpu::CommandBuffer> m_command_buffers;
            std::vector<gpu::Fence>         m_fences;

            std::jthread m_render_thread;
        };

    } // namespace stormkit::engine
}

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::engine {
    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    auto RenderSurface::bufferingCount() const noexcept -> core::UInt32 {
        return core::narrow<core::UInt32>(std::size(m_swapchain->images()));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    Renderer::Renderer(std::string_view                                 application_name,
                       std::optional<core::NakedRef<const wsi::Window>> window,
                       Tag) {
        doInit(application_name, std::move(window)).transform_error(core::throwError());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE Renderer::~Renderer() = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE Renderer::Renderer(Renderer&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Renderer::operator=(Renderer&&) noexcept -> Renderer& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        Renderer::create(std::string_view                                 application_name,
                         std::optional<core::NakedRef<const wsi::Window>> window) noexcept
        -> gpu::Expected<Renderer> try {
        return Renderer { application_name, std::move(window), Tag {} };
    } catch (const gpu::Result& err) { return std::unexpected { err }; }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        Renderer::allocate(std::string_view                                 application_name,
                           std::optional<core::NakedRef<const wsi::Window>> window) noexcept
        -> gpu::Expected<std::unique_ptr<Renderer>> try {
        return std::make_unique<Renderer>(application_name, std::move(window), Tag {});
    } catch (const gpu::Result& err) { return std::unexpected { err }; }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto Renderer::startRendering() noexcept -> void {
        m_render_thread = std::jthread { core::curry(&Renderer::threadLoop, this) };
        core::setThreadName(m_render_thread, "StormKit:RenderThread");
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE RenderSurface::~RenderSurface() = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE RenderSurface::RenderSurface(RenderSurface&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        RenderSurface::operator=(RenderSurface&&) noexcept -> RenderSurface& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto RenderSurface::createFromWindow(const gpu::Instance& instance,
                                                               const gpu::Device&   device,
                                                               const gpu::Queue&    raster_queue,
                                                               const wsi::Window&   window) noexcept
        -> gpu::Expected<RenderSurface> try {
        return RenderSurface { instance, device, raster_queue, window, Tag {} };
    } catch (const gpu::Result& err) { return std::unexpected { err }; }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto RenderSurface::allocateFromWindow(const gpu::Instance& instance,
                                                                 const gpu::Device&   device,
                                                                 const gpu::Queue&    raster_queue,
                                                                 const wsi::Window& window) noexcept
        -> gpu::Expected<std::unique_ptr<RenderSurface>> try {
        return std::make_unique<RenderSurface>(instance, device, raster_queue, window, Tag {});
    } catch (const gpu::Result& err) { return std::unexpected { err }; }
} // namespace stormkit::engine
