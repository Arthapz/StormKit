// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;



#include <stormkit/Core/PlatformMacro.hpp>

export module stormkit.Engine:Vulkan.CommandBuffer;

import std;

import stormkit.Core;


import vulkan_hpp;

export namespace stormkit::engine {
    auto createCommandBuffer(const vk::raii::Device     & device,
                             const vk::raii::CommandPool& pool,
                             vk::CommandBufferLevel       level = vk::CommandBufferLevel::ePrimary)
        -> decltype(auto);

    auto createCommandBuffers(const vk::raii::Device     & device,
                              const vk::raii::CommandPool& pool,
                              core::RangeExtent            count,
                              vk::CommandBufferLevel       level = vk::CommandBufferLevel::ePrimary)
        -> decltype(auto);

    auto transitionImageLayout(vk::raii::CommandBuffer        & cmb,
                               const vk::raii::Image          & image,
                               vk::ImageLayout                  source_layout,
                               vk::ImageLayout                  destination_layout,
                               const vk::ImageSubresourceRange& subresource_range =
                                   vk::ImageSubresourceRange {}
                                       .setAspectMask(vk::ImageAspectFlagBits::eColor)
                                       .setBaseMipLevel(0)
                                       .setLevelCount(1)
                                       .setBaseArrayLayer(0)
                                       .setLayerCount(1)) noexcept -> void;

    auto transitionImageLayout(vk::raii::CommandBuffer        & cmb,
                               const vk::Image                & image,
                               vk::ImageLayout                  source_layout,
                               vk::ImageLayout                  destination_layout,
                               const vk::ImageSubresourceRange& subresource_range =
                                   vk::ImageSubresourceRange {}
                                       .setAspectMask(vk::ImageAspectFlagBits::eColor)
                                       .setBaseMipLevel(0)
                                       .setLevelCount(1)
                                       .setBaseArrayLayer(0)
                                       .setLayerCount(1)) noexcept -> void;

    auto submit(const vk::raii::Queue        & queue,
                const vk::raii::CommandBuffer& cmb,
                std::span<const vk::Semaphore> wait_semaphores,
                std::span<const vk::Semaphore> signal_semaphores,
                vk::Fence                      fence = {}) noexcept -> void;

    auto submit(const vk::raii::Queue                  & queue,
                std::span<const vk::raii::CommandBuffer> cmbs,
                std::span<const vk::Semaphore>           wait_semaphores,
                std::span<const vk::Semaphore>           signal_semaphores,
                vk::Fence                                fence = {}) -> void;

    auto submit(const vk::raii::Queue            & queue,
                std::span<const vk::CommandBuffer> cmbs,
                std::span<const vk::Semaphore>     wait_semaphores,
                std::span<const vk::Semaphore>     signal_semaphores,
                vk::Fence                          fence = {}) -> void;
} // namespace stormkit::engine

namespace stormkit::engine {
    namespace {
        constexpr auto old_layout_access_map =
            core::makeFrozenMap<vk::ImageLayout,
                                std::pair<vk::AccessFlags, vk::PipelineStageFlags>>(
                { { vk::ImageLayout::eUndefined,
                    { vk::AccessFlagBits {}, vk::PipelineStageFlagBits::eTopOfPipe } },
                  { vk::ImageLayout::ePreinitialized,
                    { vk::AccessFlagBits {}, vk::PipelineStageFlagBits::eTopOfPipe } },
                  { vk::ImageLayout::eGeneral,
                    { vk::AccessFlagBits::eColorAttachmentWrite |
                          vk::AccessFlagBits::eColorAttachmentRead,
                      vk::PipelineStageFlagBits::eColorAttachmentOutput } },
                  { vk::ImageLayout::eColorAttachmentOptimal,
                    { vk::AccessFlagBits::eColorAttachmentWrite |
                          vk::AccessFlagBits::eColorAttachmentRead,
                      vk::PipelineStageFlagBits::eColorAttachmentOutput } },
                  { vk::ImageLayout::eDepthStencilAttachmentOptimal,
                    { vk::AccessFlagBits::eDepthStencilAttachmentRead |
                          vk::AccessFlagBits::eDepthStencilAttachmentWrite,
                      vk::PipelineStageFlagBits::eLateFragmentTests } },
                  { vk::ImageLayout::eDepthStencilReadOnlyOptimal,
                    { vk::AccessFlagBits::eDepthStencilAttachmentRead,
                      vk::PipelineStageFlagBits::eLateFragmentTests } },
                  { vk::ImageLayout::eShaderReadOnlyOptimal,
                    { vk::AccessFlagBits::eInputAttachmentRead,
                      vk::PipelineStageFlagBits::eFragmentShader } },
                  { vk::ImageLayout::eTransferSrcOptimal,
                    { vk::AccessFlagBits::eTransferRead, vk::PipelineStageFlagBits::eTransfer } },
                  { vk::ImageLayout::eTransferDstOptimal,
                    { vk::AccessFlagBits::eTransferWrite, vk::PipelineStageFlagBits::eTransfer } },
                  { vk::ImageLayout::ePresentSrcKHR,
                    { vk::AccessFlagBits::eMemoryRead, vk::PipelineStageFlagBits::eTransfer } } });

        constexpr auto new_layout_access_map =
            core::makeFrozenMap<vk::ImageLayout,
                                std::pair<vk::AccessFlags, vk::PipelineStageFlags>>(
                { { vk::ImageLayout::eUndefined, { vk::AccessFlagBits {}, {} } },
                  { vk::ImageLayout::ePreinitialized, { vk::AccessFlagBits {}, {} } },
                  { vk::ImageLayout::eGeneral,
                    { vk::AccessFlagBits::eShaderWrite | vk::AccessFlagBits::eShaderRead,
                      vk::PipelineStageFlagBits::eVertexShader } },
                  { vk::ImageLayout::eColorAttachmentOptimal,
                    { vk::AccessFlagBits::eColorAttachmentWrite |
                          vk::AccessFlagBits::eColorAttachmentRead,
                      vk::PipelineStageFlagBits::eColorAttachmentOutput } },
                  { vk::ImageLayout::eDepthStencilAttachmentOptimal,
                    { vk::AccessFlagBits::eDepthStencilAttachmentWrite |
                          vk::AccessFlagBits::eDepthStencilAttachmentRead,
                      vk::PipelineStageFlagBits::eEarlyFragmentTests } },
                  { vk::ImageLayout::eDepthStencilReadOnlyOptimal,
                    { vk::AccessFlagBits::eShaderRead, vk::PipelineStageFlagBits::eVertexInput } },
                  { vk::ImageLayout::eShaderReadOnlyOptimal,
                    { vk::AccessFlagBits::eShaderRead,
                      vk::PipelineStageFlagBits::eFragmentShader } },
                  { vk::ImageLayout::eTransferSrcOptimal,
                    { vk::AccessFlagBits::eTransferRead, vk::PipelineStageFlagBits::eTransfer } },
                  { vk::ImageLayout::eTransferDstOptimal,
                    { vk::AccessFlagBits::eTransferWrite, vk::PipelineStageFlagBits::eTransfer } },
                  { vk::ImageLayout::ePresentSrcKHR,
                    { vk::AccessFlagBits::eMemoryRead, vk::PipelineStageFlagBits::eTransfer } } });
    } // namespace

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto createCommandBuffers(const vk::raii::Device     & device,
                                                    const vk::raii::CommandPool& pool,
                                                    core::RangeExtent            count,
                                                    vk::CommandBufferLevel       level)
        -> decltype(auto) {
        const auto allocate_info = vk::CommandBufferAllocateInfo {}
                                       .setCommandPool(*pool)
                                       .setLevel(vk::CommandBufferLevel::ePrimary)
                                       .setCommandBufferCount(count);

        return vk::raii::CommandBuffers { device, allocate_info };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto createCommandBuffer(const vk::raii::Device     & device,
                                                   const vk::raii::CommandPool& pool,
                                                   vk::CommandBufferLevel level) -> decltype(auto) {
        return std::move(createCommandBuffers(device, pool, 1, level).front());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        transitionImageLayout(vk::raii::CommandBuffer        & cmb,
                              const vk::raii::Image          & image,
                              vk::ImageLayout                  source_layout,
                              vk::ImageLayout                  destination_layout,
                              const vk::ImageSubresourceRange& subresource_range) noexcept -> void {
        transitionImageLayout(cmb, *image, source_layout, destination_layout, subresource_range);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        transitionImageLayout(vk::raii::CommandBuffer        & cmb,
                              const vk::Image                & image,
                              vk::ImageLayout                  source_layout,
                              vk::ImageLayout                  destination_layout,
                              const vk::ImageSubresourceRange& subresource_range) noexcept -> void {
        const auto& [source_access_mask, source_stage] =
            old_layout_access_map.find(source_layout)->second;
        const auto& [destination_access_mask, destination_stage] =
            old_layout_access_map.find(destination_layout)->second;

        const auto barriers = std::array { vk::ImageMemoryBarrier {}
                                               .setSrcAccessMask(source_access_mask)
                                               .setDstAccessMask(destination_access_mask)
                                               .setOldLayout(source_layout)
                                               .setNewLayout(destination_layout)
                                               .setSrcQueueFamilyIndex(vk::QueueFamilyIgnored)
                                               .setDstQueueFamilyIndex(vk::QueueFamilyIgnored)
                                               .setImage(image)
                                               .setSubresourceRange(subresource_range) };

        cmb.pipelineBarrier(source_stage, destination_stage, {}, {}, {}, barriers);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto submit(const vk::raii::Queue        & queue,
                                      const vk::raii::CommandBuffer& cmb,
                                      std::span<const vk::Semaphore> wait_semaphores,
                                      std::span<const vk::Semaphore> signal_semaphores,
                                      vk::Fence                      fence) noexcept -> void {
        submit(queue, std::array { *cmb }, wait_semaphores, signal_semaphores, std::move(fence));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto submit(const vk::raii::Queue                  & queue,
                                      std::span<const vk::raii::CommandBuffer> cmbs,
                                      std::span<const vk::Semaphore>           wait_semaphores,
                                      std::span<const vk::Semaphore>           signal_semaphores,
                                      vk::Fence                                fence) -> void {
        const auto _cmbs = cmbs | std::views::transform([](auto&& cmb) { return *cmb; }) |
                           std::ranges::to<std::vector>();
        submit(queue, _cmbs, wait_semaphores, signal_semaphores, fence);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto submit(const vk::raii::Queue            & queue,
                                      std::span<const vk::CommandBuffer> cmbs,
                                      std::span<const vk::Semaphore>     wait_semaphores,
                                      std::span<const vk::Semaphore>     signal_semaphores,
                                      vk::Fence                          fence) -> void {
        const auto wait_stages = std::vector<vk::PipelineStageFlags> {
            std::size(wait_semaphores),
            vk::PipelineStageFlagBits::eColorAttachmentOutput
        };

        const auto submit_info = vk::SubmitInfo {}
                                     .setWaitSemaphores(wait_semaphores)
                                     .setSignalSemaphores(signal_semaphores)
                                     .setCommandBuffers(cmbs);

        queue.submit(submit_info, fence);
    }
} // namespace stormkit::engine
