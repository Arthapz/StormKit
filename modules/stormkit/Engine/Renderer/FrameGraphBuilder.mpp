// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/PlatformMacro.hpp>

export module stormkit.Engine:Renderer.FrameGraphBuilder;

import std;

import stormkit.Core;
import stormkit.Gpu;

import :Renderer.BakedFrameGraph;
import :Renderer.GraphID;
import :Renderer.GraphTask;
import :Renderer.GraphResource;

export namespace stormkit::engine {
    class STORMKIT_API FrameGraphBuilder {
      public:
        template<typename T>
        using SetupCallback = std::function<void(T&, GraphTaskBuilder&)>;
        template<typename T>
        using ExecuteCallback = std::function<void(const T&,
                                                   std::optional<core::NakedRef<gpu::RenderPass>>&,
                                                   gpu::CommandBuffer& cmb)>;

        FrameGraphBuilder() noexcept;
        ~FrameGraphBuilder();

        FrameGraphBuilder(const FrameGraphBuilder&)                    = delete;
        auto operator=(const FrameGraphBuilder&) -> FrameGraphBuilder& = delete;

        FrameGraphBuilder(FrameGraphBuilder&&) noexcept;
        auto operator=(FrameGraphBuilder&&) noexcept -> FrameGraphBuilder&;

        template<class TaskData>
        auto addTask(std::string               name,
                     SetupCallback<TaskData>   setup,
                     ExecuteCallback<TaskData> execute,
                     GraphTask::Type           type       = GraphTask::Type::Graphics,
                     bool                      cull_imune = false) noexcept -> GraphTask&;

        template<ResourceDescriptionType Description, typename Resource>
        auto setRetainedResource(std::string     name,
                                 Description&&   description,
                                 const Resource& image) -> GraphResource<Description>&;

        auto setFinalResource(GraphID final) noexcept -> void;

        auto reset() noexcept -> void;
        auto bake() -> void;
        auto createFrameGraph(const gpu::Device& device,
                              BakedFrameGraph   *old = nullptr) -> BakedFrameGraph;
        auto allocateFrameGraph(const gpu::Device& device,
                                BakedFrameGraph *old = nullptr) -> std::unique_ptr<BakedFrameGraph>;

        auto hasTask(GraphID id) const noexcept -> bool;
        auto hasTask(std::string_view name) const noexcept -> bool;

        template<class TaskData>
        auto getTask(this auto& self, std::string_view name) noexcept -> decltype(auto);

        template<class TaskData>
        auto getTask(this auto& self, GraphID id) noexcept -> decltype(auto);

        auto getTask(this auto& self, std::string_view name) noexcept -> decltype(auto);
        auto getTask(this auto& self, GraphID id) noexcept -> decltype(auto);

        auto hasResource(GraphID id) const noexcept -> bool;
        auto hasResource(std::string_view name) const noexcept -> bool;

        template<class Description>
        auto getResource(this auto& self, std::string_view name) noexcept -> decltype(auto);

        template<class Description>
        auto getResource(this auto& self, GraphID id) noexcept -> decltype(auto);

        auto getResource(this auto& self, std::string_view name) noexcept -> decltype(auto);
        auto getResource(this auto& self, GraphID id) noexcept -> decltype(auto);

      private:
        struct BufferInfo {
            GraphID                 id;
            gpu::Buffer::CreateInfo create_info;
            std::string_view        name;
        };

        struct ImageInfo {
            GraphID                id;
            gpu::Image::CreateInfo create_info;
            gpu::ClearValue        clear_value;
            std::string_view       name;
        };

        struct RenderPassData {
            gpu::RenderPassDescription                  description;
            std::vector<std::vector<gpu::Subpass::Ref>> color_attachment_refs;
            std::vector<std::vector<gpu::Subpass::Ref>> depth_attachment_refs;
            std::vector<std::vector<gpu::Subpass::Ref>> resolve_attachment_refs;
        };

        struct Pass {
            GraphID id = INVALID_ID;

            RenderPassData   renderpass;
            std::string_view name;

            std::vector<BufferInfo> buffers;
            std::vector<ImageInfo>  images;
        };

        using GraphResourceVariant = std::variant<GraphBuffer, GraphImage>;
        using ResourceVariant =
            std::variant<core::NakedRef<const gpu::Image>, core::NakedRef<const gpu::Buffer>>;

        auto prepareTask(GraphTask& task) noexcept -> void;

        auto cullUnreferencedResources() noexcept -> void;
        auto buildPhysicalDescriptions() noexcept -> void;
        auto buildImagePhysicalDescriptions(const GraphTask& task) noexcept
            -> std::vector<ImageInfo>;
        auto buildBufferPhysicalDescriptions(const GraphTask& task) noexcept
            -> std::vector<BufferInfo>;
        auto buildRenderPassPhysicalDescription(
            const GraphTask&                          task,
            core::HashMap<GraphID, gpu::ImageLayout>& layouts) noexcept -> RenderPassData;
        auto allocatePhysicalResources(const gpu::Device& device) -> BakedFrameGraph::Data;

        std::future<void>               m_bake_future;
        std::list<GraphTask>            m_tasks;
        std::list<GraphResourceVariant> m_resources;
        GraphID                         m_final_resource = INVALID_ID;

        std::vector<std::vector<std::byte>> m_datas;

        core::HashMap<GraphID, ResourceVariant> m_retained_resources;

        std::vector<Pass> m_preprocessed_framegraph;

        core::ThreadPool m_thread_pool;

        friend class GraphTaskBuilder;
    };
} // namespace stormkit::engine

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::engine {
    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE FrameGraphBuilder::FrameGraphBuilder() noexcept {
        m_thread_pool.setName("StormKit:FrameGraph:Worker");
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE FrameGraphBuilder::~FrameGraphBuilder() = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    FrameGraphBuilder::FrameGraphBuilder(FrameGraphBuilder&& other) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto FrameGraphBuilder::operator=(FrameGraphBuilder&& other) noexcept
        -> FrameGraphBuilder& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto FrameGraphBuilder::reset() noexcept -> void {
        m_resources.clear();
        m_tasks.clear();
        m_datas.clear();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData>
    inline auto FrameGraphBuilder::addTask(std::string               name,
                                           SetupCallback<TaskData>   setup,
                                           ExecuteCallback<TaskData> execute,
                                           GraphTask::Type           type,
                                           bool cull_imune) noexcept -> GraphTask& {
        core::expects(!hasTask(name), std::format("Task {} already registered !", name));

        auto  id   = std::size(m_datas);
        auto& task = m_tasks.emplace_back(id, std::move(name), type, cull_imune);
        m_datas.emplace_back(std::vector<std::byte> { sizeof(TaskData) });

        task.onSetup = [setup = std::move(setup)](core::Byte&       data,
                                                  GraphTaskBuilder& builder) noexcept {
            setup(core::as<TaskData>(data), builder);
        };
        task.onExecute = [execute = std::move(
                              execute)](const core::Byte&                              data,
                                        std::optional<core::NakedRef<gpu::RenderPass>> renderpass,
                                        gpu::CommandBuffer& cmb) noexcept {
            execute(core::as<TaskData>(data), std::move(renderpass), cmb);
        };

        prepareTask(task);

        return task;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType Description, typename Resource>
    inline auto FrameGraphBuilder::setRetainedResource(std::string     name,
                                                       Description&&   description,
                                                       const Resource& image)
        -> GraphResource<Description>& {
        auto& graph_resource = m_resources.emplace_back(std::move(name),
                                                        INVALID_ID,
                                                        std::forward<Description>(description));

        m_retained_resources.emplace(graph_resource->id(), ResourceVariant { &image });

        return core::as<GraphResource<Description>>(*graph_resource);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto FrameGraphBuilder::setFinalResource(GraphID id) noexcept -> void {
        m_final_resource = id;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto FrameGraphBuilder::hasTask(GraphID id) const noexcept -> bool {
        return std::ranges::any_of(m_tasks, [&](const auto& t) noexcept { return t.id() == id; });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        FrameGraphBuilder::hasTask(std::string_view name) const noexcept -> bool {
        return std::ranges::any_of(m_tasks,
                                   [&](const auto& t) noexcept { return t.name() == name; });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData>
    STORMKIT_FORCE_INLINE auto
        FrameGraphBuilder::getTask(this auto&       self,
                                   std::string_view name) noexcept -> decltype(auto) {
        return core::as<core::LikeCV<decltype(self), GraphTask>>(self.getTask(name));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData>
    STORMKIT_FORCE_INLINE auto FrameGraphBuilder::getTask(this auto& self,
                                                          GraphID id) noexcept -> decltype(auto) {
        return core::as<core::LikeCV<decltype(self), GraphTask>>(self.getTask(id));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        FrameGraphBuilder::getTask(this auto&       self,
                                   std::string_view name) noexcept -> decltype(auto) {
        const auto it = std::ranges::find_if(self.m_tasks, [&](const auto& t) noexcept {
            return t.name() == name;
        });

        core::ensures(it != std::ranges::cend(self.m_tasks),
                      std::format("task with name {} not found", name));

        return *it;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto FrameGraphBuilder::getTask(this auto& self,
                                                          GraphID id) noexcept -> decltype(auto) {
        auto it = std::ranges::find_if(self.m_tasks,
                                       [&](const auto& t) noexcept { return t.id() == id; });

        core::ensures(it != std::ranges::end(self.m_tasks),
                      std::format("task with id {} not found", id));

        return *it;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto FrameGraphBuilder::hasResource(GraphID id) const noexcept -> bool {
        return std::ranges::any_of(m_resources, [&](const auto& t) noexcept {
            return std::visit([&](auto&& t) { return t.id() == id; }, t);
        });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        FrameGraphBuilder::hasResource(std::string_view name) const noexcept -> bool {
        return std::ranges::any_of(m_resources, [&](const auto& t) noexcept {
            return std::visit([&](auto&& t) { return t.name() == name; }, t);
        });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class ResourceData>
    STORMKIT_FORCE_INLINE auto
        FrameGraphBuilder::getResource(this auto&       self,
                                       std::string_view name) noexcept -> decltype(auto) {
        return core::as<GraphResource<ResourceData>>(self.getResource(name));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class ResourceData>
    STORMKIT_FORCE_INLINE auto
        FrameGraphBuilder::getResource(this auto& self, GraphID id) noexcept -> decltype(auto) {
        return core::as<GraphResource<ResourceData>>(self.getResource(id));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        FrameGraphBuilder::getResource(this auto&       self,
                                       std::string_view name) noexcept -> decltype(auto) {
        const auto visitor = [name](auto&& value) noexcept { return value.name() == name; };

        auto it = std::ranges::find_if(self.m_resources, [&](auto&& value) noexcept {
            return std::visit(visitor, value);
        });

        core::ensures(it != std::ranges::end(self.m_resources),
                      std::format("resource with name {} not found", name));

        return *it;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE auto
        FrameGraphBuilder::getResource(this auto& self, GraphID id) noexcept -> decltype(auto) {
        const auto visitor = [id](auto&& value) noexcept { return value.id() == id; };

        auto it = std::ranges::find_if(self.m_resources, [&](auto&& value) noexcept {
            return std::visit(visitor, value);
        });

        core::ensures(it != std::ranges::end(self.m_resources),
                      std::format("resource with id {} not found", id));

        return *it;
    }
} // namespace stormkit::engine
