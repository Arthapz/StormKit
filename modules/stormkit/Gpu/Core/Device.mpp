// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

export module stormkit.Gpu:Core.Device;

import std;

import stormkit.Core;

import <stormkit/Core/PlatformMacro.hpp>;

import :Core.Types;
import :Core.Vulkan.Utils;

import vulkan;
import vma;

export namespace stormkit::gpu {
    class PhysicalDevice;
    class Instance;
    class Fence;
    class Semaphore;
    class STORMKIT_API Device: public InstanceObject {
      public:
        static constexpr auto DEBUG_TYPE = DebugObjectType::Device;

        struct QueueEntry {
            core::UInt32 id;
            core::UInt32 count;
            QueueFlag flags = QueueFlag {};
        };

        struct Info {
            bool enable_swapchain;
            bool enable_raytracing;
        };

        Device(const PhysicalDevice& physical_device,
               const Instance& instance,
               Info info = { true, false });
        ~Device();

        Device(const Device&)                    = delete;
        auto operator=(const Device&) -> Device& = delete;

        Device(Device&&) noexcept;
        auto operator=(Device&&) noexcept -> Device&;

        auto waitIdle() const noexcept -> void;

        auto waitForFences(std::span<const core::NakedRef<const Fence>> fences,
                           bool wait_all = true,
                           const std::chrono::milliseconds& timeout =
                               std::chrono::milliseconds::max()) const noexcept -> Result;
        auto waitForFence(const Fence& fence,
                          const std::chrono::milliseconds& timeout =
                              std::chrono::milliseconds::max()) const noexcept -> Result;

        auto resetFences(std::span<const core::NakedRef<const Fence>> fences) const noexcept
            -> Result;
        auto resetFence(const Fence& fence) const noexcept -> Result;

        [[nodiscard]] auto rasterQueueEntry() const noexcept -> const QueueEntry&;
        [[nodiscard]] auto asyncTransfertQueueEntry() const noexcept -> const QueueEntry&;
        [[nodiscard]] auto asyncComputeQueueEntry() const noexcept -> const QueueEntry&;

        [[nodiscard]] auto hasAsyncTransfertQueue() const noexcept -> bool;
        [[nodiscard]] auto hasAsyncComputeQueue() const noexcept -> bool;

        [[nodiscard]] auto physicalDevice() const noexcept -> const PhysicalDevice&;

        [[nodiscard]] auto vkHandle() const noexcept -> const vk::raii::Device&;

        [[nodiscard]] auto vmaAllocator() const noexcept -> const vma::Allocator&;
        [[nodiscard]] auto vmaFunctionTable() const noexcept -> const vma::VulkanFunctions&;

        template<class T>
        auto setObjectName(const T& object, std::string_view name) const -> void;

        auto setObjectName(core::UInt64 object, DebugObjectType type, std::string_view name) const
            -> void;

      private:
        const PhysicalDevice *m_physical_device = nullptr;

        std::unique_ptr<vk::raii::Device> m_vk_device;

        QueueEntry m_raster_queue;
        std::optional<QueueEntry> m_async_transfert_queue;
        std::optional<QueueEntry> m_async_compute_queue;

        vma::raii::Allocator m_vma_allocator;
        vma::VulkanFunctions m_vma_function_table;
    };
} // namespace stormkit::gpu

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::gpu {
    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::waitForFence(const Fence& fence,
                                     const std::chrono::milliseconds& timeout) const noexcept
        -> Result {
        return waitForFences(core::makeNakedRefArray(fence), true, timeout);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::resetFence(const Fence& fence) const noexcept -> Result {
        return resetFences(core::makeNakedRefArray(fence));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::rasterQueueEntry() const noexcept -> const QueueEntry& {
        return m_raster_queue;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::asyncTransfertQueueEntry() const noexcept -> const QueueEntry& {
        core::expects(m_async_transfert_queue != std::nullopt);

        return *m_async_transfert_queue;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::asyncComputeQueueEntry() const noexcept -> const QueueEntry& {
        core::expects(m_async_compute_queue != std::nullopt);

        return *m_async_compute_queue;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::hasAsyncTransfertQueue() const noexcept -> bool {
        return m_async_transfert_queue != std::nullopt;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::hasAsyncComputeQueue() const noexcept -> bool {
        return m_async_compute_queue != std::nullopt;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::physicalDevice() const noexcept -> const PhysicalDevice& {
        return *m_physical_device;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::vkHandle() const noexcept -> const vk::raii::Device& {
        core::expects(m_vk_device != nullptr);

        return *m_vk_device;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::vmaAllocator() const noexcept -> const vma::Allocator& {
        core::expects(m_vma_allocator.operator bool());

        return *m_vma_allocator;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::vmaFunctionTable() const noexcept -> const vma::VulkanFunctions& {
        return m_vma_function_table;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class T>
    auto Device::setObjectName(const T& object, std::string_view name) const -> void {
        setObjectName(std::bit_cast<core::UInt64>(*(object.vkHandle())), T::DEBUG_TYPE, name);
    }
} // namespace stormkit::gpu
