// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/core/platform_macro.hpp>

export module stormkit.core:containers.utils;

import std;

import :meta;
import :typesafe.byte;

namespace stdr = std::ranges;

export namespace stormkit { inline namespace core {
    template<stdr::range T, stdr::range... U>
    constexpr auto merge(T& output, const U&... ranges) noexcept -> void;

    template<stdr::range T, stdr::range... U>
    constexpr auto concat(const T& first, const U&... others) noexcept
      -> std::vector<meta::RangeType<T>>;

    template<stdr::range T, stdr::range... U>
    constexpr auto move_and_merge(T& output, U&&... ranges) noexcept -> void;

    template<stdr::range T, stdr::range... U>
    constexpr auto move_and_concat(T&& first, U&&... others) noexcept
      -> std::vector<meta::RangeType<T>>;

    template<typename... Args>
        requires(sizeof...(Args) > 0)
    constexpr auto to_array(Args&&... args) noexcept
      -> std::array<meta::CanonicalType<Args...[0]>, sizeof...(Args)>;

    template<typename... Args>
        requires(sizeof...(Args) > 0)
    constexpr auto into_array(Args&&... args) noexcept
      -> std::array<meta::CanonicalType<Args...[0]>, sizeof...(Args)>;

    template<stdr::range T>
    constexpr auto to_dyn_array(T&& range) noexcept -> std::vector<stdr::range_value_t<T>>;

    template<typename... Args>
        requires(sizeof...(Args) > 0)
    constexpr auto into_dyn_array(Args&&... args) noexcept
      -> std::vector<meta::CanonicalType<Args...[0]>>;

    template<typename T, typename... Args>
        requires(sizeof...(Args) > 0)
    constexpr auto to_array_of(Args&&... args) noexcept -> std::array<T, sizeof...(Args)>;

    template<typename T, typename... Args>
        requires(sizeof...(Args) > 0)
    constexpr auto into_array_of(Args&&... args) noexcept -> std::array<T, sizeof...(Args)>;

    template<typename T, typename... Args>
        requires(sizeof...(Args) > 0)
    constexpr auto to_dyn_array_of(Args&&... args) noexcept -> std::vector<T>;

    template<typename T, typename... Args>
        requires(sizeof...(Args) > 0)
    constexpr auto into_dyn_array_of(Args&&... args) noexcept -> std::vector<T>;

    template<typename... Args>
        requires(sizeof...(Args) > 0)
    constexpr auto to_dyn_array(Args&&... args) noexcept
      -> std::vector<meta::CanonicalType<Args...[0]>>;

    template<meta::IsStringLike T>
    constexpr auto as_view(T& range) noexcept -> std::string_view;

    template<stdr::contiguous_range T>
    constexpr auto as_view(T& range) noexcept
      -> std::span<meta::ForwardConst<T, stdr::range_value_t<T>>>;

    template<stdr::contiguous_range T>
    constexpr auto as_view(T& range, Force) noexcept
      -> std::span<meta::ForwardConst<T, stdr::range_value_t<T>>>;
}} // namespace stormkit::core

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit { inline namespace core {
    ////////////////////////////////////////
    ////////////////////////////////////////
    template<stdr::range T, stdr::range... U>
    STORMKIT_FORCE_INLINE
    constexpr auto merge(T& output, const U&... ranges) noexcept -> void {
        output.reserve(std::size(output) + (stdr::size(ranges) + ...));
        (stdr::copy(ranges, std::back_inserter(output)), ...);
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<stdr::range T, stdr::range... U>
    STORMKIT_FORCE_INLINE
    STORMKIT_PURE
    constexpr auto concat(const T& first, const U&... others) noexcept
      -> std::vector<meta::RangeType<T>> {
        auto output = std::vector<meta::RangeType<T>> {};
        merge(output, first, others...);

        return output;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<stdr::range T, stdr::range... U>
    STORMKIT_FORCE_INLINE
    constexpr auto move_and_merge(T& output, U&&... ranges) noexcept -> void {
        output.reserve(std::size(output) + (stdr::size(ranges) + ...));
        (stdr::move(std::forward<U>(ranges), std::back_inserter(output)), ...);
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<stdr::range T, stdr::range... U>
    STORMKIT_FORCE_INLINE
    STORMKIT_PURE
    constexpr auto move_and_concat(T&& first, U&&... others) noexcept
      -> std::vector<meta::RangeType<T>> {
        auto output = std::vector<meta::RangeType<T>> {};
        move_and_merge(output, std::forward<T>(first), std::forward<U>(others)...);

        return output;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename... Args>
        requires(sizeof...(Args) > 0)
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto to_array(Args&&... args) noexcept
      -> std::array<meta::CanonicalType<Args...[0]>, sizeof...(Args)> {
        return std::array { std::forward<Args>(args)... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename... Args>
        requires(sizeof...(Args) > 0)
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto into_array(Args&&... args) noexcept
      -> std::array<meta::CanonicalType<Args...[0]>, sizeof...(Args)> {
        static_assert((not meta::IsLValueReference<Args> and ...),
                      "lvalue reference can't be passed to into_ functions as it take "
                      "ownership");
        return std::array { std::move(args)... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename... Args>
    STORMKIT_FORCE_INLINE STORMKIT_PURE
    constexpr auto to_dyn_array(Args&&... args) noexcept
      -> std::vector<meta::CanonicalType<Args...[0]>> {
        return std::vector { std::move(args)... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename... Args>
    STORMKIT_FORCE_INLINE STORMKIT_PURE
    constexpr auto into_dyn_array(Args&&... args) noexcept
      -> std::vector<meta::CanonicalType<Args...[0]>> {
        static_assert((not meta::IsLValueReference<Args> and ...),
                      "lvalue reference can't be passed to into_ functions as it take "
                      "ownership");
        return std::vector { std::move(args)... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<stdr::range T>
    STORMKIT_FORCE_INLINE
    STORMKIT_PURE
    constexpr auto to_dyn_array(T&& range) noexcept -> std::vector<stdr::range_value_t<T>> {
        return std::forward<T>(range) | stdr::to<std::vector>();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T, typename... Args>
        requires(sizeof...(Args) > 0)
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto to_array_of(Args&&... args) noexcept -> std::array<T, sizeof...(Args)> {
        return std::array<T, sizeof...(Args)> { std::forward<Args>(args)... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T, typename... Args>
        requires(sizeof...(Args) > 0)
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto into_array_of(Args&&... args) noexcept -> std::array<T, sizeof...(Args)> {
        static_assert((not meta::IsLValueReference<Args> and ...),
                      "lvalue reference can't be passed to into_ functions as it take "
                      "ownership");
        return std::array<T, sizeof...(Args)> { std::move(args)... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T, typename... Args>
    STORMKIT_FORCE_INLINE STORMKIT_PURE
    constexpr auto to_dyn_array_of(Args&&... args) noexcept -> std::vector<T> {
        return std::vector<T> { std::move(args)... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename T, typename... Args>
    STORMKIT_FORCE_INLINE STORMKIT_PURE
    constexpr auto into_dyn_array_of(Args&&... args) noexcept -> std::vector<T> {
        static_assert((not meta::IsLValueReference<Args> and ...),
                      "lvalue reference can't be passed to into_ functions as it take "
                      "ownership");
        return std::vector<T> { std::move(args)... };
    }

    template<meta::IsStringLike T>
    STORMKIT_FORCE_INLINE
    STORMKIT_CONST
    constexpr auto as_view(T& range) noexcept -> std::string_view {
        return std::string_view { range };
    }

    template<stdr::contiguous_range T>
    STORMKIT_FORCE_INLINE STORMKIT_CONST
    constexpr auto as_view(T& range) noexcept
      -> std::span<meta::ForwardConst<T, stdr::range_value_t<T>>> {
        return { range };
    }

    template<stdr::contiguous_range T>
    STORMKIT_FORCE_INLINE STORMKIT_CONST
    constexpr auto as_view(T& range, Force) noexcept
      -> std::span<meta::ForwardConst<T, stdr::range_value_t<T>>> {
        return { range };
    }
}} // namespace stormkit::core
