// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/PlatformMacro.hpp>

#include <stormkit/Core/Types.hpp>

#include <stormkit/gpu/Fwd.hpp>
#include <stormkit/gpu/resource/Buffer.hpp>

export module stormkit.engine.render.core.ShaderInputBuffer;

import stormkit.Engine;
import stormkit.engine.EngineObject;

import stormkit.engine.render.core.BlockBuffer;

export namespace stormkit::engine {
    template<core::RangeExtent ComponentCount>
    class STORMKIT_API ShaderInputBuffer: public EngineObject {
      public:
        using ComponentHandle = core::Handle64<std::vector<BlockBuffer>>;
        using BufferHandle    = core::Handle64<BlockBuffer>;

        struct Allocation {
            ComponentHandle component;
            BufferHandle buffer;
            BlockBuffer::Block::Handle block;
        };

        template<core::Is<gpu::Buffer::CreateInfo>... CreateInfos>
            requires(sizeof...(CreateInfos) == ComponentCount)
        explicit ShaderInputBuffer(Engine& engine, const CreateInfos&...infos);
        ~ShaderInputBuffer();

        ShaderInputBuffer(const ShaderInputBuffer&)                    = delete;
        auto operator=(const ShaderInputBuffer&) -> ShaderInputBuffer& = delete;

        ShaderInputBuffer(ShaderInputBuffer&&) noexcept;
        auto operator=(ShaderInputBuffer&&) noexcept -> ShaderInputBuffer&;

        [[nodiscard]] auto allocateBlock(core::RangeExtent size,
                                         ComponentHandle component_handle) noexcept -> Allocation;
        [[nodiscard]] auto getBlock(const Allocation& allocation) noexcept
            -> const BlockBuffer::Block&;
        [[nodiscard]] auto getBuffer(const Allocation& allocation) noexcept -> const gpu::Buffer&;
        auto freeBlock(const Allocation& allocation) noexcept -> void;

        auto defragment() noexcept -> void;

      private:
        std::array<gpu::Buffer::CreateInfo, ComponentCount> m_create_infos;
        std::array<std::vector<BlockBuffer>, ComponentCount> m_components;
    };

    /////////////////////////////////////
    /////////////////////////////////////
    template<core::RangeExtent ComponentCount>
    template<core::Is<gpu::Buffer::CreateInfo>... CreateInfos>
        requires(sizeof...(CreateInfos) == ComponentCount)
    ShaderInputBuffer<ComponentCount>::ShaderInputBuffer(Engine& engine, const CreateInfos&...infos)
        : EngineObject { engine }, m_create_infos { infos... } {
        auto i = 0;
        ([&]() { m_components[i++].emplace_back(this->engine(), infos); }(), ...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<core::RangeExtent ComponentCount>
    ShaderInputBuffer<ComponentCount>::~ShaderInputBuffer() = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<core::RangeExtent ComponentCount>
    ShaderInputBuffer<ComponentCount>::ShaderInputBuffer(ShaderInputBuffer&& other) noexcept =
        default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<core::RangeExtent ComponentCount>
    auto ShaderInputBuffer<ComponentCount>::operator=(ShaderInputBuffer&& other) noexcept
        -> ShaderInputBuffer& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<core::RangeExtent ComponentCount>
    auto ShaderInputBuffer<ComponentCount>::allocateBlock(core::RangeExtent size,
                                                          ComponentHandle component_handle) noexcept
        -> Allocation {
        core::expects(component_handle < ComponentCount);

        auto block_handle  = BlockBuffer::Block::Handle::invalidHandle();
        auto buffer_handle = BufferHandle::invalidHandle();

        auto i = 0u;
        for (auto& buffer : m_components[component_handle]) {
            block_handle  = buffer.requestBlock(size);
            buffer_handle = BufferHandle { i++ };

            if (block_handle != BlockBuffer::Block::Handle::invalidHandle()) break;
        }

        if (block_handle == BlockBuffer::Block::Handle::invalidHandle()) {
            auto& buffer =
                m_components[component_handle].emplace_back(engine(),
                                                            m_create_infos[component_handle]);

            block_handle  = buffer.requestBlock(size);
            buffer_handle = BufferHandle { std::size(m_components[component_handle]) - 1 };
        }

        return { component_handle, buffer_handle, block_handle };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<core::RangeExtent ComponentCount>
    auto ShaderInputBuffer<ComponentCount>::getBlock(const Allocation& allocation) noexcept
        -> const BlockBuffer::Block& {
        core::expects(allocation.component < ComponentCount);
        core::expects(allocation.buffer < std::size(m_components[allocation.component]));

        return m_components[allocation.component][allocation.buffer].getBlock(allocation.block);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<core::RangeExtent ComponentCount>
    auto ShaderInputBuffer<ComponentCount>::getBuffer(const Allocation& allocation) noexcept
        -> const gpu::Buffer& {
        core::expects(allocation.component < ComponentCount);
        core::expects(allocation.buffer < std::size(m_components[allocation.component]));

        return m_components[allocation.component][allocation.buffer].gpuBuffer();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<core::RangeExtent ComponentCount>
    auto ShaderInputBuffer<ComponentCount>::freeBlock(const Allocation& allocation) noexcept
        -> void {
        core::expects(allocation.component < ComponentCount);
        core::expects(allocation.buffer < std::size(m_components[allocation.component]));

        m_components[allocation.component][allocation.buffer].freeBlock(allocation.block);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<core::RangeExtent ComponentCount>
    auto ShaderInputBuffer<ComponentCount>::defragment() noexcept -> void {
        for (auto& component : m_components)
            for (auto& buffer : component) buffer.defragment();
    }
} // namespace stormkit::engine
