// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <filesystem>
#include <iterator>
#include <memory>
#include <optional>
#include <ranges>
#include <span>
#include <string_view>
#include <vector>

#include <stormkit/Core/MemoryMacro.hpp>
#include <stormkit/Core/PlatformMacro.hpp>

#include <stormkit/Core/HashMap.hpp>
#include <stormkit/Core/Memory.hpp>
#include <stormkit/Core/Strings.hpp>
#include <stormkit/Core/Types.hpp>

#include <stormkit/gpu/Fwd.hpp>
#include <stormkit/gpu/core/Types.hpp>

#include <stormkit/gpu/resource/Shader.hpp>

export module stormkit.engine.render.core.ShaderCache;

export namespace stormkit::engine {
    class STORMKIT_API ShaderCache {
      public:
        ShaderCache(const gpu::Device& device);
        ~ShaderCache();

        ShaderCache(const ShaderCache&)                    = delete;
        auto operator=(const ShaderCache&) -> ShaderCache& = delete;

        ShaderCache(ShaderCache&&) noexcept;
        auto operator=(ShaderCache&&) noexcept -> ShaderCache&;

        [[nodiscard]] auto has(std::string_view name) const noexcept -> bool;
        [[nodiscard]] auto get(std::string_view name) const noexcept -> const gpu::Shader&;

        auto load(std::string name, std::filesystem::path filepath, gpu::ShaderStageFlag type)
            -> const gpu::Shader&;
        auto load(std::string name, core::ByteConstSpan data, gpu::ShaderStageFlag type)
            -> const gpu::Shader&;
        auto load(std::string name, std::span<const gpu::SpirvID> data, gpu::ShaderStageFlag type)
            -> const gpu::Shader&;

      private:
        auto insert(std::string name, gpu::Shader&& shader) -> const gpu::Shader&;

        const gpu::Device *m_device = nullptr;

        core::StringHashMap<gpu::Shader> m_shaders;
    };

    DECLARE_PTR_AND_REF(ShaderCache);

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto ShaderCache::has(std::string_view name) const noexcept -> bool {
        return std::ranges::any_of(m_shaders,
                                   [name](const auto& pair) { return pair.first == name; });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto ShaderCache::get(std::string_view name) const noexcept -> const gpu::Shader& {
        core::expects(has(name));

        return m_shaders.find(name)->second;
    }
} // namespace stormkit::engine
