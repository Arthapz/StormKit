// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/Core/AssertMacro.hpp>
#include <stormkit/Core/MemoryMacro.hpp>
#include <stormkit/Core/PlatformMacro.hpp>

#include <stormkit/Core/Format.hpp>

#include <future>
#include <iterator>
#include <memory>
#include <optional>
#include <ranges>
#include <vector>

#include <stormkit/Core/Format.hpp>
#include <stormkit/Core/Memory.hpp>
#include <stormkit/Core/Types.hpp>

#include <stormkit/gpu/Fwd.hpp>
#include <stormkit/gpu/pipeline/RenderPassDescription.hpp>
#include <stormkit/gpu/resource/Buffer.hpp>
#include <stormkit/gpu/resource/Image.hpp>

#include <stormkit/gpu/pipeline/RenderPassDescription.hpp>

export module stormkit.engine.render.framegraph.FrameGraphBuilder;

import stormkit.Engine;
import stormkit.engine.EngineObject;

import stormkit.engine.render.framegraph.BakedFrameGraph;
import stormkit.engine.render.framegraph.GraphTask;
import stormkit.engine.render.framegraph.GraphResource;
import stormkit.engine.render.framegraph.GraphID;

namespace stormkit::engine {
    class Engine;
}

export namespace stormkit::engine {
    class STORMKIT_API FrameGraphBuilder: public EngineObject {
      public:
        explicit FrameGraphBuilder(Engine& engine);
        ~FrameGraphBuilder();

        FrameGraphBuilder(const FrameGraphBuilder&)                    = delete;
        auto operator=(const FrameGraphBuilder&) -> FrameGraphBuilder& = delete;

        FrameGraphBuilder(FrameGraphBuilder&&) noexcept;
        auto operator=(FrameGraphBuilder&&) noexcept -> FrameGraphBuilder&;

        template<class TaskData, typename... Args>
        auto addTask(std::string name, Args&&...args) -> GraphTask<TaskData>&;

        template<ResourceDescriptionType Description, gpu::ResourceType Resource>
        auto setRetainedResource(std::string name, Description&& description, const Resource& image)
            -> GraphResource<Description>&;

        auto setFinalResource(GraphID final) noexcept -> void;

        auto reset() -> void;
        auto bake() -> void;
        auto createFrameGraph(BakedFrameGraph *old = nullptr) -> BakedFrameGraph;
        auto allocateFrameGraph(BakedFrameGraph *old = nullptr) -> std::unique_ptr<BakedFrameGraph>;

        auto hasTask(GraphID id) const noexcept -> bool;
        auto hasTask(std::string_view name) const noexcept -> bool;

        template<class TaskData>
        auto getTask(std::string_view name) noexcept -> GraphTask<TaskData>&;
        template<class TaskData>
        auto getTask(std::string_view name) const noexcept -> const GraphTask<TaskData>&;

        template<class TaskData>
        auto getTask(GraphID id) noexcept -> GraphTask<TaskData>&;
        template<class TaskData>
        auto getTask(GraphID id) const noexcept -> const GraphTask<TaskData>&;

        auto getTask(std::string_view name) noexcept -> GraphTaskBase&;
        auto getTask(std::string_view name) const noexcept -> const GraphTaskBase&;
        auto getTask(GraphID id) noexcept -> GraphTaskBase&;
        auto getTask(GraphID id) const noexcept -> const GraphTaskBase&;

        auto hasResource(GraphID id) const noexcept -> bool;
        auto hasResource(std::string_view name) const noexcept -> bool;

        template<class Description>
        auto getResource(std::string_view name) noexcept -> GraphResource<Description>&;
        template<class Description>
        auto getResource(std::string_view name) const noexcept -> const GraphResource<Description>&;

        template<class Description>
        auto getResource(GraphID id) noexcept -> GraphResource<Description>&;
        template<class Description>
        auto getResource(GraphID id) const noexcept -> const GraphResource<Description>&;

        auto getResource(std::string_view name) noexcept -> GraphResourceBase&;
        auto getResource(std::string_view name) const noexcept -> const GraphResourceBase&;
        auto getResource(GraphID id) noexcept -> GraphResourceBase&;
        auto getResource(GraphID id) const noexcept -> const GraphResourceBase&;

      private:
        using ResourceVariant = std::variant<const gpu::Image *, const gpu::Buffer *>;

        struct BufferInfo {
            GraphID id;
            gpu::Buffer::CreateInfo create_info;
            std::string_view name;
        };

        struct ImageInfo {
            GraphID id;
            gpu::Image::CreateInfo create_info;
            gpu::ClearValue clear_value;
            std::string_view name;
        };

        struct Pass {
            GraphID id = INVALID_ID;

            std::optional<gpu::RenderPassDescription> description;
            std::string_view name;

            std::vector<BufferInfo> buffers;
            std::vector<ImageInfo> images;
        };

        auto prepareTask(GraphTaskBase& task) noexcept -> void;

        auto cullUnreferencedResources() noexcept -> void;
        auto buildPhysicalDescriptions() noexcept -> void;
        auto buildImagePhysicalDescriptions(const GraphTaskBase& task) noexcept
            -> std::vector<ImageInfo>;
        auto buildBufferPhysicalDescriptions(const GraphTaskBase& task) noexcept
            -> std::vector<BufferInfo>;
        auto buildRenderPassPhysicalDescription(
            const GraphTaskBase& task,
            core::HashMap<GraphID, gpu::ImageLayout>& layouts) noexcept
            -> gpu::RenderPassDescription;
        auto allocatePhysicalResources() -> BakedFrameGraph::Data;

        std::future<void> m_bake_future;
        std::vector<std::unique_ptr<GraphTaskBase>> m_tasks;
        std::vector<std::unique_ptr<GraphResourceBase>> m_resources;
        GraphID m_final_resource = INVALID_ID;

        core::HashMap<GraphID, ResourceVariant> m_retained_resources;

        std::vector<Pass> m_preprocessed_framegraph;

        friend class GraphTaskBuilder;
    };

    DECLARE_PTR_AND_REF(FrameGraphBuilder);

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData, typename... Args>
    inline auto FrameGraphBuilder::addTask(std::string name, Args&&...args)
        -> GraphTask<TaskData>& {
        core::expects(!hasTask(name), std::format("Task {} already registered !", name));

        auto& task = m_tasks.emplace_back(
            std::make_unique<GraphTask<TaskData>>(std::move(name), std::forward<Args>(args)...));
        prepareTask(*task);

        return static_cast<GraphTask<TaskData>&>(*task);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType Description, gpu::ResourceType Resource>
    inline auto FrameGraphBuilder::setRetainedResource(std::string name,
                                                       Description&& description,
                                                       const Resource& image)
        -> GraphResource<Description>& {
        auto& graph_resource = m_resources.emplace_back(
            std::make_unique<GraphResource<Description>>(std::move(name),
                                                         INVALID_ID,
                                                         std::forward<Description>(description)));

        m_retained_resources.emplace(graph_resource->id(), ResourceVariant { &image });

        return static_cast<GraphResource<Description>&>(*graph_resource);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameGraphBuilder::setFinalResource(GraphID id) noexcept -> void {
        m_final_resource = id;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameGraphBuilder::hasTask(GraphID id) const noexcept -> bool {
        return std::ranges::any_of(m_tasks, [&](const auto& t) { return t->id() == id; });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameGraphBuilder::hasTask(std::string_view name) const noexcept -> bool {
        return std::ranges::any_of(m_tasks, [&](const auto& t) { return t->name() == name; });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData>
    inline auto FrameGraphBuilder::getTask(std::string_view name) noexcept -> GraphTask<TaskData>& {
        return static_cast<GraphTask<TaskData>&>(getTask(name));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData>
    inline auto FrameGraphBuilder::getTask(std::string_view name) const noexcept
        -> const GraphTask<TaskData>& {
        return static_cast<const GraphTask<TaskData>&>(getTask(name));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData>
    inline auto FrameGraphBuilder::getTask(GraphID id) noexcept -> GraphTask<TaskData>& {
        return static_cast<GraphTask<TaskData>&>(getTask(id));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData>
    inline auto FrameGraphBuilder::getTask(GraphID id) const noexcept
        -> const GraphTask<TaskData>& {
        return static_cast<const GraphTask<TaskData>&>(getTask(id));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameGraphBuilder::getTask(std::string_view name) noexcept -> GraphTaskBase& {
        auto it = std::ranges::find_if(m_tasks, [&](const auto& t) { return t->name() == name; });

        STORMKIT_ENSURES_MESSAGE(it != std::ranges::end(m_tasks),
                                 std::format("task with name {} not found", name));

        return **it;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameGraphBuilder::getTask(std::string_view name) const noexcept
        -> const GraphTaskBase& {
        const auto it =
            std::ranges::find_if(m_tasks, [&](const auto& t) { return t->name() == name; });

        STORMKIT_ENSURES_MESSAGE(it != std::ranges::cend(m_tasks),
                                 std::format("task with name {} not found", name));

        return **it;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameGraphBuilder::getTask(GraphID id) noexcept -> GraphTaskBase& {
        auto it = std::ranges::find_if(m_tasks, [&](const auto& t) { return t->id() == id; });

        STORMKIT_ENSURES_MESSAGE(it != std::ranges::end(m_tasks),
                                 std::format("task with id {} not found", id));

        return **it;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameGraphBuilder::getTask(GraphID id) const noexcept -> const GraphTaskBase& {
        const auto it = std::ranges::find_if(m_tasks, [&](const auto& t) { return t->id() == id; });

        STORMKIT_ENSURES_MESSAGE(it != std::ranges::cend(m_tasks),
                                 std::format("task with id {} not found", id));

        return **it;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameGraphBuilder::hasResource(GraphID id) const noexcept -> bool {
        return std::ranges::any_of(m_resources, [&](const auto& t) { return t->id() == id; });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameGraphBuilder::hasResource(std::string_view name) const noexcept -> bool {
        return std::ranges::any_of(m_resources, [&](const auto& t) { return t->name() == name; });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class ResourceData>
    inline auto FrameGraphBuilder::getResource(std::string_view name) noexcept
        -> GraphResource<ResourceData>& {
        return static_cast<GraphResource<ResourceData>&>(getResource(name));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class ResourceData>
    inline auto FrameGraphBuilder::getResource(std::string_view name) const noexcept
        -> const GraphResource<ResourceData>& {
        return static_cast<const GraphResource<ResourceData>&>(getResource(name));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class ResourceData>
    inline auto FrameGraphBuilder::getResource(GraphID id) noexcept
        -> GraphResource<ResourceData>& {
        return static_cast<GraphResource<ResourceData>&>(getResource(id));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class ResourceData>
    inline auto FrameGraphBuilder::getResource(GraphID id) const noexcept
        -> const GraphResource<ResourceData>& {
        return static_cast<const GraphResource<ResourceData>&>(getResource(id));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameGraphBuilder::getResource(std::string_view name) noexcept
        -> GraphResourceBase& {
        auto it =
            std::ranges::find_if(m_resources, [&](const auto& t) { return t->name() == name; });

        STORMKIT_ENSURES_MESSAGE(it != std::ranges::end(m_resources),
                                 std::format("resource with name {} not found", name));

        return **it;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameGraphBuilder::getResource(std::string_view name) const noexcept
        -> const GraphResourceBase& {
        const auto it =
            std::ranges::find_if(m_resources, [&](const auto& t) { return t->name() == name; });

        STORMKIT_ENSURES_MESSAGE(it != std::ranges::cend(m_resources),
                                 std::format("resource with name {} not found", name));

        return **it;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameGraphBuilder::getResource(GraphID id) noexcept -> GraphResourceBase& {
        auto it = std::ranges::find_if(m_resources, [&](const auto& t) { return t->id() == id; });

        STORMKIT_ENSURES_MESSAGE(it != std::ranges::end(m_resources),
                                 std::format("resource with id {} not found", id));

        return **it;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameGraphBuilder::getResource(GraphID id) const noexcept
        -> const GraphResourceBase& {
        const auto it =
            std::ranges::find_if(m_resources, [&](const auto& t) { return t->id() == id; });

        STORMKIT_ENSURES_MESSAGE(it != std::ranges::cend(m_resources),
                                 std::format("resource with id {} not found", id));

        return **it;
    }
} // namespace stormkit::engine
