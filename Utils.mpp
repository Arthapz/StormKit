// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

export module stormkit.Core:Utils;

export import :Utils.Algorithms;
export import :Utils.Assert;
export import :Utils.AsCast;
export import :Utils.Numerics;
/*
import std.compat;
import <cstdio>;
import <cstdlib>;

import <stormkit/Core/PlatformMacro.hpp>;

import :AsCast;
import :Concepts;
import :Types;
import :Assert;
import :Hash;
import :HashMap;

export {
#else
    #include <stormkit/std.hpp>

    #include <stormkit/Core/AsCast.hpp>
    #include <stormkit/Core/Assert.hpp>
    #include <stormkit/Core/Concepts.hpp>
    #include <stormkit/Core/Hash.hpp>
    #include <stormkit/Core/HashMap.hpp>
    #include <stormkit/Core/MemoryMacro.hpp>
    #include <stormkit/Core/PlatformMacro.hpp>
    #include <stormkit/Core/Types.hpp>
#endif
    namespace stormkit::core {
        STORMKIT_API [[nodiscard]] auto read(std::istream& stream, RangeExtent size) noexcept
            -> std::vector<Byte>;

        template<RangeExtent size>
        [[nodiscard]] auto read(std::istream& stream) noexcept -> std::array<Byte, size>;

        STORMKIT_API auto read(std::istream& stream, std::span<Byte> output) noexcept -> void;

        STORMKIT_API auto write(std::ostream& stream, std::span<const Byte> data) noexcept -> void;

        STORMKIT_API [[nodiscard]] auto readText(std::istream& stream, RangeExtent size) noexcept
            -> std::string;

        STORMKIT_API auto readText(std::istream& stream, std::span<char> output) noexcept -> void;

        STORMKIT_API auto writeText(std::ostream& stream, std::string_view data) noexcept -> void;

        template<class T, template<class> class CRTP_TYPE>
        struct CRTP {
            [[nodiscard]] constexpr auto underlying() noexcept -> T&;
            [[nodiscard]] constexpr auto underlying() const noexcept -> const T&;
        };

        namespace literals {
            STORMKIT_API [[nodiscard]] constexpr auto operator""_kb(unsigned long long x) noexcept
                -> core::UInt64;

            STORMKIT_API [[nodiscard]] constexpr auto operator""_mb(unsigned long long x) noexcept
                -> core::UInt64;

            STORMKIT_API [[nodiscard]] constexpr auto operator""_gb(unsigned long long x) noexcept
                -> core::UInt64;

            STORMKIT_API [[nodiscard]] constexpr auto operator""_kib(unsigned long long x) noexcept
                -> core::UInt64;

            STORMKIT_API [[nodiscard]] constexpr auto operator""_mib(unsigned long long x) noexcept
                -> core::UInt64;

            STORMKIT_API [[nodiscard]] constexpr auto operator""_gib(unsigned long long x) noexcept
                -> core::UInt64;
        } // namespace literals

        STORMKIT_API auto split(std::string_view string, char delim) -> std::vector<std::string>;

        STORMKIT_API auto toLower(std::string_view string, std::locale locale = std::locale(""))
            -> std::string;
        STORMKIT_API auto toUpper(std::string_view string, std::locale locale = std::locale(""))
            -> std::string;

        struct STORMKIT_API StringHash {
            using is_transparent = void;

            [[nodiscard]] auto operator()(const std::string& value) const noexcept -> core::Hash64;
            [[nodiscard]] auto operator()(std::string_view value) const noexcept -> core::Hash64;
        };

        struct STORMKIT_API StringEqual {
            using is_transparent = void;

            [[nodiscard]] auto operator()(const std::string& a, const std::string& b) const noexcept
                -> bool;
            [[nodiscard]] auto operator()(const std::string& a, std::string_view b) const noexcept
                -> bool;
            [[nodiscard]] auto operator()(std::string_view a, const std::string& b) const noexcept
                -> bool;
            [[nodiscard]] auto operator()(std::string_view a, std::string_view b) const noexcept
                -> bool;
        };

        STORMKIT_API auto asciiToUtf16(std::string_view) -> std::u16string;
        STORMKIT_API auto utf16ToAscii(std::u16string_view) -> std::string;

        STORMKIT_API auto asciiToWide(std::string_view) -> std::wstring;
        STORMKIT_API auto wideToAscii(std::wstring_view) -> std::string;

        STORMKIT_API auto asciiToUtf8(std::string_view) -> std::u8string;
        STORMKIT_API auto utf8ToAscii(std::u8string_view) -> std::string;

#ifdef STORMKIT_COMPILER_MSVC
        STORMKIT_API auto toNativeEncoding(std::string_view) -> std::wstring;
#else
    STORMKIT_API auto toNativeEncoding(std::string_view) -> std::u8string;
#endif

        template<class T>
        using StringHashMap = HashMap<std::string, T, StringHash, StringEqual>;

        template<IsByte... T>
        constexpr auto makeStaticByteArray(T... bytes) noexcept -> decltype(auto);

        template<IsNotByte... T>
        constexpr auto makeStaticByteArray(T... bytes) noexcept -> decltype(auto);

        /// \brief Create an observer ptr from a pointer value.
        /// \requires `T` shall to be a raw or a smart pointer.
        /// \param ptr The pointer to observe.
        /// \returns An observer ptr.
        template<IsPointer T>
        constexpr auto makeObserver(T& ptr) noexcept -> decltype(auto);

        /// \brief Create an observer ptr from a non-pointer value.
        /// \requires `T` shall not to be a raw or a smart pointer.
        /// \param value The value to observe.
        /// \returns An observer ptr.
        template<IsNotPointer T>
        constexpr auto makeObserver(T& value) noexcept -> decltype(auto);

        /// \brief Create a const observer ptr from a pointer value.
        /// \requires `T` shall to be a raw or a smart pointer.
        /// \param ptr The pointer to observe.
        /// \returns A const observer ptr.
        template<IsPointer T>
        constexpr auto makeConstObserver(const T& ptr) noexcept -> decltype(auto);

        /// \brief Create a const observer ptr from a non-pointer value.
        /// \requires `T` shall not to be a raw or a smart pointer.
        /// \param value The value to observe.
        /// \returns A const observer ptr.
        template<IsNotPointer T>
        constexpr auto makeConstObserver(const T& value) noexcept -> decltype(auto);

        /// TODO FIX DOC
        /// \brief Create an  from a pointer value.
        /// \requires `T` shall to be a raw or a smart pointer.
        /// \param ptr The pointer to observe.
        /// \returns An observer ptr.
        template<IsPointer T>
        constexpr auto makeRef(T& ptr) noexcept -> decltype(auto);

        /// TODO FIX DOC
        /// \brief Create an observer ptr from a non-pointer value.
        /// \requires `T` shall not to be a raw or a smart pointer.
        /// \param value The value to observe.
        /// \returns An observer ptr.
        template<IsNotPointer T>
        constexpr auto makeRef(T& value) noexcept -> decltype(auto);

        /// TODO FIX DOC
        /// \brief Create a const observer ptr from a pointer value.
        /// \requires `T` shall to be a raw or a smart pointer.
        /// \param ptr The pointer to observe.
        /// \returns A const observer ptr.
        template<IsPointer T>
        constexpr auto makeConstRef(const T& ptr) noexcept -> decltype(auto);

        /// TODO FIX DOC
        /// \brief Create a const observer ptr from a non-pointer value.
        /// \requires `T` shall not to be a raw or a smart pointer.
        /// \param value The value to observe.
        /// \returns A const observer ptr.
        template<IsNotPointer T>
        constexpr auto makeConstRef(const T& value) noexcept -> decltype(auto);

        /// \brief Create a static array of observer ptr.
        ///
        /// Observer pointers are created with `makeObserver`.
        ///
        /// \param args The list of values to observe.
        /// \returns A static array of observer ptr.
        template<class... Args>
        constexpr auto makeObserverStaticArray(Args&&...args) noexcept -> decltype(auto);

        /// \brief Create a static array of const observer ptr.
        ///
        /// Observer pointers are created with `makeConstObserver`.
        ///
        /// \param args The list of values to observe.
        /// \returns A static array of const observer ptr.
        template<class... Args>
        constexpr auto makeConstObserverStaticArray(Args&&...args) noexcept -> decltype(auto);

        /// \brief Create a dynamic array of observer ptr.
        ///
        /// Observer pointers are created with `makeObserver`.
        ///
        /// \param args The list of values to observe.
        /// \returns A dynamic array of observer ptr.
        template<class... Args>
        auto makeObserverArray(Args&&...args) noexcept -> decltype(auto);

        /// \brief Create a dynamic array of const observer ptr.
        ///
        /// Observer pointers are created with `makeConstObserver`.
        ///
        /// \param args The list of values to observe.
        /// \returns A dynamic array of const observer ptr.
        template<class... Args>
        auto makeConstObserverArray(Args&&...args) noexcept -> decltype(auto);

        /// \brief Create a static array of reference_wrapper.
        ///
        /// References are created with `std::ref`.
        ///
        /// \param args The list of values to observe.
        /// \returns A static array of reference_wrapper
        template<class... Args>
        auto makeRefStaticArray(Args&&...args) noexcept -> decltype(auto);

        /// \brief Create a dynamic array of reference_wrapper.
        ///
        /// References are created with `std::ref`.
        ///
        /// \param args The list of values to observe.
        /// \returns A dynamic array of reference_wrapper
        template<class... Args>
        auto makeRefArray(Args&&...args) noexcept -> decltype(auto);

        /// \brief Create a dynamic array of const reference_wrapper.
        ///
        /// References are created with `std::cref`.
        ///
        /// \param args The list of values to observe.
        /// \returns A dynamic array of const reference_wrapper.
        template<class... Args>
        auto makeConstRefStaticArray(Args&&...args) noexcept -> decltype(auto);

        /// \brief Create a dynamic array of const reference_wrapper.
        ///
        /// References are created with `std::cref`.
        ///
        /// \param args The list of values to observe.
        /// \returns A dynamic array of const reference_wrapper.
        template<class... Args>
        auto makeConstRefArray(Args&&...args) noexcept -> decltype(auto);

        /// \brief Convert an array of data to an array of observer ptr of data.
        ///
        /// Observers ptr are created with makeObserverPtr.
        ///
        /// \param container The array to convert.
        /// \returns A dynamic array of observer ptrs.
        template<std::ranges::range Container>
        auto toObserverArray(Container&& container) -> decltype(auto);

        /// \brief Convert an array of const data to an array of const observer ptr of data.
        ///
        /// Observers ptr are created with makeConstObserverPtr.
        ///
        /// \param container The array to convert.
        /// \returns A dynamic array of const observer ptrs.
        template<std::ranges::range Container>
        auto toConstObserverArray(Container&& container) -> decltype(auto);

        /// \brief Convert an array of data to an array of reference_wrapper of data.
        ///
        /// Reference_wrappers are created with std::ref.
        ///
        /// \param container The array to convert.
        /// \returns A dynamic array of reference_wrapper.
        template<std::ranges::range Container>
        auto toRefArray(Container&& container) -> decltype(auto);

        template<std::ranges::range Container>
        auto toArray(Container&& container) -> decltype(auto);

        /// \brief Convert an array of data to an array of const reference_wrapper of data.
        ///
        /// Reference_wrappers are created with std::ref.
        ///
        /// \param container The array to convert.
        /// \returns A dynamic array of const reference_wrapper.
        template<std::ranges::range Container>
        auto toConstRefArray(Container&& container) -> decltype(auto);

        /// \brief Create a static array of `T`
        /// \param first The first value, the array will be an array of this type
        /// \param args The list of values
        /// \requires all values need to be the same type as / convertible to `T`
        /// \return A static array of T
        template<class T, typename... Args>
            requires((core::Is<T, Args> and ...) or (std::convertible_to<T, Args> and ...) or
                     (std::constructible_from<T, Args> and ...))
        constexpr auto makeStaticArray(T&& first, Args&&...args) noexcept -> decltype(auto);

        /// \brief Create a dynamic array of `T`
        /// \param first The first value, the array will be an array of this type
        /// \param args The list of values
        /// \requires all values need to be the same type as `T`
        /// \return A dynamic array of T
        template<class T, typename... Args>
            requires((core::Is<T, Args> and ...) or (std::convertible_to<T, Args> and ...) or
                     (std::constructible_from<T, Args> and ...))
        auto makeArray(T&& first, Args&&...args) -> decltype(auto);

        /// \brief Utility to defer allocation on stack of a class member
        template<class T>
        using DeferredAlloc = std::optional<T>;

        template<SmartIsPointer T>
        [[nodiscard]] auto addressOf(const T& ptr) noexcept -> std::intptr_t;

        template<IsRawPointer T>
        [[nodiscard]] constexpr auto addressOf(const T& ptr) noexcept -> std::intptr_t;

        template<class T, IsBinaryPredicate<std::remove_cvref_t<T>> BinaryPredicate>
        [[nodiscard]] constexpr auto binaryToUnary(T&& value, BinaryPredicate&& predicate) noexcept;

        template<class T>
        [[nodiscard]] constexpr auto toLambda(T&& t);

        STORMKIT_API auto setupSignalHandler() noexcept -> void;

        STORMKIT_API [[nodiscard]] constexpr auto
            toEndian(std::integral auto value,
                     std::endian source,
                     std::endian destination = std::endian::native) noexcept -> decltype(auto);

        template<class T>
        struct ValueReseter {
            ~ValueReseter() {
                if (reset) value = T {};
            }

            T& value;
            bool reset = true;
        };

        template<IsCharacter T, IsFormattable<T>... Args>
        auto printBase(std::basic_format_string<T, Args...> format_string, Args&&...args) -> void;

        template<IsCharacter T, IsFormattable<T>... Args>
        auto vprintBase(std::basic_string_view<T> format_string, Args&&...args) -> void;

        template<IsCharacter T, IsFormattable<T>... Args>
        auto printlnBase(std::basic_format_string<T, Args...> format_string, Args&&...args) -> void;

        template<IsCharacter T, IsFormattable<T>... Args>
        auto vprintlnBase(std::basic_string_view<T> format_string, Args&&...args) -> void;

        template<IsFormattable<char>... Args>
        auto print(std::format_string<Args...> format_string, Args&&...args) -> void;

        template<IsFormattable<char>... Args>
        auto vprint(std::string_view format_string, Args&&...args) -> void;

        template<IsFormattable<char>... Args>
        auto println(std::format_string<Args...> format_string, Args&&...args) -> void;

        template<IsFormattable<char>... Args>
        auto vprintln(std::string_view format_string, Args&&...args) -> void;

    } // namespace stormkit::core

#ifndef STORMKIT_NO_MODULES
}
#endif

namespace stormkit::core {
    namespace details {
        STORMKIT_API [[nodiscard]] auto randomGenerator() noexcept -> std::default_random_engine&;

        /////////////////////////////////////
        /////////////////////////////////////
        constexpr auto byteSwap(std::integral auto value) noexcept -> decltype(auto) {
            auto repr = std::bit_cast<std::array<std::byte, sizeof(value)>>(value);
            std::ranges::reverse(repr);
            return std::bit_cast<decltype(value)>(repr);
        }
    } // namespace details

    /////////////////////////////////////
    /////////////////////////////////////
    template<class T, template<class> class CRTP_TYPE>
    constexpr auto CRTP<T, CRTP_TYPE>::underlying() noexcept -> T& {
        return static_cast<T&>(*this);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class T, template<class> class CRTP_TYPE>
    constexpr auto CRTP<T, CRTP_TYPE>::underlying() const noexcept -> const T& {
        return static_cast<const T&>(*this);
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto read(std::istream& stream, RangeExtent size) noexcept -> std::vector<Byte> {
        auto output = std::vector<Byte> {};
        output.resize(size);

        read(stream, output);

        return output;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<RangeExtent size>
    inline auto read(std::istream& stream) noexcept -> std::array<Byte, size> {
        auto output = std::array<Byte, size> {};

        read(stream, output);

        return output;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto read(std::istream& stream, std::span<Byte> output) noexcept -> void {
        stream.read(std::bit_cast<char *>(std::data(output)), std::size(output));
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto write(std::ostream& stream, std::span<const Byte> data) noexcept -> void {
        stream.write(std::bit_cast<const char *>(std::data(data)), std::size(data));
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto readText(std::istream& stream, RangeExtent size) noexcept -> std::string {
        auto output = std::string {};
        output.resize(size);

        readText(stream, output);

        return output;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto readText(std::istream& stream, std::span<char> output) noexcept -> void {
        stream.read(std::data(output), std::size(output));
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto writeText(std::ostream& stream, std::string_view data) noexcept -> void {
        stream.write(std::data(data), std::size(data));
    }

    namespace literals {
        /////////////////////////////////////
        /////////////////////////////////////
        inline constexpr auto operator""_kb(unsigned long long x) noexcept -> core::UInt64 {
            return 1000ULL * x;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        inline constexpr auto operator""_mb(unsigned long long x) noexcept -> core::UInt64 {
            return 1000ULL * 1000ULL * x;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        inline constexpr auto operator""_gb(unsigned long long x) noexcept -> core::UInt64 {
            return 1000ULL * 1000ULL * 1000ULL * x;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        inline constexpr auto operator""_kib(unsigned long long x) noexcept -> core::UInt64 {
            return 1024ULL * x;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        inline constexpr auto operator""_mib(unsigned long long x) noexcept -> core::UInt64 {
            return 1024ULL * 1024ULL * x;
        }

        /////////////////////////////////////
        /////////////////////////////////////
        inline constexpr auto operator""_gib(unsigned long long x) noexcept -> core::UInt64 {
            return 1024ULL * 1000ULL * 1024ULL * x;
        }
    } // namespace literals

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsArithmetic T, IsArithmetic V>
    constexpr auto map(V x, V in_min, V in_max, T out_min, T out_max) noexcept -> T {
        return as<T>((x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::integral auto start, std::integral auto stop>
    constexpr auto range() noexcept -> std::array<decltype(stop - start), stop - start> {
        auto output = std::array<decltype(stop - start), stop - start> {};

        std::iota(std::begin(output), std::end(output), start);

        return output;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::integral T, std::convertible_to<T> U>
    constexpr auto range(T stop, U increment) noexcept -> std::vector<T> {
        return range(T { 0 }, stop, increment);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::integral T, std::convertible_to<T> U>
    constexpr auto range(T start, T stop, U increment) noexcept -> std::vector<T> {
        auto output = std::vector<T> {};
        output.resize(stop - start);

        auto i = 0;
        for (auto& v : output) {
            v = i * core::as<T>(increment);
            ++i;
        }

        return output;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto split(std::string_view string, char delim) -> std::vector<std::string> {
        auto output = std::vector<std::string> {};
        auto first  = RangeExtent { 0u };

        while (first < string.size()) {
            const auto second = string.find_first_of(delim, first);

            if (first != second) output.emplace_back(string.substr(first, second - first));

            if (second == std::string_view::npos) break;

            first = second + 1;
        }

        return output;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto toLower(std::string_view string, std::locale locale) -> std::string {
        auto& facet = std::use_facet<std::ctype<class std::string_view::value_type>>(locale);

        auto result = std::string { string };
        facet.tolower(&result[0], &result[0] + result.size());

        return result;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto toUpper(std::string_view string, std::locale locale) -> std::string {
        auto& facet = std::use_facet<std::ctype<class std::string_view::value_type>>(locale);

        auto result = std::string { string };
        facet.toupper(&result[0], &result[0] + result.size());

        return result;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto StringEqual::operator()(const std::string& a, const std::string& b) const noexcept
        -> bool {
        return a.compare(b) == 0;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto StringEqual::operator()(const std::string& a, std::string_view b) const noexcept
        -> bool {
        return a.compare(b) == 0;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto StringEqual::operator()(std::string_view a, const std::string& b) const noexcept
        -> bool {
        return a.compare(b) == 0;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto StringEqual::operator()(std::string_view a, std::string_view b) const noexcept
        -> bool {
        return a.compare(b) == 0;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto StringHash::operator()(const std::string& value) const noexcept -> core::Hash64 {
        return std::hash<std::string> {}(value);
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto StringHash::operator()(std::string_view value) const noexcept -> core::Hash64 {
        return std::hash<std::string_view> {}(value);
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto asciiToUtf16(std::string_view input) -> std::u16string {
        auto state  = std::mbstate_t {};
        auto output = std::u16string {};
        output.resize(std::size(input));

        auto len      = 0ull;
        auto input_it = std::data(input);
        while ((len = std::mbrtoc16(reinterpret_cast<char16_t *>(std::data(output)),
                                    input_it,
                                    MB_CUR_MAX,
                                    &state)) > 0ull)
            input_it += len;

        return output;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto utf16ToAscii(std::u16string_view input) -> std::string {
        auto state  = std::mbstate_t {};
        auto output = std::string {};
        output.resize(std::size(input));

        for (const auto& c : input)
            std::c16rtomb(reinterpret_cast<char *>(std::data(output)), c, &state);

        return output;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto asciiToWide(std::string_view input) -> std::wstring {
        auto state  = std::mbstate_t {};
        auto output = std::wstring {};
        output.resize(std::size(input));

        auto len      = 0ull;
        auto input_it = std::data(input);
        auto i        = 0;
#ifdef STORMKIT_COMPILER_MSVC
        while ((len = std::mbrtoc16(reinterpret_cast<char16_t *>(std::data(output)) + i++,
                                    input_it,
                                    MB_CUR_MAX,
                                    &state)) > 0u)
            input_it += len;
#else
        while ((len = std::mbrtoc8(reinterpret_cast<char *>(std::data(output)) + i++,
                                   input_it,
                                   MB_CUR_MAX,
                                   &state)) > 0ull)
            input_it += len;
#endif

        return output;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto wideToAscii(std::wstring_view input) -> std::string {
        auto state  = std::mbstate_t {};
        auto output = std::string {};
        output.resize(std::size(input));

#ifdef STORMKIT_COMPILER_MSVC
        for (const auto& c : input) std::c16rtomb(std::data(output), core::as<char16_t>(c), &state);
#else
        for (const auto& c : input) std::c8rtomb(std::data(output), core::as<char>(c), &state);
#endif

        return output;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto asciiToUtf8(std::string_view input) -> std::u8string {
        auto state  = std::mbstate_t {};
        auto output = std::u8string {};
        output.resize(std::size(input) * as<RangeExtent>(MB_LEN_MAX));

#ifdef STORMKIT_COMPILER_MSVC
        auto bytes = toByteSpan(output);
        std::ranges::copy(asByteView(input), std::ranges::begin(bytes));
#else
        auto len      = 0ull;
        auto input_it = std::data(input);
        auto i        = 0;
        while ((len = std::mbrtoc8(reinterpret_cast<char *>(std::data(output)) + i++,
                                   input_it,
                                   MB_CUR_MAX,
                                   &state)) > 0ull)
            input_it += len;
#endif

        output.shrink_to_fit();

        return output;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto utf8ToAscii(std::u8string_view input) -> std::string {
        auto state  = std::mbstate_t {};
        auto output = std::string {};
        output.resize(std::size(input));

#ifdef STORMKIT_COMPILER_MSVC
        auto bytes = toByteSpan(output);
        std::ranges::copy(asByteView(input), std::ranges::begin(bytes));
#else
        for (const auto& c : input) std::c8rtomb(std::data(output), c, &state);
#endif

        output.shrink_to_fit();

        return output;
    }

#ifdef STORMKIT_COMPILER_MSVC
    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto toNativeEncoding(std::string_view input) -> std::wstring {
        return asciiToWide(input);
    }
#else
    ////////////////////////////////////////
    ////////////////////////////////////////
    inline auto toNativeEncoding(std::string_view input) -> std::u8string {
        return asciiToUtf8(input);
    }
#endif

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsByte... T>
    constexpr auto makeStaticByteArray(T... bytes) noexcept -> decltype(auto) {
        return std::array { bytes... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNotByte... T>
    constexpr auto makeStaticByteArray(T... bytes) noexcept -> decltype(auto) {
        return std::array { static_cast<Byte>(bytes)... };
    }

    /////////////////////////////////////
    /////////////////////////////////////

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto makeValueReseter(auto& value) noexcept -> decltype(auto) {
        return ValueReseter<std::remove_reference_t<decltype(value)>> { value };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsPointer T>
    constexpr auto makeObserver(T& ptr) noexcept -> decltype(auto) {
        return std::addressof(*ptr);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNotPointer T>
    constexpr auto makeObserver(T& value) noexcept -> decltype(auto) {
        return std::addressof(value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsPointer T>
    constexpr auto makeConstObserver(const T& ptr) noexcept -> decltype(auto) {
        return std::addressof(std::as_const(*ptr));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsNotPointer T>
    constexpr auto makeConstObserver(const T& value) noexcept -> decltype(auto) {
        return std::addressof(std::as_const(value));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class T, typename... Args>
        requires((core::Is<T, Args> and ...) or (std::convertible_to<T, Args> and ...) or
                 (std::constructible_from<T, Args> and ...))
    constexpr auto makeStaticArray(T&& first, Args&&...args) noexcept -> decltype(auto) {
        return std::array { std::forward<T>(first), static_cast<T>(std::forward<Args>(args))... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class T, typename... Args>
        requires((core::Is<T, Args> and ...) or (std::convertible_to<T, Args> and ...) or
                 (std::constructible_from<T, Args> and ...))
    auto makeArray(T&& first, Args&&...args) -> decltype(auto) {
        return std::vector { std::forward<T>(first), static_cast<T>(std::forward<Args>(args))... };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class... Args>
    constexpr auto makeObserverStaticArray(Args&&...args) noexcept -> decltype(auto) {
        return makeStaticArray(makeObserver(std::forward<Args>(args))...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class... Args>
    constexpr auto makeConstObserverStaticArray(Args&&...args) noexcept -> decltype(auto) {
        return makeStaticArray(makeConstObserver(std::forward<Args>(args))...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class... Args>
    auto makeObserverArray(Args&&...args) noexcept -> decltype(auto) {
        return makeArray(makeObserver(std::forward<Args>(args))...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class... Args>
    auto makeConstObserverArray(Args&&...args) noexcept -> decltype(auto) {
        return makeArray(makeConstObserver(std::forward<Args>(args))...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class... Args>
    auto makeRefStaticArray(Args&&...args) noexcept -> decltype(auto) {
        return makeStaticArray(makeRef(std::forward<Args>(args))...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class... Args>
    auto makeConstRefStaticArray(Args&&...args) noexcept -> decltype(auto) {
        return makeStaticArray(makeConstRef(std::forward<Args>(args))...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class... Args>
    auto makeRefArray(Args&&...args) noexcept -> decltype(auto) {
        return makeArray(makeRef(std::forward<Args>(args))...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class... Args>
    auto makeConstRefArray(Args&&...args) noexcept -> decltype(auto) {
        return makeArray(makeConstRef(std::forward<Args>(args))...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::ranges::range Container>
    auto toObserverArray(Container&& container) -> decltype(auto) {
        using value_type = typename std::remove_cvref_t<Container>::value_type;

        auto vec = std::vector<value_type *> {};
        vec.reserve(std::size(container));

        std::ranges::transform(container, std::back_inserter(vec), makeObserver);

        return vec;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::ranges::range Container>
    auto toConstObserverArray(Container&& container) -> decltype(auto) {
        using value_type = typename std::remove_cvref_t<Container>::value_type;

        auto vec = std::vector<const value_type *> {};
        vec.reserve(std::size(container));

        std::ranges::transform(container, std::back_inserter(vec), makeConstObserver);

        return vec;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::ranges::range Container>
    auto toRefArray(Container&& container) -> decltype(auto) {
        using value_type = typename std::remove_cvref_t<Container>::value_type;

        auto vec = std::vector<std::reference_wrapper<value_type>> {};
        vec.reserve(std::size(container));

        std::ranges::transform(container, std::back_inserter(vec), std::ref);

        return vec;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::ranges::range Container>
    auto toConstRefArray(Container&& container) -> decltype(auto) {
        using value_type = typename std::remove_cvref_t<Container>::value_type;

        auto vec = std::vector<const value_type&> {};
        vec.reserve(std::size(container));

        std::ranges::transform(container, std::back_inserter(vec), std::cref);

        return vec;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::ranges::range Container>
    auto toArray(Container&& container) -> decltype(auto) {
        auto output = std::vector<class std::remove_cvref_t<Container>::value_type> {};
        output.reserve(std::size(container));

        std::ranges::copy(container, std::back_inserter(output));

        return output;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<SmartIsPointer T>
    auto addressOf(const T& ptr) noexcept -> std::intptr_t {
        return addressOf(ptr.get());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsRawPointer T>
    constexpr auto addressOf(const T& ptr) noexcept -> std::intptr_t {
        return reinterpret_cast<std::intptr_t>(ptr.get());
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::ranges::input_range Range,
             IsUnaryPredicate<class std::remove_cvref_t<Range>::value_type> Predicate>
    constexpr auto copyIf(Range&& input, Predicate&& predicate) noexcept {
        auto output = std::vector<class std::remove_cvref_t<Range>::value_type> {};
        output.reserve(std::size(input));

        std::ranges::copy_if(input, std::back_inserter(output), std::forward<Predicate>(predicate));

        return output;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::ranges::input_range Range,
             std::invocable<const typename std::remove_cvref_t<Range>::value_type&> Lambda>
    constexpr auto transform(Range&& input, Lambda&& lambda) noexcept {
        auto output = std::vector<
            std::invoke_result_t<std::remove_cvref_t<Lambda>,
                                 const typename std::remove_cvref_t<Range>::value_type&>> {};
        output.reserve(std::size(input));

        std::ranges::transform(input, std::back_inserter(output), lambda);

        return output;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::ranges::input_range Range,
             IsUnaryPredicate<class std::remove_cvref_t<Range>::value_type> Predicate,
             std::invocable<const typename std::remove_cvref_t<Range>::value_type&> Lambda>
    constexpr auto transformIf(Range&& input, Predicate&& predicate, Lambda&& lambda) noexcept {
        auto output = std::vector<
            std::invoke_result_t<std::remove_cvref_t<Lambda>,
                                 const typename std::remove_cvref_t<Range>::value_type&>> {};
        output.reserve(std::size(input));

        std::ranges::for_each(input, [&](auto& elem) {
            if (predicate(elem)) output.emplace_back(lambda(elem));
        });

        return output;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<
        std::ranges::input_range Range,
        IsUnaryPredicate<class std::remove_cvref_t<Range>::value_type> Predicate,
        std::invocable<const typename std::remove_cvref_t<Range>::value_type&> Lambda,
        std::output_iterator<
            std::invoke_result_t<Lambda, const typename std::remove_cvref_t<Range>::value_type&>>
            Iterator>
    constexpr auto
        transformIf(Range&& input, Iterator&& it, Predicate&& predicate, Lambda&& lambda) noexcept
        -> void {
        std::ranges::for_each(input, [&](auto& elem) {
            if (predicate(elem)) *it++ = lambda(elem);
        });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class T, IsBinaryPredicate<std::remove_cvref_t<T>> BinaryPredicate>
    constexpr auto binaryToUnary(T&& value, BinaryPredicate&& predicate) noexcept {
        if constexpr (std::is_rvalue_reference_v<T>)
            return [value     = std::forward<T>(value),
                    predicate = std::forward<BinaryPredicate>(predicate)](
                       const std::remove_cvref_t<T>& other) { return predicate(value, other); };
        else
            return [&value, predicate = std::forward<BinaryPredicate>(predicate)](
                       const std::remove_cvref_t<T>& other) { return predicate(value, other); };
    }

    template<class T>
    constexpr auto toLambda(T&& t) {
        return [t = std::forward<T>(t)](const auto& elem) -> decltype(t(elem)) { return t(elem); };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto setupSignalHandler() noexcept -> void {
    }

#if defined(__cpp_lib_byteswap) and __cpp_lib_byteswap >= 20210L
    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto byteSwap(std::integral auto value) noexcept -> decltype(auto) {
        return std::byteswap(value);
    }
#else
    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto byteSwap(std::integral auto value) noexcept -> decltype(auto) {
        if constexpr (sizeof(decltype(value)) == sizeof(core::UInt16)) {
    #ifdef STORMKIT_COMPILER_MSVC
            return std::bit_cast<decltype(value)>(
                _byteswap_ushort(std::bit_cast<core::UInt16>(value)));
    #else
            return details::byteSwap(value);
    #endif
        }
        if constexpr (sizeof(decltype(value)) == sizeof(core::UInt32)) {
            const auto _value  = std::bit_cast<core::UInt32>(value);
    #ifdef STORMKIT_COMPILER_MSVC
            const auto swapped = _byteswap_ulong(_value);
    #else
            const auto swapped = __builtin_bswap32(_value);
    #endif
            return std::bit_cast<decltype(value)>(swapped);
        }
        if constexpr (sizeof(decltype(value)) == sizeof(core::UInt32)) {
            const auto _value  = std::bit_cast<core::UInt64>(value);
    #ifdef STORMKIT_COMPILER_MSVC
            const auto swapped = _byteswap_uint64(_value);
    #else
            const auto swapped = __builtin_bswap64(_value);
    #endif
            return std::bit_cast<decltype(value)>(swapped);
        } else
            return details::byteSwap(value);
    }
#endif

    /////////////////////////////////////
    /////////////////////////////////////
    inline constexpr auto toEndian(std::integral auto value,
                                   std::endian source,
                                   std::endian destination) noexcept -> decltype(auto) {
        if (source == destination) return value;

        return byteSwap(value);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsCharacter T, IsFormattable<T>... Args>
    auto printBase(std::basic_format_string<T, Args...> format_string, Args&&...args) -> void {
        const auto output = std::format(std::move(format_string), std::forward<Args>(args)...);
        std::fprintf(stdout, "%s", std::data(output));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsCharacter T, IsFormattable<T>... Args>
    auto vprintBase(std::basic_string_view<T> format_string, Args&&...args) -> void {
        const auto output =
            std::vformat(format_string, std::make_format_args(std::forward<Args>(args)...));
        std::fprintf(stdout, "%s", std::data(output));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsCharacter T, IsFormattable<T>... Args>
    auto printlnBase(std::basic_format_string<T, Args...> format_string, Args&&...args) -> void {
        const auto output = std::format(std::move(format_string), std::forward<Args>(args)...);
        std::fprintf(stdout, "%s\n", std::data(output));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsCharacter T, IsFormattable<T>... Args>
    auto vprintlnBase(std::basic_string_view<T> format_string, Args&&...args) -> void {
        const auto output =
            std::vformat(format_string, std::make_format_args(std::forward<Args>(args)...));
        std::fprintf(stdout, "%s\n", std::data(output));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsFormattable<char>... Args>
    auto print(std::format_string<Args...> format_string, Args&&...args) -> void {
        printBase<char, Args...>(std::move(format_string), std::forward<Args>(args)...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsFormattable<char>... Args>
    auto vprint(std::string_view format_string, Args&&...args) -> void {
        vprintBase<char, Args...>(format_string, std::forward<Args>(args)...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsFormattable<char>... Args>
    auto println(std::format_string<Args...> format_string, Args&&...args) -> void {
        printlnBase<char, Args...>(std::move(format_string), std::forward<Args>(args)...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<IsFormattable<char>... Args>
    auto vprintln(std::string_view format_string, Args&&...args) -> void {
        vprintlnBase<char, Args...>(format_string, std::forward<Args>(args)...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class T>
    auto merge(std::vector<T>& input, std::ranges::range auto&&...others) -> void {
        input.reserve(std::size(input) + (std::size(others) + ...));

        (std::ranges::merge(others, std::back_inserter(input)), ...);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    auto concat(std::ranges::range auto&& first, std::ranges::range auto&&...others)
        -> decltype(auto) {
        auto output = std::vector<RangeType<decltype(first)>> {};

        merge(output,
              std::forward<decltype(first)>(first),
              std::forward<decltype(others)>(others)...);

        return output;
    }
} // namespace stormkit::core
*/