// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

export module stormkit.Gpu:Graphics:RasterPipeline;

import std;

import stormkit.Core;

import stormkit.Gpu:Core;
import stormkit.Gpu:Resource;
import stormkit.Gpu:Execution;

#define STATE(TYPE, NAME, MEMBER)                             \
    auto NAME() noexcept -> TYPE& {                           \
        core::expects(m_is_baked == false);                   \
        return m_state.MEMBER;                                \
    }                                                         \
    [[nodiscard]] auto NAME() const noexcept -> const TYPE& { \
        return m_state.MEMBER;                                \
    }

export namespace stormkit::gpu {
    struct VertexBindingDescription {
        core::UInt32 binding;
        core::UInt32 stride;
        VertexInputRate input_rate = VertexInputRate::Vertex;
    };

    struct VertexInputAttributeDescription {
        core::UInt32 location;
        core::UInt32 binding;
        Format format;
        core::UInt32 offset;
    };

    struct RasterPipelineVertexInputState {
        std::vector<VertexBindingDescription> binding_descriptions;
        std::vector<VertexInputAttributeDescription> input_attribute_descriptions;
    };

    struct RasterPipelineInputAssemblyState {
        PrimitiveTopology topology    = PrimitiveTopology::Triangle_List;
        bool primitive_restart_enable = false;
    };

    struct RasterPipelineViewportState {
        std::vector<Viewport> viewports;
        std::vector<Scissor> scissors;
    };

    struct RasterPipelineRasterizationState {
        bool depth_clamp_enable        = false;
        bool rasterizer_discard_enable = false;
        PolygonMode polygon_mode       = PolygonMode::Fill;
        float line_width               = 1;
        CullModeFlag cull_mode         = CullModeFlag::Back;
        FrontFace front_face           = FrontFace::Clockwise;
    };

    struct RasterPipelineMultiSampleState {
        bool sample_shading_enable            = false;
        SampleCountFlag rasterization_samples = SampleCountFlag::C1;
    };

    struct RasterPipelineColorBlendAttachmentState {
        ColorComponentFlag color_write_mask = ColorComponentFlag::RGBA;
        bool blend_enable                   = false;

        BlendFactor src_color_blend_factor   = BlendFactor::One;
        BlendFactor dst_color_blend_factor   = BlendFactor::Zero;
        BlendOperation color_blend_operation = BlendOperation::Add;

        BlendFactor src_alpha_blend_factor   = BlendFactor::One;
        BlendFactor dst_alpha_blend_factor   = BlendFactor::Zero;
        BlendOperation alpha_blend_operation = BlendOperation::Substract;
    };

    struct RasterPipelineColorBlendState {
        bool logic_operation_enable    = false;
        LogicOperation logic_operation = LogicOperation::Copy;
        std::vector<RasterPipelineColorBlendAttachmentState> attachments;
        std::array<float, 4> blend_constants = { 0.f, 0.f, 0.f, 0.f };
    };

    struct RasterPipelineDynamicState {
        std::vector<DynamicState> dynamics;
    };

    struct RasterPipelineShaderState {
        std::vector<const Shader *> shaders;
    };

    struct RasterPipelineDepthStencilState {
        bool depth_test_enable  = false;
        bool depth_write_enable = false;

        CompareOperation depth_compare_op = CompareOperation::Less;

        bool depth_bounds_test_enable = false;

        float min_depth_bounds = 0.f;
        float max_depth_bounds = 1.f;
    };

    struct RasterPipelineLayout {
        std::vector<const DescriptorSetLayout *> descriptor_set_layouts;
        std::vector<PushConstantRange> push_constant_ranges;
    };

    struct RasterPipelineState {
        RasterPipelineInputAssemblyState input_assembly_state;
        RasterPipelineViewportState viewport_state;
        RasterPipelineRasterizationState rasterization_state;
        RasterPipelineMultiSampleState multisample_state;
        RasterPipelineColorBlendState color_blend_state;
        RasterPipelineDynamicState dynamic_state;
        RasterPipelineShaderState shader_state;
        RasterPipelineVertexInputState vertex_input_state;
        RasterPipelineDepthStencilState depth_stencil_state;
        RasterPipelineLayout layout;
    };

    class STORMKIT_API RasterPipeline: public Pipeline {
      public:
        explicit RasterPipeline(const Device& device,
                                const PipelineCache *cache = nullptr) noexcept;

        ~RasterPipeline() override;

        RasterPipeline(const RasterPipeline&)                    = delete;
        auto operator=(const RasterPipeline&) -> RasterPipeline& = delete;

        RasterPipeline(RasterPipeline&&) noexcept;
        auto operator=(RasterPipeline&&) noexcept -> RasterPipeline&;

        STATE(RasterPipelineVertexInputState, vertexInputState, vertex_input_state)
        STATE(RasterPipelineInputAssemblyState, inputAssemblyState, input_assembly_state)
        STATE(RasterPipelineViewportState, viewportState, viewport_state)
        STATE(RasterPipelineRasterizationState, rasterizationState, rasterization_state)
        STATE(RasterPipelineMultiSampleState, multisampleState, multisample_state)
        STATE(RasterPipelineColorBlendState, colorBlendState, color_blend_state)
        STATE(RasterPipelineDynamicState, dynamicState, dynamic_state)
        STATE(RasterPipelineShaderState, shaderState, shader_state)
        STATE(RasterPipelineDepthStencilState, depthStencilState, depth_stencil_state)
        STATE(RasterPipelineLayout, layout, layout)

        auto bake() -> void override;

        auto setRenderPass(const RenderPass& render_pass) noexcept -> void;
        auto renderPass() const noexcept -> const RenderPass&;

        auto setState(const RasterPipelineState& state) noexcept -> void;
        [[nodiscard]] auto state() noexcept -> RasterPipelineState&;
        [[nodiscard]] auto state() const noexcept -> const RasterPipelineState&;

      protected:
        auto bind(CommandBuffer& commandbuffer) const noexcept -> void override;

      private:
        RasterPipelineState m_state = {};

        const RenderPass *m_render_pass = nullptr;
    };

    DECLARE_PTR_AND_REF(RasterPipeline);
} // namespace stormkit::gpu

HASH_FUNC(stormkit::gpu::VertexInputAttributeDescription)
HASH_FUNC(stormkit::gpu::VertexBindingDescription)
HASH_FUNC(stormkit::gpu::RasterPipelineVertexInputState)
HASH_FUNC(stormkit::gpu::RasterPipelineInputAssemblyState)
HASH_FUNC(stormkit::gpu::RasterPipelineViewportState)
HASH_FUNC(stormkit::gpu::RasterPipelineRasterizationState)
HASH_FUNC(stormkit::gpu::RasterPipelineMultiSampleState)
HASH_FUNC(stormkit::gpu::RasterPipelineColorBlendAttachmentState)
HASH_FUNC(stormkit::gpu::RasterPipelineColorBlendState)
HASH_FUNC(stormkit::gpu::RasterPipelineDynamicState)
HASH_FUNC(stormkit::gpu::RasterPipelineShaderState)
HASH_FUNC(stormkit::gpu::RasterPipelineDepthStencilState)
HASH_FUNC(stormkit::gpu::RasterPipelineLayout)
HASH_FUNC(stormkit::gpu::RasterPipelineState)

#ifndef STORMKIT_NO_MODULES
}
#endif

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::gpu {
    /////////////////////////////////////
    /////////////////////////////////////
    inline auto RasterPipeline::setRenderPass(const RenderPass& render_pass) noexcept -> void {
        core::expects(m_is_baked == false);

        m_render_pass = &render_pass;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto RasterPipeline::renderPass() const noexcept -> const RenderPass& {
        core::expects(m_render_pass);

        return *m_render_pass;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto RasterPipeline::setState(const RasterPipelineState& state) noexcept -> void {
        core::expects(m_is_baked == false);

        m_state = state;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto RasterPipeline::state() noexcept -> RasterPipelineState& {
        core::expects(m_is_baked == false);

        return m_state;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto RasterPipeline::state() const noexcept -> const RasterPipelineState& {
        return m_state;
    }
} // namespace stormkit::gpu
