// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

#ifndef STORMKIT_NO_MODULES
export module stormkit.Gpu:Compute;

import std;

import stormkit.Core;

import stormkit.Gpu:Core;
import stormkit.Gpu:Resource;
import stormkit.Gpu:Execution;
#endif

#define STATE(TYPE, NAME, MEMBER)                             \
    auto NAME() noexcept -> TYPE& {                           \
        core::expects(m_is_baked == false);                   \
        return m_state.MEMBER;                                \
    }                                                         \
    [[nodiscard]] auto NAME() const noexcept -> const TYPE& { \
        return m_state.MEMBER;                                \
    }

#ifndef STORMKIT_NO_MODULES
export {
#else
    #include <stormkit/std.hpp>

    #include <stormkit/Core.hpp>

    #include <stormkit/gpu/Core.hpp>
    #include <stormkit/gpu/Execution.hpp>
    #include <stormkit/gpu/Resource.hpp>
#endif

    namespace stormkit::gpu {
        struct ComputePipelineShaderState {
            const Shader *shader = nullptr;
        };

        struct ComputePipelineLayout {
            std::vector<const DescriptorSetLayout *> descriptor_set_layouts;
            std::vector<PushConstantRange> push_constant_ranges;
        };

        struct ComputePipelineState {
            ComputePipelineShaderState shader_state;
            ComputePipelineLayout layout;
        };

        class STORMKIT_API ComputePipeline: public Pipeline {
          public:
            static constexpr auto DEBUG_TYPE = DebugObjectType::Pipeline;

            ComputePipeline(const Device& device, const PipelineCache *cache = nullptr) noexcept;
            ~ComputePipeline() override;

            ComputePipeline(const ComputePipeline&)                    = delete;
            auto operator=(const ComputePipeline&) -> ComputePipeline& = delete;

            ComputePipeline(ComputePipeline&&) noexcept;
            auto operator=(ComputePipeline&&) noexcept -> ComputePipeline&;

            STATE(ComputePipelineShaderState, shaderState, shader_state)
            STATE(ComputePipelineLayout, layout, layout)

            auto bake() -> void override;

            auto setState(const ComputePipelineState& state) noexcept -> void;
            [[nodiscard]] auto state() noexcept -> ComputePipelineState&;
            [[nodiscard]] auto state() const noexcept -> const ComputePipelineState&;

          protected:
            auto bind(CommandBuffer& commandbuffer) const noexcept -> void override;

          private:
            ComputePipelineState m_state = {};
        };

        DECLARE_PTR_AND_REF(ComputePipeline);
    } // namespace stormkit::gpu

    HASH_FUNC(stormkit::gpu::ComputePipelineShaderState)
    HASH_FUNC(stormkit::gpu::ComputePipelineLayout)
    HASH_FUNC(stormkit::gpu::ComputePipelineState)

#ifndef STORMKIT_NO_MODULES
}
#endif

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::gpu {
    /////////////////////////////////////
    /////////////////////////////////////
    inline auto ComputePipeline::setState(const ComputePipelineState& state) noexcept -> void {
        core::expects(m_is_baked == false);

        m_state = state;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto ComputePipeline::state() noexcept -> ComputePipelineState& {
        core::expects(m_is_baked == false);

        return m_state;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto ComputePipeline::state() const noexcept -> const ComputePipelineState& {
        return m_state;
    }
} // namespace stormkit::gpu
