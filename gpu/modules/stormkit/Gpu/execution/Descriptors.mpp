// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

#ifndef STORMKIT_NO_MODULES
export module stormkit.Gpu:Execution:Descriptors;

import std;

import stormkit.Core;

import stormkit.Gpu:Core;
import stormkit.Gpu:Resource;

export {
#else
    #include <stormkit/std.hpp>

    #include <stormkit/Core.hpp>

    #include <stormkit/gpu/Core.hpp>
    #include <stormkit/gpu/Resource.hpp>
#endif

    namespace stormkit::gpu {
        struct BufferDescriptor {
            DescriptorType type = DescriptorType::Uniform_Buffer;
            core::UInt32 binding;
            const Buffer *buffer;
            core::UInt32 range;
            core::UInt32 offset;
        };

        struct ImageDescriptor {
            DescriptorType type = DescriptorType::Combined_Image_Sampler;
            core::UInt32 binding;
            ImageLayout layout;
            const ImageView *image_view;
            const Sampler *sampler;
        };

        using Descriptor = std::variant<BufferDescriptor, ImageDescriptor>;

        class DescriptorPool;

        class STORMKIT_API DescriptorSet: public DeviceObject {
            struct Tag {};

          public:
            static constexpr auto DEBUG_TYPE = DebugObjectType::Descriptor_Set;

            using Deleter = std::function<void(VkDescriptorSet)>;

            DescriptorSet(const DescriptorPool& pool,
                          std::vector<DescriptorType> type,
                          VkDescriptorSet sets,
                          Deleter deleter,
                          Tag);
            ~DescriptorSet();

            DescriptorSet(const DescriptorSet&)                    = delete;
            auto operator=(const DescriptorSet&) -> DescriptorSet& = delete;

            DescriptorSet(DescriptorSet&&) noexcept;
            auto operator=(DescriptorSet&&) noexcept -> DescriptorSet&;

            auto update(std::span<const Descriptor> descriptors) -> void;

            [[nodiscard]] auto types() const noexcept -> std::span<const DescriptorType>;

            [[nodiscard]] operator VkDescriptorSet() const noexcept;
            [[nodiscard]] auto vkHandle() const noexcept -> VkDescriptorSet;

          private:
            const DescriptorPool *m_pool = nullptr;

            std::vector<DescriptorType> m_types;

            VkDescriptorSet m_descriptor_set;

            Deleter m_deleter;
            friend class DescriptorPool;
        };

        DECLARE_PTR_AND_REF(DescriptorSet);

        struct DescriptorSetLayoutBinding {
            core::UInt32 binding;
            DescriptorType type;
            ShaderStageFlag stages;
            core::RangeExtent descriptor_count;
        };

        class STORMKIT_API DescriptorSetLayout: public DeviceObject {
          public:
            static constexpr auto DEBUG_TYPE = DebugObjectType::Descriptor_Set_Layout;

            explicit DescriptorSetLayout(const Device& device);
            ~DescriptorSetLayout();

            DescriptorSetLayout(const DescriptorSetLayout&)                    = delete;
            auto operator=(const DescriptorSetLayout&) -> DescriptorSetLayout& = delete;

            DescriptorSetLayout(DescriptorSetLayout&&) noexcept;
            auto operator=(DescriptorSetLayout&&) noexcept -> DescriptorSetLayout&;

            auto addBinding(const DescriptorSetLayoutBinding& binding) -> void;

            auto bake() -> void;

            [[nodiscard]] auto hash() const noexcept -> core::Hash64;
            [[nodiscard]] auto bindings() const noexcept
                -> std::span<const DescriptorSetLayoutBinding>;

            [[nodiscard]] operator VkDescriptorSetLayout() const noexcept;
            [[nodiscard]] auto vkHandle() const noexcept -> VkDescriptorSetLayout;

            [[nodiscard]] auto operator==(const DescriptorSetLayout& second) const noexcept -> bool;

          private:
            auto updateHash() noexcept -> void;

            std::vector<DescriptorSetLayoutBinding> m_bindings = {};

            core::Hash64 m_hash = 0;

            VkDescriptorSetLayout m_descriptor_set_layout = VK_NULL_HANDLE;
        };

        DECLARE_PTR_AND_REF(DescriptorSetLayout);

        class STORMKIT_API DescriptorPool: public DeviceObject {
          public:
            static constexpr auto DEBUG_TYPE = DebugObjectType::Descriptor_Pool;

            struct Size {
                DescriptorType type;
                core::UInt32 descriptor_count;
            };

            DescriptorPool(const Device& device,
                           std::span<const Size> sizes,
                           core::UInt32 max_sets);
            ~DescriptorPool();

            DescriptorPool(const DescriptorPool&)                    = delete;
            auto operator=(const DescriptorPool&) -> DescriptorPool& = delete;

            DescriptorPool(DescriptorPool&&) noexcept;
            auto operator=(DescriptorPool&&) noexcept -> DescriptorPool&;

            [[nodiscard]] auto createDescriptorSet(const DescriptorSetLayout& layout) const
                -> DescriptorSet;
            [[nodiscard]] auto allocateDescriptorSet(const DescriptorSetLayout& layout) const
                -> std::unique_ptr<DescriptorSet>;
            [[nodiscard]] auto
                allocateRefCountedDescriptorSet(const DescriptorSetLayout& layout) const
                -> std::shared_ptr<DescriptorSet>;

            [[nodiscard]] auto createDescriptorSets(core::RangeExtent count,
                                                    const DescriptorSetLayout& layout) const
                -> std::vector<DescriptorSet>;
            [[nodiscard]] auto allocateDescriptorSets(core::RangeExtent count,
                                                      const DescriptorSetLayout& layout) const
                -> std::vector<std::unique_ptr<DescriptorSet>>;
            [[nodiscard]] auto
                allocateRefCountedDescriptorSets(core::RangeExtent count,
                                                 const DescriptorSetLayout& layout) const
                -> std::vector<std::shared_ptr<DescriptorSet>>;

            [[nodiscard]] operator VkDescriptorPool() const noexcept;
            [[nodiscard]] auto vkHandle() const noexcept -> VkDescriptorPool;

          private:
            auto createVkDescriptorSets(core::RangeExtent count,
                                        const DescriptorSetLayout& layout) const
                -> std::pair<std::vector<VkDescriptorSet>, std::vector<DescriptorType>>;
            auto deleteDescriptorSet(VkDescriptorSet set) const -> void;

            VkDescriptorPool m_descriptor_pool = VK_NULL_HANDLE;
        };

        DECLARE_PTR_AND_REF(DescriptorPool);
    } // namespace stormkit::gpu

    HASH_FUNC(stormkit::gpu::DescriptorSetLayout)
    HASH_FUNC(stormkit::gpu::DescriptorSetLayoutBinding)
    HASH_FUNC(stormkit::gpu::BufferDescriptor)
    HASH_FUNC(stormkit::gpu::ImageDescriptor)
    HASH_FUNC(stormkit::gpu::Descriptor)

#ifndef STORMKIT_NO_MODULES
}
#endif

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::gpu {
    /////////////////////////////////////
    /////////////////////////////////////
    inline auto DescriptorSet::types() const noexcept -> std::span<const DescriptorType> {
        return m_types;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline DescriptorSet::operator VkDescriptorSet() const noexcept {
        return vkHandle();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto DescriptorSet::vkHandle() const noexcept -> VkDescriptorSet {
        core::expects(m_descriptor_set);

        return m_descriptor_set;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto DescriptorSetLayout::addBinding(const DescriptorSetLayoutBinding& binding) -> void {
        m_bindings.emplace_back(binding);

        updateHash();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto DescriptorSetLayout::hash() const noexcept -> core::Hash64 {
        return m_hash;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto DescriptorSetLayout::bindings() const noexcept
        -> std::span<const DescriptorSetLayoutBinding> {
        return m_bindings;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline DescriptorSetLayout::operator VkDescriptorSetLayout() const noexcept {
        return vkHandle();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto DescriptorSetLayout::vkHandle() const noexcept -> VkDescriptorSetLayout {
        core::expects(m_descriptor_set_layout);

        return m_descriptor_set_layout;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto DescriptorSetLayout::operator==(const DescriptorSetLayout& second) const noexcept
        -> bool {
        return m_hash == second.hash();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto DescriptorPool::createDescriptorSet(const DescriptorSetLayout& layout) const
        -> DescriptorSet {
        auto descriptor = std::move(createDescriptorSets(1u, layout)[0]);

        return descriptor;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto DescriptorPool::allocateDescriptorSet(const DescriptorSetLayout& layout) const
        -> std::unique_ptr<DescriptorSet> {
        auto descriptor = std::move(allocateDescriptorSets(1u, layout)[0]);

        return descriptor;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto
        DescriptorPool::allocateRefCountedDescriptorSet(const DescriptorSetLayout& layout) const
        -> std::shared_ptr<DescriptorSet> {
        auto descriptor = std::move(allocateRefCountedDescriptorSets(1u, layout)[0]);

        return descriptor;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline DescriptorPool::operator VkDescriptorPool() const noexcept {
        return vkHandle();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto DescriptorPool::vkHandle() const noexcept -> VkDescriptorPool {
        core::expects(m_descriptor_pool);

        return m_descriptor_pool;
    }
} // namespace stormkit::gpu
