// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

#ifndef STORMKIT_NO_MODULES
export module stormkit.Gpu:Execution:RenderPass;

import std;

import stormkit.Core;

import stormkit.Gpu:Core;
import stormkit.Gpu:Resource;

export {
#else
    #include <stormkit/std.hpp>

    #include <stormkit/Core.hpp>

    #include <stormkit/gpu/Core.hpp>
    #include <stormkit/gpu/Resource.hpp>
#endif

    namespace stormkit::gpu {
        class RenderPass;

        class STORMKIT_API FrameBuffer: public DeviceObject {
          public:
            static constexpr auto DEBUG_TYPE = DebugObjectType::FrameBuffer;

            FrameBuffer(const RenderPass& render_pass,
                        const core::math::ExtentU& size,
                        std::vector<ImageViewConstRef> attachments);
            ~FrameBuffer();

            FrameBuffer(const FrameBuffer&)                    = delete;
            auto operator=(const FrameBuffer&) -> FrameBuffer& = delete;

            FrameBuffer(FrameBuffer&&) noexcept;
            auto operator=(FrameBuffer&&) noexcept -> FrameBuffer&;

            [[nodiscard]] auto extent() const noexcept -> const core::math::ExtentU&;
            [[nodiscard]] auto attachments() const noexcept -> std::span<const ImageViewConstRef>;

            [[nodiscard]] operator VkFramebuffer() const noexcept;
            [[nodiscard]] auto vkHandle() const noexcept -> VkFramebuffer;

          private:
            const RenderPass *m_render_pass = nullptr;

            core::math::ExtentU m_extent = { 0, 0 };
            std::vector<ImageViewConstRef> m_attachments;

            VkFramebuffer m_framebuffer = VK_NULL_HANDLE;
        };

        DECLARE_PTR_AND_REF(FrameBuffer);

        struct AttachmentDescription {
            PixelFormat format;
            SampleCountFlag samples = SampleCountFlag::C1;

            AttachmentLoadOperation load_op   = AttachmentLoadOperation::Clear;
            AttachmentStoreOperation store_op = AttachmentStoreOperation::Store;

            AttachmentLoadOperation stencil_load_op   = AttachmentLoadOperation::Dont_Care;
            AttachmentStoreOperation stencil_store_op = AttachmentStoreOperation::Dont_Care;

            ImageLayout source_layout      = ImageLayout::Undefined;
            ImageLayout destination_layout = ImageLayout::Present_Src;

            bool resolve = false;
        };

        using AttachmentDescriptions = std::vector<AttachmentDescription>;

        struct Subpass {
            struct Ref {
                core::UInt32 attachment_id;

                ImageLayout layout = ImageLayout::Color_Attachment_Optimal;
            };

            PipelineBindPoint bind_point;
            std::vector<Ref> attachment_refs;
        };

        using Subpasses = std::vector<Subpass>;

        struct RenderPassDescription {
            AttachmentDescriptions attachments;
            Subpasses subpasses;

            auto isCompatible(const RenderPassDescription& description) const noexcept -> bool;
        };

        class Device;

        class STORMKIT_API RenderPass: public DeviceObject {
          public:
            static constexpr auto DEBUG_TYPE = DebugObjectType::Render_Pass;

            // RenderPass(const Device &device, vk::RenderPass render_pass);
            RenderPass(const Device& device, const RenderPassDescription& description);
            ~RenderPass();

            RenderPass(const RenderPass&)                    = delete;
            auto operator=(const RenderPass&) -> RenderPass& = delete;

            RenderPass(RenderPass&&) noexcept;
            auto operator=(RenderPass&&) noexcept -> RenderPass&;

            [[nodiscard]] auto createFrameBuffer(const core::math::ExtentU& extent,
                                                 std::vector<ImageViewConstRef> attachments) const
                -> FrameBuffer;
            [[nodiscard]] auto allocateFrameBuffer(const core::math::ExtentU& extent,
                                                   std::vector<ImageViewConstRef> attachments) const
                -> std::unique_ptr<FrameBuffer>;
            [[nodiscard]] auto
                allocateRefCountedFrameBuffer(const core::math::ExtentU& extent,
                                              std::vector<ImageViewConstRef> attachments) const
                -> std::shared_ptr<FrameBuffer>;

            [[nodiscard]] auto isCompatible(const RenderPass& render_pass) const noexcept -> bool;

            [[nodiscard]] auto description() const noexcept -> const RenderPassDescription&;

            [[nodiscard]] operator VkRenderPass() const noexcept;
            [[nodiscard]] auto vkHandle() const noexcept -> VkRenderPass;

          private:
            auto bake() noexcept -> void;

            RenderPassDescription m_description = {};

            VkRenderPass m_render_pass = VK_NULL_HANDLE;
        };

        DECLARE_PTR_AND_REF(RenderPass);
    } // namespace stormkit::gpu

    HASH_FUNC(stormkit::gpu::AttachmentDescription)
    HASH_FUNC(stormkit::gpu::Subpass::Ref)
    HASH_FUNC(stormkit::gpu::Subpass)
    HASH_FUNC(stormkit::gpu::RenderPassDescription)

#ifndef STORMKIT_NO_MODULES
}
#endif

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::gpu {
    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameBuffer::extent() const noexcept -> const core::math::ExtentU& {
        return m_extent;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameBuffer::attachments() const noexcept -> std::span<const ImageViewConstRef> {
        return m_attachments;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline FrameBuffer::operator VkFramebuffer() const noexcept {
        return vkHandle();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto FrameBuffer::vkHandle() const noexcept -> VkFramebuffer {
        core::expects(m_framebuffer);

        return m_framebuffer;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto RenderPass::description() const noexcept -> const RenderPassDescription& {
        return m_description;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline RenderPass::operator VkRenderPass() const noexcept {
        return vkHandle();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto RenderPass::vkHandle() const noexcept -> VkRenderPass {
        core::expects(m_render_pass);

        return m_render_pass;
    }
} // namespace stormkit::gpu
