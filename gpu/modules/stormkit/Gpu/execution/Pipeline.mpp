// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

#ifndef STORMKIT_NO_MODULES
export module stormkit.Gpu:Execution:Pipeline;

import std;

import stormkit.Core;

import stormkit.Gpu:Core;

export {
#else
    #include <stormkit/std.hpp>

    #include <stormkit/Core.hpp>

    #include <stormkit/gpu/Core.hpp>
#endif

    namespace stormkit::gpu {
        class Device;
        class CommandBuffer;

        class STORMKIT_API PipelineCache: public DeviceObject {
          public:
            static constexpr auto DEBUG_TYPE = DebugObjectType::Pipeline_Cache;

            explicit PipelineCache(const Device& device,
                                   std::filesystem::path cache_path = "./pipeline_cache.bin");
            ~PipelineCache();

            PipelineCache(const PipelineCache&)                    = delete;
            auto operator=(const PipelineCache&) -> PipelineCache& = delete;

            PipelineCache(PipelineCache&&) noexcept;
            auto operator=(PipelineCache&&) noexcept -> PipelineCache&;

            [[nodiscard]] operator VkPipelineCache() const noexcept;
            [[nodiscard]] auto vkHandle() const noexcept -> VkPipelineCache;

          private:
            auto createNewPipelineCache() -> void;
            auto readPipelineCache() -> void;
            auto saveCache() -> void;

            static constexpr auto MAGIC   = core::UInt32 { 0xDEADBEEF };
            static constexpr auto VERSION = core::UInt32 { 1u };

            struct SerializedCache {
                struct {
                    core::UInt32 magic;
                    core::RangeExtent data_size;
                    core::UInt64 data_hash;
                } guard;

                struct {
                    core::UInt32 version;
                    core::UInt64 vendor_id;
                    core::UInt64 device_id;
                } infos;

                struct {
                    std::array<core::UInt8, VK_UUID_SIZE> value;
                } uuid;
            } m_serialized;

            std::filesystem::path m_path = {};

            VkPipelineCache m_pipeline_cache = VK_NULL_HANDLE;
        };

        DECLARE_PTR_AND_REF(PipelineCache);

        class STORMKIT_API Pipeline: public DeviceObject {
          public:
            static constexpr auto DEBUG_TYPE = DebugObjectType::Pipeline;

            Pipeline(const Device& device, const PipelineCache *cache = nullptr) noexcept;
            virtual ~Pipeline();

            Pipeline(const Pipeline&)                    = delete;
            auto operator=(const Pipeline&) -> Pipeline& = delete;

            Pipeline(Pipeline&&) noexcept;
            auto operator=(Pipeline&&) noexcept -> Pipeline&;

            [[nodiscard]] auto baked() const noexcept -> bool;
            virtual auto bake() -> void = 0;

            [[nodiscard]] operator VkPipeline() const noexcept;
            [[nodiscard]] VkPipeline vkHandle() const noexcept;
            [[nodiscard]] VkPipelineLayout vkLayout() const noexcept;

          protected:
            virtual auto bind(CommandBuffer& commandbuffer) const noexcept -> void = 0;
            friend class CommandBuffer;

            const PipelineCache *m_pipeline_cache = nullptr;

            bool m_is_baked = false;

            VkPipeline m_pipeline              = VK_NULL_HANDLE;
            VkPipelineLayout m_pipeline_layout = VK_NULL_HANDLE;

          private:
            Pipeline() = delete;
        };

        DECLARE_PTR_AND_REF(Pipeline);
    } // namespace stormkit::gpu

#ifndef STORMKIT_NO_MODULES
}
#endif

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::gpu {
    /////////////////////////////////////
    /////////////////////////////////////
    inline PipelineCache::operator VkPipelineCache() const noexcept {
        return vkHandle();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto PipelineCache::vkHandle() const noexcept -> VkPipelineCache {
        core::expects(m_pipeline_cache);

        return m_pipeline_cache;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Pipeline::baked() const noexcept -> bool {
        return m_is_baked;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline Pipeline::operator VkPipeline() const noexcept {
        return vkHandle();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Pipeline::vkHandle() const noexcept -> VkPipeline {
        core::expects(m_pipeline);

        return m_pipeline;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Pipeline::vkLayout() const noexcept -> VkPipelineLayout {
        core::expects(m_pipeline_layout);

        return m_pipeline_layout;
    }
} // namespace stormkit::gpu
