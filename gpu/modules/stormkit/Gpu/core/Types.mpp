// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

export module stormkit.Gpu:Core.Types;

import std;

import stormkit.Core;

import :Core.Vulkan;

export {
    namespace stormkit::gpu {
        inline constexpr auto QUEUE_FAMILY_IGNORED = core::UInt32 { VK_QUEUE_FAMILY_IGNORED };

        enum class PhysicalDeviceType : core::UInt8 {
            Discrete_GPU   = VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
            Virtual_GPU    = VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
            Integrated_GPU = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
            CPU            = VK_PHYSICAL_DEVICE_TYPE_CPU,
            Other          = VK_PHYSICAL_DEVICE_TYPE_OTHER,
        };

        enum class QueueFlag : core::UInt8 {
            None           = 0,
            Graphics       = VK_QUEUE_GRAPHICS_BIT,
            Compute        = VK_QUEUE_COMPUTE_BIT,
            Transfert      = VK_QUEUE_TRANSFER_BIT,
            Sparse_Binding = VK_QUEUE_SPARSE_BINDING_BIT,
        };

        enum class ShaderStageFlag : core::UInt8 {
            None     = 0,
            Vertex   = VK_SHADER_STAGE_VERTEX_BIT,
            Fragment = VK_SHADER_STAGE_FRAGMENT_BIT,
            Geometry = VK_SHADER_STAGE_GEOMETRY_BIT,
            Compute  = VK_SHADER_STAGE_COMPUTE_BIT,
        };

        enum class PrimitiveTopology : core::UInt8 {
            Point_List     = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
            Line_List      = VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
            Line_Strip     = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
            Triangle_List  = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
            Triangle_Strip = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
            Triangle_Fan   = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
        };

        enum class PolygonMode : core::UInt8 {
            Fill  = VK_POLYGON_MODE_FILL,
            Line  = VK_POLYGON_MODE_LINE,
            Point = VK_POLYGON_MODE_POINT,
        };

        enum class CullModeFlag : core::UInt8 {
            None       = VK_CULL_MODE_NONE,
            Front      = VK_CULL_MODE_FRONT_BIT,
            Back       = VK_CULL_MODE_BACK_BIT,
            Front_Back = Front | Back,
        };

        enum class FrontFace : core::UInt8 {
            Clockwise         = VK_FRONT_FACE_CLOCKWISE,
            Counter_Clockwise = VK_FRONT_FACE_COUNTER_CLOCKWISE,
        };

        enum class SampleCountFlag : core::UInt8 {
            None = 0,
            C1   = VK_SAMPLE_COUNT_1_BIT,
            C2   = VK_SAMPLE_COUNT_2_BIT,
            C4   = VK_SAMPLE_COUNT_4_BIT,
            C8   = VK_SAMPLE_COUNT_8_BIT,
            C16  = VK_SAMPLE_COUNT_16_BIT,
            C32  = VK_SAMPLE_COUNT_32_BIT,
            C64  = VK_SAMPLE_COUNT_64_BIT,
        };

        enum class ColorComponentFlag : core::UInt8 {
            None = 0,
            R    = VK_COLOR_COMPONENT_R_BIT,
            G    = VK_COLOR_COMPONENT_G_BIT,
            B    = VK_COLOR_COMPONENT_B_BIT,
            A    = VK_COLOR_COMPONENT_A_BIT,
            RG   = R | G,
            RGB  = RG | B,
            RGBA = RGB | A,
        };

        enum class BlendFactor : core::UInt8 {
            One                      = VK_BLEND_FACTOR_ONE,
            Zero                     = VK_BLEND_FACTOR_ZERO,
            Src_Color                = VK_BLEND_FACTOR_SRC_COLOR,
            One_Minus_Src_Color      = VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
            Dst_Color                = VK_BLEND_FACTOR_DST_COLOR,
            One_Minus_Dst_Color      = VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
            Src_Alpha                = VK_BLEND_FACTOR_SRC_ALPHA,
            One_Minus_Src_Alpha      = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
            Dst_Alpha                = VK_BLEND_FACTOR_DST_ALPHA,
            One_Minus_Dst_Alpha      = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
            Constant_Color           = VK_BLEND_FACTOR_CONSTANT_COLOR,
            One_Minus_Constant_Color = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
            Constant_Alpha           = VK_BLEND_FACTOR_CONSTANT_ALPHA,
            One_Minus_Constant_Alpha = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
            Src_Alpha_Saturate       = VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
            Src1_Color               = VK_BLEND_FACTOR_SRC1_COLOR,
            One_Minus_Src1_Color     = VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
            Src1_Alpha               = VK_BLEND_FACTOR_SRC1_ALPHA,
            One_Minus_Src1_Alpha     = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
        };

        enum class BlendOperation : core::UInt8 {
            Add               = VK_BLEND_OP_ADD,
            Substract         = VK_BLEND_OP_SUBTRACT,
            Reverse_Substract = VK_BLEND_OP_REVERSE_SUBTRACT,
            Min               = VK_BLEND_OP_MIN,
            Max               = VK_BLEND_OP_MAX,
        };

        enum class LogicOperation : core::UInt8 {
            Clear         = VK_LOGIC_OP_CLEAR,
            And           = VK_LOGIC_OP_AND,
            And_Reverse   = VK_LOGIC_OP_AND_REVERSE,
            Copy          = VK_LOGIC_OP_COPY,
            And_Inverted  = VK_LOGIC_OP_AND_INVERTED,
            No_Operation  = VK_LOGIC_OP_NO_OP,
            Xor           = VK_LOGIC_OP_XOR,
            Or            = VK_LOGIC_OP_OR,
            Nor           = VK_LOGIC_OP_NOR,
            Equivalent    = VK_LOGIC_OP_EQUIVALENT,
            Invert        = VK_LOGIC_OP_INVERT,
            Or_Reverse    = VK_LOGIC_OP_OR_REVERSE,
            Copy_Inverted = VK_LOGIC_OP_COPY_INVERTED,
            Or_Inverted   = VK_LOGIC_OP_OR_INVERTED,
            Nand          = VK_LOGIC_OP_NAND,
            Set           = VK_LOGIC_OP_SET,
        };

        enum class PixelFormat : core::UInt8 {
            R8_SNorm    = VK_FORMAT_R8_SNORM,
            RG8_SNorm   = VK_FORMAT_R8G8_SNORM,
            RGB8_SNorm  = VK_FORMAT_R8G8B8_SNORM,
            RGBA8_SNorm = VK_FORMAT_R8G8B8A8_SNORM,

            R8_UNorm    = VK_FORMAT_R8_UNORM,
            RG8_UNorm   = VK_FORMAT_R8G8_UNORM,
            RGB8_UNorm  = VK_FORMAT_R8G8B8_UNORM,
            RGBA8_UNorm = VK_FORMAT_R8G8B8A8_UNORM,

            R16_SNorm    = VK_FORMAT_R16_SNORM,
            RG16_SNorm   = VK_FORMAT_R16G16_SNORM,
            RGB16_SNorm  = VK_FORMAT_R16G16B16_SNORM,
            RGBA16_SNorm = VK_FORMAT_R16G16B16A16_SNORM,

            R16_UNorm    = VK_FORMAT_R16_UNORM,
            RG16_UNorm   = VK_FORMAT_R16G16_UNORM,
            RGB16_UNorm  = VK_FORMAT_R16G16B16_UNORM,
            RGBA16_UNorm = VK_FORMAT_R16G16B16A16_UNORM,

            A2_RGB10_UNorm = VK_FORMAT_A2R10G10B10_UNORM_PACK32,

            RGBA4_UNorm_Pack16 = VK_FORMAT_R4G4B4A4_UNORM_PACK16,

            A1_RGB5_UNorm_Pack16 = VK_FORMAT_A1R5G5B5_UNORM_PACK16,

            R5_G6_B5_UNorm_Pack16 = VK_FORMAT_R5G6B5_UNORM_PACK16,

            BGR8_UNorm  = VK_FORMAT_B8G8R8_UNORM,
            BGRA8_UNorm = VK_FORMAT_B8G8R8A8_UNORM,

            R8I    = VK_FORMAT_R8_SINT,
            RG8I   = VK_FORMAT_R8G8_SINT,
            RGB8I  = VK_FORMAT_R8G8B8_SINT,
            RGBA8I = VK_FORMAT_R8G8B8A8_SINT,

            R8U    = VK_FORMAT_R8_UINT,
            RG8U   = VK_FORMAT_R8G8_UINT,
            RGB8U  = VK_FORMAT_R8G8B8_UINT,
            RGBA8U = VK_FORMAT_R8G8B8A8_UINT,

            R16I    = VK_FORMAT_R16_SINT,
            RG16I   = VK_FORMAT_R16G16_SINT,
            RGB16I  = VK_FORMAT_R16G16B16_SINT,
            RGBA16I = VK_FORMAT_R16G16B16A16_SINT,

            R16U    = VK_FORMAT_R16_UINT,
            RG16U   = VK_FORMAT_R16G16_UINT,
            RGB16U  = VK_FORMAT_R16G16B16_UINT,
            RGBA16U = VK_FORMAT_R16G16B16A16_UINT,

            R32I    = VK_FORMAT_R32_SINT,
            RG32I   = VK_FORMAT_R32G32_SINT,
            RGB32I  = VK_FORMAT_R32G32B32_SINT,
            RGBA32I = VK_FORMAT_R32G32B32A32_SINT,

            R32U    = VK_FORMAT_R32_UINT,
            RG32U   = VK_FORMAT_R32G32_UINT,
            RGB32U  = VK_FORMAT_R32G32B32_UINT,
            RGBA32U = VK_FORMAT_R32G32B32A32_UINT,

            A2_RGB10U_Pack32 = VK_FORMAT_A2R10G10B10_UINT_PACK32,

            R16F    = VK_FORMAT_R16_SFLOAT,
            RG16F   = VK_FORMAT_R16G16_SFLOAT,
            RGB16F  = VK_FORMAT_R16G16B16_SFLOAT,
            RGBA16F = VK_FORMAT_R16G16B16A16_SFLOAT,

            R32F    = VK_FORMAT_R32_SFLOAT,
            RG32F   = VK_FORMAT_R32G32_SFLOAT,
            RGB32F  = VK_FORMAT_R32G32B32_SFLOAT,
            RGBA32F = VK_FORMAT_R32G32B32A32_SFLOAT,

            BG11_R10F_Pack32 = VK_FORMAT_B10G11R11_UFLOAT_PACK32,

            sRGB8  = VK_FORMAT_R8G8B8_SRGB,
            sRGBA8 = VK_FORMAT_R8G8B8A8_SRGB,
            sBGR8  = VK_FORMAT_B8G8R8_SRGB,
            sBGRA8 = VK_FORMAT_B8G8R8A8_SRGB,

            Depth16  = VK_FORMAT_D16_UNORM,
            Depth24  = VK_FORMAT_X8_D24_UNORM_PACK32,
            Depth32F = VK_FORMAT_D32_SFLOAT,

            Depth16_Stencil8  = VK_FORMAT_D16_UNORM_S8_UINT,
            Depth24_Stencil8  = VK_FORMAT_D24_UNORM_S8_UINT,
            Depth32F_Stencil8 = VK_FORMAT_D32_SFLOAT_S8_UINT,

            Undefined = VK_FORMAT_UNDEFINED,
        };

        enum class AttachmentLoadOperation : core::UInt8 {
            Clear     = VK_ATTACHMENT_LOAD_OP_CLEAR,
            Load      = VK_ATTACHMENT_LOAD_OP_LOAD,
            Dont_Care = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
        };

        enum class AttachmentStoreOperation : core::UInt8 {
            Store     = VK_ATTACHMENT_STORE_OP_STORE,
            Dont_Care = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        };

        enum class PipelineBindPoint : core::UInt8 {
            Graphics = VK_PIPELINE_BIND_POINT_GRAPHICS,
            Compute  = VK_PIPELINE_BIND_POINT_COMPUTE,
        };

        enum class ImageLayout : core::UInt32 {
            General                          = VK_IMAGE_LAYOUT_GENERAL,
            Color_Attachment_Optimal         = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
            Depth_Stencil_Attachment_Optimal = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
            Depth_Stencil_Read_Only_Optimal  = VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
            Shader_Read_Only_Optimal         = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
            Transfer_Src_Optimal             = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
            Transfer_Dst_Optimal             = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
            Preinitialized                   = VK_IMAGE_LAYOUT_PREINITIALIZED,
            Depth_Read_Only_Stencil_Attachment_Optimal =
                VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
            Depth_Attachment_Stencil_Read_Only_Optimal =
                VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
            Present_Src    = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
            Shared_Present = VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR,
            Undefined      = VK_IMAGE_LAYOUT_UNDEFINED,
        };

        enum class ImageAspectMaskFlag : core::UInt8 {
            None    = 0,
            Color   = VK_IMAGE_ASPECT_COLOR_BIT,
            Depth   = VK_IMAGE_ASPECT_DEPTH_BIT,
            Stencil = VK_IMAGE_ASPECT_STENCIL_BIT,
        };

        enum class VertexInputRate : core::UInt8 {
            Vertex   = VK_VERTEX_INPUT_RATE_VERTEX,
            Instance = VK_VERTEX_INPUT_RATE_INSTANCE,
        };

        enum class ImageCreateFlag : core::UInt16 {
            None                        = 0,
            Sparse_Binding              = VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
            Sparse_Residency            = VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
            Sparse_Aliased              = VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
            Mutable_Format              = VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
            Cube_Compatible             = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
            Alias                       = VK_IMAGE_CREATE_ALIAS_BIT,
            Split_Instance_Bind_Regions = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
            Array_2D_Compatible         = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
            Block_Texel_View_Compatible = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
            Extended_Usage              = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
            Protected                   = VK_IMAGE_CREATE_PROTECTED_BIT,
            Disjoint                    = VK_IMAGE_CREATE_DISJOINT_BIT,
        };

        enum class Format : core::UInt8 {
            Byte  = VK_FORMAT_R8_SINT,
            Byte2 = VK_FORMAT_R8G8_SINT,
            Byte3 = VK_FORMAT_R8G8B8_SINT,
            Byte4 = VK_FORMAT_R8G8B8A8_SINT,

            Byte_Norm  = VK_FORMAT_R8_SNORM,
            Byte2_Norm = VK_FORMAT_R8G8_SNORM,
            Byte3_Norm = VK_FORMAT_R8G8B8_SNORM,
            Byte4_Norm = VK_FORMAT_R8G8B8A8_SNORM,

            Byte_Scaled  = VK_FORMAT_R8_SSCALED,
            Byte2_Scaled = VK_FORMAT_R8G8_SSCALED,
            Byte3_Scaled = VK_FORMAT_R8G8B8_SSCALED,
            Byte4_Scaled = VK_FORMAT_R8G8B8A8_SSCALED,

            UByte  = VK_FORMAT_R8_UINT,
            UByte2 = VK_FORMAT_R8G8_UINT,
            UByte3 = VK_FORMAT_R8G8B8_UINT,
            UByte4 = VK_FORMAT_R8G8B8A8_UINT,

            UByte_Norm  = VK_FORMAT_R8_UNORM,
            UByte2_Norm = VK_FORMAT_R8G8_UNORM,
            UByte3_Norm = VK_FORMAT_R8G8B8_UNORM,
            UByte4_Norm = VK_FORMAT_R8G8B8A8_UNORM,

            UByte_Ucaled  = VK_FORMAT_R8_USCALED,
            UByte2_Ucaled = VK_FORMAT_R8G8_USCALED,
            UByte3_Ucaled = VK_FORMAT_R8G8B8_USCALED,
            UByte4_Ucaled = VK_FORMAT_R8G8B8A8_USCALED,

            Short  = VK_FORMAT_R16_SINT,
            Short2 = VK_FORMAT_R16G16_SINT,
            Short3 = VK_FORMAT_R16G16B16_SINT,
            Short4 = VK_FORMAT_R16G16B16A16_SINT,

            Short_Norm  = VK_FORMAT_R16_SFLOAT,
            Short2_Norm = VK_FORMAT_R16G16_SFLOAT,
            Short3_Norm = VK_FORMAT_R16G16B16_SFLOAT,
            Short4_Norm = VK_FORMAT_R16G16B16A16_SFLOAT,

            Short_Scaled  = VK_FORMAT_R16_SSCALED,
            Short2_Scaled = VK_FORMAT_R16G16_SSCALED,
            Short3_Scaled = VK_FORMAT_R16G16B16_SSCALED,
            Short4_Scaled = VK_FORMAT_R16G16B16A16_SSCALED,

            UShort  = VK_FORMAT_R16_UINT,
            UShort2 = VK_FORMAT_R16G16_UINT,
            UShort3 = VK_FORMAT_R16G16B16_UINT,
            UShort4 = VK_FORMAT_R16G16B16A16_UINT,

            UShort_Norm  = VK_FORMAT_R16_UNORM,
            UShort2_Norm = VK_FORMAT_R16G16_UNORM,
            UShort3_Norm = VK_FORMAT_R16G16B16_UNORM,
            UShort4_Norm = VK_FORMAT_R16G16B16A16_UNORM,

            UShort_Ucaled  = VK_FORMAT_R16_USCALED,
            UShort2_Ucaled = VK_FORMAT_R16G16_USCALED,
            UShort3_Ucaled = VK_FORMAT_R16G16B16_USCALED,
            UShort4_Ucaled = VK_FORMAT_R16G16B16A16_USCALED,

            Int  = VK_FORMAT_R32_SINT,
            Int2 = VK_FORMAT_R32G32_SINT,
            Int3 = VK_FORMAT_R32G32B32_SINT,
            Int4 = VK_FORMAT_R32G32B32A32_SINT,

            UInt  = VK_FORMAT_R32_UINT,
            UInt2 = VK_FORMAT_R32G32_UINT,
            UInt3 = VK_FORMAT_R32G32B32_UINT,
            UInt4 = VK_FORMAT_R32G32B32A32_UINT,

            Long  = VK_FORMAT_R64_SINT,
            Long2 = VK_FORMAT_R64G64_SINT,
            Long3 = VK_FORMAT_R64G64B64_SINT,
            Long4 = VK_FORMAT_R64G64B64A64_SINT,

            ULong  = VK_FORMAT_R64_UINT,
            ULong2 = VK_FORMAT_R64G64_UINT,
            ULong3 = VK_FORMAT_R64G64B64_UINT,
            ULong4 = VK_FORMAT_R64G64B64A64_UINT,

            Float  = VK_FORMAT_R32_SFLOAT,
            Float2 = VK_FORMAT_R32G32_SFLOAT,
            Float3 = VK_FORMAT_R32G32B32_SFLOAT,
            Float4 = VK_FORMAT_R32G32B32A32_SFLOAT,

            Double  = VK_FORMAT_R64_SFLOAT,
            Double2 = VK_FORMAT_R64G64_SFLOAT,
            Double3 = VK_FORMAT_R64G64B64_SFLOAT,
            Double4 = VK_FORMAT_R64G64B64A64_SFLOAT,

            Undefined = VK_FORMAT_UNDEFINED,
        };

        enum class BufferUsageFlag : core::UInt16 {
            Vertex        = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
            Index         = VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
            Transfert_Src = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
            Transfert_Dst = VK_BUFFER_USAGE_TRANSFER_DST_BIT,
            Uniform       = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
            Storage       = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
            Uniform_Texel = VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
            Storage_Texel = VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
            Indirect      = VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
        };

        enum class ImageUsageFlag : core::UInt16 {
            Transfert_Src            = VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
            Transfert_Dst            = VK_IMAGE_USAGE_TRANSFER_DST_BIT,
            Sampled                  = VK_IMAGE_USAGE_SAMPLED_BIT,
            Storage                  = VK_IMAGE_USAGE_STORAGE_BIT,
            Color_Attachment         = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
            Depth_Stencil_Attachment = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
            Transient_Attachment     = VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
            Input_Attachment         = VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
        };

        enum class MemoryPropertyFlag : core::UInt8 {
            Device_Local  = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
            Host_Visible  = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
            Host_Coherent = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
            Host_Cached   = VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
        };

        enum class CommandBufferLevel : core::UInt8 {
            Primary   = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
            Secondary = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
        };

        enum class DescriptorType : core::UInt8 {
            Sampler                = VK_DESCRIPTOR_TYPE_SAMPLER,
            Combined_Image_Sampler = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
            Sampled_Image          = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            Storage_Image          = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
            Uniform_Texel_Buffer   = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
            Storage_Texel_Buffer   = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
            Uniform_Buffer         = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            Storage_Buffer         = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
            Uniform_Buffer_Dynamic = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
            Storage_Buffer_Dynamic = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
            Input_Attachment       = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
        };

        enum class CompareOperation : core::UInt8 {
            Never            = VK_COMPARE_OP_NEVER,
            Less             = VK_COMPARE_OP_LESS,
            Equal            = VK_COMPARE_OP_EQUAL,
            Less_Or_Equal    = VK_COMPARE_OP_LESS_OR_EQUAL,
            Greater          = VK_COMPARE_OP_GREATER,
            Not_Equal        = VK_COMPARE_OP_NOT_EQUAL,
            Greater_Or_Equal = VK_COMPARE_OP_GREATER_OR_EQUAL,
            Always           = VK_COMPARE_OP_ALWAYS,
        };

        enum class Filter : core::UInt32 {
            Nearest   = VK_FILTER_NEAREST,
            Linear    = VK_FILTER_LINEAR,
            Cubic_Img = VK_FILTER_CUBIC_IMG,
        };

        enum class SamplerAddressMode : core::UInt8 {
            Repeat               = VK_SAMPLER_ADDRESS_MODE_REPEAT,
            Mirrored_Repeat      = VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
            Clamp_To_Edge        = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
            Clamp_To_Border      = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
            Mirror_Clamp_To_Edge = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
        };

        enum class BorderColor : core::UInt8 {
            Float_Transparent_Black = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
            Int_Transparent_Black   = VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
            Float_Opaque_Black      = VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
            Int_Opaque_Black        = VK_BORDER_COLOR_INT_OPAQUE_BLACK,
            Float_Opaque_White      = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
            Int_opaque_White        = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
        };

        enum class SamplerMipmapMode : core::UInt8 {
            Nearest = VK_SAMPLER_MIPMAP_MODE_NEAREST,
            Linear  = VK_SAMPLER_MIPMAP_MODE_LINEAR,
        };

        enum class Result : core::Int32 {
            Success                              = VK_SUCCESS,
            Not_Ready                            = VK_NOT_READY,
            Timeout                              = VK_TIMEOUT,
            Event_Set                            = VK_EVENT_SET,
            Event_Reset                          = VK_EVENT_RESET,
            Incomplete                           = VK_INCOMPLETE,
            Error_Out_Of_host_Memory             = VK_ERROR_OUT_OF_HOST_MEMORY,
            Error_Out_Of_Device_Memory           = VK_ERROR_OUT_OF_DEVICE_MEMORY,
            Error_Initialization_Failed          = VK_ERROR_INITIALIZATION_FAILED,
            Error_Device_Lost                    = VK_ERROR_DEVICE_LOST,
            Error_Memory_Map_Failed              = VK_ERROR_MEMORY_MAP_FAILED,
            Error_Layer_Not_Present              = VK_ERROR_LAYER_NOT_PRESENT,
            Error_Extension_Not_Present          = VK_ERROR_EXTENSION_NOT_PRESENT,
            Error_Feature_Not_Present            = VK_ERROR_FEATURE_NOT_PRESENT,
            Error_Incompatible_Driver            = VK_ERROR_INCOMPATIBLE_DRIVER,
            Error_Too_Many_Objects               = VK_ERROR_TOO_MANY_OBJECTS,
            Error_Format_Not_Supported           = VK_ERROR_FORMAT_NOT_SUPPORTED,
            Error_Fragmented_Pool                = VK_ERROR_FRAGMENTED_POOL,
            Error_Unknown                        = VK_ERROR_UNKNOWN,
            Error_Out_Of_Pool_Memory             = VK_ERROR_OUT_OF_POOL_MEMORY,
            Error_Invalid_External_Handle        = VK_ERROR_INVALID_EXTERNAL_HANDLE,
            Error_Fragmentation                  = VK_ERROR_FRAGMENTATION,
            Error_Invalid_Opaque_Capture_Address = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
            Error_Surface_Lost                   = VK_ERROR_SURFACE_LOST_KHR,
            Error_Native_Window_In_Use           = VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,
            Suboptimal                           = VK_SUBOPTIMAL_KHR,
            Error_Out_Of_Data                    = VK_ERROR_OUT_OF_DATE_KHR,
            Error_Incompatible_Display           = VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,
            Error_Validation_Failed              = VK_ERROR_VALIDATION_FAILED_EXT,
            Error_Not_Permitted                  = VK_ERROR_NOT_PERMITTED_EXT,
            Error_Fullscreen_Exclusive_Mode_Lost = VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,
            Thread_Idle                          = VK_THREAD_IDLE_KHR,
            Thread_Done                          = VK_THREAD_DONE_KHR,
            Operation_Deferred                   = VK_OPERATION_DEFERRED_KHR,
            Operation_Not_Deferred               = VK_OPERATION_NOT_DEFERRED_KHR,
            Pipeline_Compile_Required            = VK_PIPELINE_COMPILE_REQUIRED_EXT,
        };

        enum class ImageType : core::UInt8 {
            T1D = VK_IMAGE_TYPE_1D,
            T2D = VK_IMAGE_TYPE_2D,
            T3D = VK_IMAGE_TYPE_3D,
        };

        enum class ImageViewType : core::UInt8 {
            T1D        = VK_IMAGE_VIEW_TYPE_1D,
            T2D        = VK_IMAGE_VIEW_TYPE_2D,
            T3D        = VK_IMAGE_VIEW_TYPE_3D,
            Cube       = VK_IMAGE_VIEW_TYPE_CUBE,
            T1D_Array  = VK_IMAGE_VIEW_TYPE_1D_ARRAY,
            T2D_Array  = VK_IMAGE_VIEW_TYPE_2D_ARRAY,
            Cube_Array = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
        };

        enum class DebugObjectType : core::UInt32 {
            Unknown               = VK_OBJECT_TYPE_UNKNOWN,
            Instance              = VK_OBJECT_TYPE_INSTANCE,
            Physical_Device       = VK_OBJECT_TYPE_PHYSICAL_DEVICE,
            Device                = VK_OBJECT_TYPE_DEVICE,
            Queue                 = VK_OBJECT_TYPE_QUEUE,
            Semaphore             = VK_OBJECT_TYPE_SEMAPHORE,
            Command_Buffer        = VK_OBJECT_TYPE_COMMAND_BUFFER,
            Fence                 = VK_OBJECT_TYPE_FENCE,
            Device_Memory         = VK_OBJECT_TYPE_DEVICE_MEMORY,
            Buffer                = VK_OBJECT_TYPE_BUFFER,
            Image                 = VK_OBJECT_TYPE_IMAGE,
            Event                 = VK_OBJECT_TYPE_EVENT,
            Query_Pool            = VK_OBJECT_TYPE_QUERY_POOL,
            Buffer_View           = VK_OBJECT_TYPE_BUFFER_VIEW,
            Image_View            = VK_OBJECT_TYPE_IMAGE_VIEW,
            Shader_Module         = VK_OBJECT_TYPE_SHADER_MODULE,
            Pipeline_Cache        = VK_OBJECT_TYPE_PIPELINE_CACHE,
            Pipeline_Layout       = VK_OBJECT_TYPE_PIPELINE_LAYOUT,
            Render_Pass           = VK_OBJECT_TYPE_RENDER_PASS,
            Pipeline              = VK_OBJECT_TYPE_PIPELINE,
            Descriptor_Set_Layout = VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
            Sampler               = VK_OBJECT_TYPE_SAMPLER,
            Descriptor_Pool       = VK_OBJECT_TYPE_DESCRIPTOR_POOL,
            Descriptor_Set        = VK_OBJECT_TYPE_DESCRIPTOR_SET,
            FrameBuffer           = VK_OBJECT_TYPE_FRAMEBUFFER,
            Command_Pool          = VK_OBJECT_TYPE_COMMAND_POOL,
            Surface               = VK_OBJECT_TYPE_SURFACE_KHR,
            Swapchain             = VK_OBJECT_TYPE_SWAPCHAIN_KHR,
            Debug_Report_Callback = VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT,
            Display_KHR           = VK_OBJECT_TYPE_DISPLAY_KHR,
        };

        enum class AccessFlag : core::UInt32 {
            None                           = VK_ACCESS_NONE_KHR,
            Indirect_Command_Read          = VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
            Vertex_Attribute_Read          = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
            Uniform_Read                   = VK_ACCESS_UNIFORM_READ_BIT,
            Input_Attachment_Read          = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
            Shader_Read                    = VK_ACCESS_SHADER_READ_BIT,
            Shader_Write                   = VK_ACCESS_SHADER_WRITE_BIT,
            Color_Attachment_Read          = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,
            Color_Attachment_Write         = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
            Depth_Stencil_Attachment_Read  = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
            Depth_Stencil_Attachment_Write = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
            Transfer_Read                  = VK_ACCESS_TRANSFER_READ_BIT,
            Transfer_Write                 = VK_ACCESS_TRANSFER_WRITE_BIT,
            Host_Read                      = VK_ACCESS_HOST_READ_BIT,
            Host_Write                     = VK_ACCESS_HOST_WRITE_BIT,
            Memory_Read                    = VK_ACCESS_MEMORY_READ_BIT,
            Memory_Write                   = VK_ACCESS_MEMORY_WRITE_BIT,
        };

        enum class PipelineStageFlag : core::UInt32 {
            None                           = VK_PIPELINE_STAGE_NONE_KHR,
            Top_Of_Pipe                    = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
            Draw_Indirect                  = VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
            Vertex_Input                   = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
            Vertex_Shader                  = VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
            Tessellation_Control_Shader    = VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
            Tessellation_Evaluation_Shader = VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
            Geometry_Shader                = VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
            Fragment_Shader                = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
            Early_Fragment_Tests           = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
            Late_Fragment_Tests            = VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
            Color_Attachment_Output        = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
            Compute_Shader                 = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
            Transfer                       = VK_PIPELINE_STAGE_TRANSFER_BIT,
            Bottom_Of_Pipe                 = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
            Host                           = VK_PIPELINE_STAGE_HOST_BIT,
            All_Graphics                   = VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
            All_Commands                   = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
        };

        enum class DependencyFlag : core::UInt8 {
            None         = 0,
            By_Region    = VK_DEPENDENCY_BY_REGION_BIT,
            Device_Group = VK_DEPENDENCY_BY_REGION_BIT,
            View_Local   = VK_DEPENDENCY_VIEW_LOCAL_BIT,
        };

        enum class DynamicState : core::UInt8 {
            Viewport             = VK_DYNAMIC_STATE_VIEWPORT,
            Scissor              = VK_DYNAMIC_STATE_SCISSOR,
            Line_Width           = VK_DYNAMIC_STATE_LINE_WIDTH,
            Depth_Bias           = VK_DYNAMIC_STATE_DEPTH_BIAS,
            Blend_Constants      = VK_DYNAMIC_STATE_BLEND_CONSTANTS,
            Depth_Bounds         = VK_DYNAMIC_STATE_DEPTH_BOUNDS,
            Stencil_Compare_Mask = VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
            Stencil_Write_Mask   = VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
            Stencil_Reference    = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
        };

        enum class ImageTiling : core::UInt32 {
            Optimal = VK_IMAGE_TILING_OPTIMAL,
            Linear  = VK_IMAGE_TILING_LINEAR,
            DRM_Ext = VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,
        };

        enum class StencilFaceFlag : core::UInt8 {
            Front          = VK_STENCIL_FACE_FRONT_BIT,
            Back           = VK_STENCIL_FACE_BACK_BIT,
            Front_And_Back = Front | Back
        };

        enum class GeometryType : core::UInt8 {
            Triangles = VK_GEOMETRY_TYPE_TRIANGLES_KHR,
            AABBS     = VK_GEOMETRY_TYPE_AABBS_KHR,
            Instances = VK_GEOMETRY_TYPE_INSTANCES_KHR
        };

        enum class GeometryFlag : core::UInt8 {
            Opaque                          = VK_GEOMETRY_OPAQUE_BIT_KHR,
            No_Duplicate_Any_Hit_Invocation = VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR
        };

        struct MemoryBarrier {
            AccessFlag src;
            AccessFlag dst;
        };

        struct RenderCapabilities {
            struct {
                bool robust_buffer_access;
                bool full_draw_index_uint32;
                bool image_cube_array;
                bool independent_blend;
                bool geometry_shader;
                bool tessellation_shader;
                bool sampler_rate_shading;
                bool dual_src_blend;
                bool logic_op;
                bool multi_draw_indirect;
                bool draw_indirect_first_instance;
                bool depth_clamp;
                bool depth_bias_clamp;
                bool fill_Mode_non_solid;
                bool depth_bounds;
                bool wide_lines;
                bool large_points;
                bool alpha_to_one;
                bool multi_viewport;
                bool sampler_anisotropy;
                bool texture_compression_etc2;
                bool texture_compression_astc_ldr;
                bool texture_compression_bc;
                bool occlusion_query_precise;
                bool pipeline_statistics_query;
                bool vertex_pipeline_stores_and_atomics;
                bool fragment_stores_and_atomics;
                bool shader_tessellation_and_geometry_point_size;
                bool shader_image_gather_extended;
                bool shader_storage_image_extended_formats;
                bool shader_storage_image_multisample;
                bool shader_storage_image_read_without_format;
                bool shader_storage_image_write_without_format;
                bool shader_uniform_buffer_array_dynamic_indexing;
                bool shader_sampled_image_array_dynamic_indexing;
                bool shader_storage_buffer_array_dynamic_indexing;
                bool shader_storage_image_array_dynamic_indexing;
                bool shader_clip_distance;
                bool shader_cull_distance;
                bool shader_float_64;
                bool shader_int_64;
                bool shader_int_16;
                bool shader_resource_residency;
                bool shader_resource_min_lod;
                bool sparse_binding;
                bool sparse_residency_buffer;
                bool sparse_residency_image_2D;
                bool sparse_residency_image_3D;
                bool sparse_residency_2_samples;
                bool sparse_residency_4_samples;
                bool sparse_residency_6_samples;
                bool sparse_residency_8_samples;
                bool sparse_residency_16_samples;
                bool sparse_residency_aliased;
                bool variable_multisample_rate;
                bool inherited_queries;
            } features;

            struct {
                core::UInt32 max_image_dimension_1D;
                core::UInt32 max_image_dimension_2D;
                core::UInt32 max_image_dimension_3D;
                core::UInt32 max_image_dimension_cube;
                core::UInt32 max_image_array_layers;
                core::UInt32 max_texel_buffer_elements;
                core::UInt32 max_uniform_buffer_range;
                std::optional<core::UInt32> max_storage_buffer_range;
                core::UInt32 max_push_constants_size;
                std::optional<core::UInt32> max_memory_allocation_count;
                std::optional<core::UInt32> max_sampler_allocation_count;
                std::optional<core::UInt64> buffer_image_granularity;
                std::optional<core::UInt64> sparse_address_space_size;
                std::optional<core::UInt32> max_bound_descriptor_sets;
                core::UInt32 max_per_stage_descriptor_samplers;
                core::UInt32 max_per_stage_descriptor_uniform_buffers;
                core::UInt32 max_per_stage_descriptor_storage_buffers;
                core::UInt32 max_per_stage_descriptor_sampled_images;
                core::UInt32 max_per_stage_descriptor_storage_images;
                std::optional<core::UInt32> max_per_stage_descriptor_input_attachments;
                std::optional<core::UInt32> max_per_stage_resources;
                core::UInt32 max_descriptor_set_samplers;
                core::UInt32 max_descriptor_set_uniform_buffers;
                core::UInt32 max_descriptor_set_uniform_buffers_dynamic;
                core::UInt32 max_descriptor_set_storage_buffers;
                core::UInt32 max_descriptor_set_storage_buffers_dynamic;
                core::UInt32 max_descriptor_set_sampled_images;
                core::UInt32 max_descriptor_set_storage_images;
                std::optional<core::UInt32> max_descriptor_set_input_attachments;
                core::UInt32 max_vertex_input_attributes;
                core::UInt32 max_vertex_input_bindings;
                core::UInt32 max_vertex_input_attribute_offset;
                std::optional<core::UInt32> max_vertex_input_binding_stride;
                core::UInt32 max_vertex_output_components;
                core::UInt32 max_tessellation_generation_level;
                core::UInt32 max_tessellation_patch_size;
                core::UInt32 max_tessellation_control_per_vertex_input_components;
                core::UInt32 max_tessellation_control_per_vertex_output_components;
                core::UInt32 max_tessellation_control_per_patch_output_components;
                core::UInt32 max_tessellation_control_total_output_components;
                core::UInt32 max_tessellation_evaluation_input_components;
                core::UInt32 max_tessellation_evaluation_output_components;
                core::UInt32 max_geometry_shader_invocations;
                core::UInt32 max_geometry_input_components;
                core::UInt32 max_geometry_output_components;
                core::UInt32 max_geometry_output_vertices;
                core::UInt32 max_geometry_total_output_components;
                core::UInt32 max_fragment_input_components;
                core::UInt32 max_fragment_output_attachments;
                core::UInt32 max_fragment_dual_src_attachments;
                core::UInt32 max_fragment_combined_output_resources;
                core::UInt32 max_compute_shared_memory_size;
                std::array<core::UInt32, 3> max_compute_work_group_count;
                core::UInt32 max_compute_work_group_invocations;
                std::array<core::UInt32, 3> max_compute_work_group_size;
                std::optional<core::UInt32> sub_pixel_precision_bits;
                std::optional<core::UInt32> sub_texel_precision_bits;
                std::optional<core::UInt32> mipmap_precision_bits;
                core::UInt32 max_draw_indexed_index_value;
                std::optional<core::UInt32> max_draw_indirect_count;
                float max_sampler_lod_bias;
                float max_sampler_anisotropy;
                core::UInt32 max_viewports;
                std::array<core::UInt32, 2> max_viewport_dimensions;
                std::array<float, 2> viewport_bounds_range;
                std::optional<core::UInt32> viewport_sub_pixel_bits;
                std::optional<core::RangeExtent> min_memory_map_alignment;
                std::optional<core::UInt64> min_texel_buffer_offset_alignment;
                core::UInt64 min_uniform_buffer_offset_alignment;
                core::UInt64 min_storage_buffer_offset_alignment;
                core::Int32 min_texel_offset;
                core::UInt32 max_texel_offset;
                core::Int32 min_texel_gather_offset;
                core::UInt32 max_texel_gather_offset;
                float min_interpolation_offset;
                float max_interpolation_offset;
                std::optional<core::UInt32> sub_pixel_interpolation_offset_bits;
                core::UInt32 max_framebuffer_width;
                core::UInt32 max_framebuffer_height;
                core::UInt32 max_framebuffer_layers;
                SampleCountFlag framebuffer_color_sample_counts;
                SampleCountFlag framebuffer_depth_sample_counts;
                SampleCountFlag framebuffer_stencil_sample_counts;
                SampleCountFlag framebuffer_no_attachments_sample_counts;
                core::UInt32 max_color_attachments;
                SampleCountFlag sampled_image_color_sample_counts;
                SampleCountFlag sampled_image_integer_sample_counts;
                SampleCountFlag sampled_image_depth_sample_counts;
                SampleCountFlag sampled_image_stencil_sample_counts;
                SampleCountFlag storage_image_sample_counts;
                core::UInt32 max_sample_mask_words;
                bool timestamp_compute_and_engine;
                float timestamp_period;
                core::UInt32 max_clip_distances;
                core::UInt32 max_cull_distances;
                core::UInt32 max_combined_clip_and_cull_distances;
                core::UInt32 discrete_queue_priorities;
                std::array<float, 2> point_size_range;
                std::array<float, 2> line_width_range;
                float point_size_granularity;
                float line_width_granularity;
                bool strict_lines;
                bool standard_sample_locations;
                std::optional<core::UInt64> optimal_buffer_copy_offset_alignment;
                std::optional<core::UInt64> optimal_buffer_copy_row_pitch_alignment;
                core::UInt64 non_coherent_atom_size;
            } limits;
        };

        struct ImageSubresourceRange {
            ImageAspectMaskFlag aspect_mask = ImageAspectMaskFlag::Color;

            core::UInt32 base_mip_level   = 0u;
            core::UInt32 level_count      = 1u;
            core::UInt32 base_array_layer = 0u;
            core::UInt32 layer_count      = 1u;
        };

        struct ImageSubresourceLayers {
            ImageAspectMaskFlag aspect_mask = ImageAspectMaskFlag::Color;

            core::UInt32 mip_level        = 0u;
            core::UInt32 base_array_layer = 0u;
            core::UInt32 layer_count      = 1u;
        };

        struct Viewport {
            core::math::Vector2F position;
            core::math::ExtentF extent;
            core::math::Vector2F depth;

            constexpr operator VkViewport() const noexcept;
        };

        struct Scissor {
            core::math::Vector2I offset;
            core::math::ExtentU extent;

            constexpr operator VkRect2D() const noexcept;
        };

        struct ClearColor {
            core::RGBColorF color = stormkit::core::RGBColorDef::Silver<float>;
        };

        struct ClearDepthStencil {
            float depth          = 1.f;
            core::UInt32 stencil = 0;
        };

        using ClearValue = std::variant<ClearColor, ClearDepthStencil>;

        struct BufferImageCopy {
            core::UInt32 buffer_offset;
            core::UInt32 buffer_row_length;
            core::UInt32 buffer_image_height;

            ImageSubresourceLayers subresource_layers;

            core::math::Vector3I offset;
            core::math::ExtentU extent;
        };

        struct BlitRegion {
            ImageSubresourceLayers source;
            ImageSubresourceLayers destination;

            std::array<core::math::ExtentI, 2> source_offset;
            std::array<core::math::ExtentI, 2> destination_offset;
        };

        struct PushConstantRange {
            ShaderStageFlag stages;
            core::UInt32 offset;
            core::RangeExtent size;
        };

        struct PhysicalDeviceInfo {
            core::UInt64 device_id;
            std::string device_name;
            core::UInt64 vendor_id;
            std::string vendor_name;

            core::UInt32 api_major_version;
            core::UInt32 api_minor_version;
            core::UInt32 api_patch_version;

            core::UInt32 driver_major_version;
            core::UInt32 driver_minor_version;
            core::UInt32 driver_patch_version;

            std::array<core::UInt8, VK_UUID_SIZE> pipeline_cache_uuid;

            PhysicalDeviceType type;
        };

        struct QueueFamily {
            QueueFlag flags;
            core::UInt32 count;
        };

        using ClearValue = std::variant<ClearColor, ClearDepthStencil>;
        using SpirvID    = core::UInt32;

        template<class T>
        using Expected = std::expected<T, Result>;

        constexpr auto toStringView(PhysicalDeviceType type) -> std::string_view;
        constexpr auto toString(PhysicalDeviceType type) -> std::string;
        constexpr auto toStringView(Result result) -> std::string_view;
        constexpr auto toString(Result result) -> std::string;

        constexpr auto isDepthOnlyFormat(PixelFormat format) noexcept -> bool;
        constexpr auto isDepthStencilFormat(PixelFormat format) noexcept -> bool;
        constexpr auto isDepthFormat(PixelFormat format) noexcept -> bool;

        constexpr auto getChannelCountFor(PixelFormat format) noexcept -> core::UInt8;
        constexpr auto getArraySizeByChannelFor(PixelFormat format) noexcept -> core::UInt8;

        auto computeMipLevel(const core::math::ExtentU& extent) noexcept -> core::UInt32;
        constexpr auto
            computeUniformBufferOffsetAlignement(core::RangeExtent size,
                                                 const RenderCapabilities& capabilities) noexcept
            -> core::RangeExtent;

        auto toString(const PhysicalDeviceInfo& data) noexcept;
    } // namespace stormkit::gpu

    FLAG_ENUM(stormkit::gpu::QueueFlag)
    FLAG_ENUM(stormkit::gpu::ShaderStageFlag)
    FLAG_ENUM(stormkit::gpu::SampleCountFlag)
    FLAG_ENUM(stormkit::gpu::ColorComponentFlag)
    FLAG_ENUM(stormkit::gpu::ImageAspectMaskFlag)
    FLAG_ENUM(stormkit::gpu::ImageCreateFlag)
    FLAG_ENUM(stormkit::gpu::CullModeFlag)
    FLAG_ENUM(stormkit::gpu::BufferUsageFlag)
    FLAG_ENUM(stormkit::gpu::ImageUsageFlag)
    FLAG_ENUM(stormkit::gpu::MemoryPropertyFlag)
    FLAG_ENUM(stormkit::gpu::AccessFlag)
    FLAG_ENUM(stormkit::gpu::PipelineStageFlag)
    FLAG_ENUM(stormkit::gpu::DependencyFlag)
    FLAG_ENUM(stormkit::gpu::StencilFaceFlag)
    FLAG_ENUM(stormkit::gpu::GeometryFlag)
    HASH_FUNC(stormkit::gpu::Viewport)
    HASH_FUNC(stormkit::gpu::Scissor)
}

namespace stormkit::gpu {
    namespace details {
        constexpr auto PHYSICAL_DEVICE_TO_STRING = [] {
            using namespace std::literals;

            return core::makeFrozenMap<PhysicalDeviceType, std::string_view>({
                { PhysicalDeviceType::CPU, "CPU"sv },
                { PhysicalDeviceType::Virtual_GPU, "Virtual_GPU"sv },
                { PhysicalDeviceType::Discrete_GPU, "Discrete_GPU"sv },
                { PhysicalDeviceType::Integrated_GPU, "Integrated_GPU"sv },
                { PhysicalDeviceType::Other, "Other"sv },
            });
        }();
    } // namespace details

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto toStringView(PhysicalDeviceType type) -> std::string_view {
        const auto it = details::PHYSICAL_DEVICE_TO_STRING.find(type);
        core::expects(it != std::ranges::cend(details::PHYSICAL_DEVICE_TO_STRING));

        return it->second;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto toString(PhysicalDeviceType type) -> std::string {
        return std::string { toStringView(type) };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto toStringView(Result result) -> std::string_view {
        return vkResultToString(core::as<VkResult>(result));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto toString(Result result) -> std::string {
        return std::string { toStringView(result) };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto isDepthOnlyFormat(PixelFormat format) noexcept -> bool {
        return format == PixelFormat::Depth16 or format == PixelFormat::Depth24 or
               format == PixelFormat::Depth32F;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto isDepthStencilFormat(PixelFormat format) noexcept -> bool {
        return format == PixelFormat::Depth16_Stencil8 or format == PixelFormat::Depth24_Stencil8 or
               format == PixelFormat::Depth32F_Stencil8;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto isDepthFormat(PixelFormat format) noexcept -> bool {
        return isDepthOnlyFormat(format) or isDepthStencilFormat(format);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto getChannelCountFor(PixelFormat format) noexcept -> core::UInt8 {
        switch (format) {
            case PixelFormat::R8_SNorm:
            case PixelFormat::R8_UNorm:
            case PixelFormat::R16_SNorm:
            case PixelFormat::R16_UNorm:
            case PixelFormat::R8I:
            case PixelFormat::R8U:
            case PixelFormat::R16I:
            case PixelFormat::R16U:
            case PixelFormat::R32I:
            case PixelFormat::R32U:
            case PixelFormat::R16F:
            case PixelFormat::R32F:
            case PixelFormat::Depth16:
            case PixelFormat::Depth24:
            case PixelFormat::Depth32F: return 1;

            case PixelFormat::RG8_SNorm:
            case PixelFormat::RG8_UNorm:
            case PixelFormat::RG16_SNorm:
            case PixelFormat::RG16_UNorm:
            case PixelFormat::RG8I:
            case PixelFormat::RG8U:
            case PixelFormat::RG16I:
            case PixelFormat::RG16U:
            case PixelFormat::RG32I:
            case PixelFormat::RG32U:
            case PixelFormat::RG16F:
            case PixelFormat::RG32F:
            case PixelFormat::Depth16_Stencil8:
            case PixelFormat::Depth24_Stencil8:
            case PixelFormat::Depth32F_Stencil8: return 2;

            case PixelFormat::RGB8_SNorm:
            case PixelFormat::RGB8_UNorm:
            case PixelFormat::RGB16_SNorm:
            case PixelFormat::RGB16_UNorm:
            case PixelFormat::BGR8_UNorm:
            case PixelFormat::RGB8I:
            case PixelFormat::RGB8U:
            case PixelFormat::RGB16I:
            case PixelFormat::RGB16U:
            case PixelFormat::RGB32I:
            case PixelFormat::RGB32U:
            case PixelFormat::RGB16F:
            case PixelFormat::RGB32F:
            case PixelFormat::sRGB8:
            case PixelFormat::sBGR8:
            case PixelFormat::R5_G6_B5_UNorm_Pack16:
            case PixelFormat::BG11_R10F_Pack32: return 3;

            case PixelFormat::RGBA8_SNorm:
            case PixelFormat::RGBA8_UNorm:
            case PixelFormat::RGBA16_SNorm:
            case PixelFormat::RGBA16_UNorm:
            case PixelFormat::BGRA8_UNorm:
            case PixelFormat::RGBA8I:
            case PixelFormat::RGBA8U:
            case PixelFormat::RGBA16I:
            case PixelFormat::RGBA16U:
            case PixelFormat::RGBA32I:
            case PixelFormat::RGBA32U:
            case PixelFormat::RGBA16F:
            case PixelFormat::RGBA32F:
            case PixelFormat::sRGBA8:
            case PixelFormat::sBGRA8: return 4;

            default: break;
        }

        return 0u;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto getArraySizeByChannelFor(PixelFormat format) noexcept -> core::UInt8 {
        switch (format) {
            case PixelFormat::R8_SNorm:
            case PixelFormat::R8_UNorm:
            case PixelFormat::RG8_SNorm:
            case PixelFormat::RG8_UNorm:
            case PixelFormat::R8I:
            case PixelFormat::R8U:
            case PixelFormat::RG8I:
            case PixelFormat::RG8U:
            case PixelFormat::RGB8_SNorm:
            case PixelFormat::RGB8_UNorm:
            case PixelFormat::BGR8_UNorm:
            case PixelFormat::RGB8I:
            case PixelFormat::RGB8U:
            case PixelFormat::RGBA8_SNorm:
            case PixelFormat::RGBA8_UNorm:
            case PixelFormat::RGBA16_SNorm:
            case PixelFormat::BGRA8_UNorm:
            case PixelFormat::sRGB8:
            case PixelFormat::sBGR8:
            case PixelFormat::sRGBA8:
            case PixelFormat::sBGRA8: return 1u;

            case PixelFormat::R16_SNorm:
            case PixelFormat::R16_UNorm:
            case PixelFormat::R16I:
            case PixelFormat::R16U:
            case PixelFormat::RG16_SNorm:
            case PixelFormat::RG16_UNorm:
            case PixelFormat::RG16I:
            case PixelFormat::RG16U:
            case PixelFormat::RG16F:
            case PixelFormat::RGB16I:
            case PixelFormat::RGB16U:
            case PixelFormat::RGB16F:
            case PixelFormat::RGBA16I:
            case PixelFormat::RGBA16U:
            case PixelFormat::RGBA16F:
            case PixelFormat::R16F: return 2u;

            case PixelFormat::R32I:
            case PixelFormat::R32U:
            case PixelFormat::R32F:
            case PixelFormat::RG32I:
            case PixelFormat::RG32U:
            case PixelFormat::RG32F:
            case PixelFormat::RGB16_SNorm:
            case PixelFormat::RGB32I:
            case PixelFormat::RGB32U:
            case PixelFormat::RGB32F:
            case PixelFormat::RGBA8I:
            case PixelFormat::RGBA8U:
            case PixelFormat::RGBA32I:
            case PixelFormat::RGBA32U:
            case PixelFormat::RGBA32F: return 4u;

            default: break;
        }

        return 0u;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr Viewport::operator VkViewport() const noexcept {
        return { .x        = position.x,
                 .y        = position.y,
                 .width    = extent.width,
                 .height   = extent.height,
                 .minDepth = depth.x,
                 .maxDepth = depth.y };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr Scissor::operator VkRect2D() const noexcept {
        return { .offset = { offset.x, offset.y }, .extent = { extent.width, extent.height } };
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto computeMipLevel(const core::math::ExtentU& extent) noexcept -> core::UInt32 {
        const auto as_float = core::math::ExtentF { extent };

        return core::as<core::UInt32>(core::math::floor(
                   core::math::log2(core::math::max(as_float.width, as_float.height)))) +
               1;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto
        computeUniformBufferOffsetAlignement(core::RangeExtent size,
                                             const RenderCapabilities& capabilities) noexcept
        -> core::RangeExtent {
        const auto min_ubo_align = capabilities.limits.min_uniform_buffer_offset_alignment;

        if (min_ubo_align > 0) size = (size + min_ubo_align - 1) & ~(min_ubo_align - 1);

        return size;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto toString(const PhysicalDeviceInfo& data) noexcept {
        return std::format("[PhysicalDeviceInfo:\n"
                           "   .device_id      = {:#06x},\n"
                           "   .device_name    = {},\n"
                           "   .vendor_id      = {:#06x},\n"
                           "   .vendor_name    = {},\n"
                           "   .api_version    = {}.{}.{},\n"
                           "   .driver_version = {}.{}.{},\n"
                           "   .type           = {}]",
                           data.device_id,
                           data.device_name,
                           data.vendor_id,
                           data.vendor_name,
                           data.api_major_version,
                           data.api_minor_version,
                           data.api_patch_version,
                           data.driver_major_version,
                           data.driver_minor_version,
                           data.driver_patch_version,
                           toString(data.type));
    }
} // namespace stormkit::gpu
