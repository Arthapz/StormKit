// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

export module stormkit.Gpu:Core.Vulkan;

import std;

import stormkit.Core;
import stormkit.Log;

// clang-format off
export import <stormkit/Gpu/Core/VulkanMacro.hpp>;
// clang-format on

export namespace stormkit::gpu {
    inline constexpr auto INSTANCE_BASE_EXTENSIONS =
        std::array<core::CZString, 1> { VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME };

    inline constexpr auto SURFACE_EXTENSIONS = std::array {
        VK_KHR_SURFACE_EXTENSION_NAME,
#ifdef STORMKIT_OS_WINDOWS
        VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
#elif defined(STORMKIT_OS_LINUX)
        VK_KHR_XCB_SURFACE_EXTENSION_NAME,
        VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME,
#elif defined(STORMKIT_OS_MACOS)
        VK_MVK_MACOS_SURFACE_EXTENSION_NAME,
#elif defined(STORMKIT_OS_IOS)
        VK_MVK_IOS_SURFACE_EXTENSION_NAME,
#endif
    };

    template<std::integral T>
    constexpr auto vkMakeVersion(T major, T minor, T patch) noexcept -> core::UInt32;

    constexpr auto vkVersionMajor(std::integral auto version) noexcept -> core::UInt32;

    constexpr auto vkVersionMinor(std::integral auto version) noexcept -> core::UInt32;

    constexpr auto vkVersionPatch(std::integral auto version) noexcept -> core::UInt32;

#if defined(STORMKIT_RENDER_SAFE_VULKAN) or defined(STORMKIT_ENABLE_VALIDATION_LAYERS)
    inline constexpr auto ENABLE_VALIDATION = true;
#else
    inline constexpr auto ENABLE_VALIDATION = false;
#endif

    [[noreturn]] auto checkVkError(
        VkResult result,
        std::string_view line,
        const std::source_location& location = std::source_location::current()) noexcept -> void;

    constexpr auto vkResultToString(VkResult error) -> std::string_view;

    template<class T>
    concept VulkanObject = requires(const T& t) { t.vkHandle(); };

    template<core::IsNotPointer T>
        requires VulkanObject<T>
    constexpr auto getHandle(const T& t) noexcept;

    template<core::IsRawPointer T>
        requires VulkanObject<std::remove_pointer_t<T>>
    constexpr auto getHandle(T t) noexcept;

    template<core::SmartIsPointer T>
        requires VulkanObject<class T::element_type>
    constexpr auto getHandle(const T& t) noexcept;

    struct ParentRefBase {
        template<typename T>
        auto parent() -> const T&;
    };

    template<typename T>
    class ParentRef: public ParentRefBase {
      public:
        explicit ParentRef(const T& instance) noexcept;
        ~ParentRef() noexcept;

        ParentRef(const ParentRef&) noexcept;
        auto operator=(const ParentRef&) noexcept -> ParentRef&;

        ParentRef(ParentRef&&) noexcept;
        auto operator=(ParentRef&&) noexcept -> ParentRef&;

        template<>
        [[nodiscard]] auto parent() const noexcept -> const T&;

      private:
        const T *m_parent;
    };

    class Instance;

    class InstanceObject: public ParentRef<Instance> {
      public:
        using ParentRef<Instance>::ParentRef;

        [[nodiscard]] auto instance() const noexcept -> const Instance&;
    };

    class Device;

    class DeviceObject: public ParentRef<Device> {
      public:
        using ParentRef<Device>::ParentRef;

        [[nodiscard]] auto device() const noexcept -> const Device&;
    };
} // namespace stormkit::gpu

namespace stormkit::gpu {
    namespace details {
        inline constexpr auto VK_RESULT_TO_STRING = [] {
            using namespace std::literals;

            return core::makeFrozenMap<VkResult, std::string_view>({
                PAIR(VK_NOT_READY),
                PAIR(VK_TIMEOUT),
                PAIR(VK_EVENT_SET),
                PAIR(VK_EVENT_RESET),
                PAIR(VK_INCOMPLETE),
                PAIR(VK_ERROR_OUT_OF_HOST_MEMORY),
                PAIR(VK_ERROR_OUT_OF_DEVICE_MEMORY),
                PAIR(VK_ERROR_OUT_OF_POOL_MEMORY),
                PAIR(VK_ERROR_INITIALIZATION_FAILED),
                PAIR(VK_ERROR_DEVICE_LOST),
                PAIR(VK_ERROR_MEMORY_MAP_FAILED),
                PAIR(VK_ERROR_LAYER_NOT_PRESENT),
                PAIR(VK_ERROR_EXTENSION_NOT_PRESENT),
                PAIR(VK_ERROR_FEATURE_NOT_PRESENT),
                PAIR(VK_ERROR_INCOMPATIBLE_DRIVER),
                PAIR(VK_ERROR_TOO_MANY_OBJECTS),
                PAIR(VK_ERROR_FORMAT_NOT_SUPPORTED),
                PAIR(VK_ERROR_SURFACE_LOST_KHR),
                PAIR(VK_ERROR_NATIVE_WINDOW_IN_USE_KHR),
                PAIR(VK_SUBOPTIMAL_KHR),
                PAIR(VK_ERROR_OUT_OF_DATE_KHR),
                PAIR(VK_ERROR_INCOMPATIBLE_DISPLAY_KHR),
                PAIR(VK_ERROR_VALIDATION_FAILED_EXT),
                PAIR(VK_ERROR_INVALID_SHADER_NV),
            });
        }();
    } // namespace details

    /////////////////////////////////////
    /////////////////////////////////////
    template<std::integral T>
    constexpr auto vkMakeVersion(T major, T minor, T patch) noexcept -> core::UInt32 {
        return vkVersionMajor(major) | vkVersionMinor(minor) | vkVersionPatch(patch);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto vkVersionMajor(std::integral auto version) noexcept -> core::UInt32 {
        return core::as<core::UInt32>(version >> 22u);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto vkVersionMinor(std::integral auto version) noexcept -> core::UInt32 {
        return core::as<core::UInt32>((version >> 12u) & 0x3ffu);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto vkVersionPatch(std::integral auto version) noexcept -> core::UInt32 {
        return core::as<core::UInt32>(version & 0xfffu);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto checkVkError(VkResult result,
                             std::string_view line,
                             const std::source_location& location) noexcept -> void {
        if (result == VK_SUCCESS) [[likely]]
            return;
        using log::operator"" _module;

        const auto m = "Vulkan"_module;

        log::Logger::flog(m,
                          "[%s] failed in \n"
                          "    > file:     %s\n"
                          "      line:     %s\n"
                          "      function: %s\n"
                          "      return_code:  %s",
                          line,
                          location.file_name(),
                          location.line(),
                          location.function_name(),
                          vkResultToString(result));

#ifdef STORMKIT_OS_MACOS
        std::exit(EXIT_FAILURE);
#else
        std::quick_exit(EXIT_FAILURE);
#endif
    }

    /////////////////////////////////////
    /////////////////////////////////////
    constexpr auto vkResultToString(VkResult error) -> std::string_view {
        using namespace std::literals;

        const auto it = details::VK_RESULT_TO_STRING.find(error);
        if (it == std::ranges::cend(details::VK_RESULT_TO_STRING)) [[unlikely]]
            return "Unknow error"sv;

        return it->second;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<core::IsNotPointer T>
        requires VulkanObject<T>
    constexpr auto getHandle(const T& t) noexcept {
        return t.vkHandle();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<core::IsRawPointer T>
        requires VulkanObject<std::remove_pointer_t<T>>
    constexpr auto getHandle(T t) noexcept {
        core::expects(t);

        return t->vkHandle();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<core::SmartIsPointer T>
        requires VulkanObject<class T::element_type>
    constexpr auto getHandle(const T& t) noexcept {
        STORMKIT_CONSTEXPR_EXPECTS(t);

        return t->vkHandle();
    }

    inline constexpr auto STORMKIT_VERSION =
        vkMakeVersion<core::Int32>(core::STORMKIT_MAJOR_VERSION,
                                   core::STORMKIT_MINOR_VERSION,
                                   core::STORMKIT_PATCH_VERSION);
} // namespace stormkit::gpu
