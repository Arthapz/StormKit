// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

export module stormkit.Gpu:Core.Device;

import std;

import stormkit.Core;

import :Types;
import :Vulkan;
import :Instance;

export namespace stormkit::gpu {
    class PhysicalDevice;
    class Fence;

    class STORMKIT_API Device: public InstanceObject {
      public:
        static constexpr auto DEBUG_TYPE = DebugObjectType::Device;

        struct QueueEntry {
            core::UInt32 id;
            core::UInt32 count;
            QueueFlag flags = QueueFlag {};
        };

        struct Info {
            bool enable_swapchain  = true;
            bool enable_raytracing = false;
        };

        Device(const PhysicalDevice& physical_device, const Instance& instance, Info info = {});
        ~Device();

        Device(const Device&)                    = delete;
        auto operator=(const Device&) -> Device& = delete;

        Device(Device&&) noexcept;
        auto operator=(Device&&) noexcept -> Device&;

        auto waitIdle() const noexcept -> void;
        auto waitForFences(std::span<const FenceConstRef> fences,
                           bool wait_all = true,
                           std::chrono::milliseconds timeout =
                               std::chrono::milliseconds::max()) const noexcept -> void;
        auto waitForFence(const Fence& fence,
                          std::chrono::milliseconds timeout =
                              std::chrono::milliseconds::max()) const noexcept -> void;

        [[nodiscard]] auto rasterQueueEntry() const noexcept -> const QueueEntry&;
        [[nodiscard]] auto asyncTransfertQueueEntry() const noexcept -> const QueueEntry&;
        [[nodiscard]] auto asyncComputeQueueEntry() const noexcept -> const QueueEntry&;

        [[nodiscard]] auto hasAsyncTransfertQueue() const noexcept -> bool;
        [[nodiscard]] auto hasAsyncComputeQueue() const noexcept -> bool;

        [[nodiscard]] auto physicalDevice() const noexcept -> const PhysicalDevice&;

        [[nodiscard]] operator VkDevice() const noexcept;
        [[nodiscard]] auto vkHandle() const noexcept -> VkDevice;

        [[nodiscard]] auto table() const noexcept -> const VolkDeviceTable&;

        [[nodiscard]] auto vmaAllocator() const noexcept -> VmaAllocator;

        template<class T>
        auto setObjectName(const T& object, std::string_view name) const -> void;

        auto setObjectName(core::UInt64 object, DebugObjectType type, std::string_view name) const
            -> void;

      private:
        const PhysicalDevice *m_physical_device = nullptr;

        VkDevice m_device              = VK_NULL_HANDLE;
        VolkDeviceTable m_device_table = {};

        QueueEntry m_raster_queue;
        std::optional<QueueEntry> m_async_transfert_queue;
        std::optional<QueueEntry> m_async_compute_queue;

        VmaAllocator m_vma_allocator = VK_NULL_HANDLE;

        VmaVulkanFunctions m_vma_device_table;
    };

    DECLARE_PTR_AND_REF(Device);

    class STORMKIT_API DeviceObject {
      public:
        explicit DeviceObject(const Device& device) noexcept;
        ~DeviceObject() noexcept;

        DeviceObject(const DeviceObject&) noexcept;
        auto operator=(const DeviceObject&) noexcept -> DeviceObject&;

        DeviceObject(DeviceObject&&) noexcept;
        auto operator=(DeviceObject&&) noexcept -> DeviceObject&;

        [[nodiscard]] auto device() const noexcept -> const Device&;

      private:
        const Device *m_device;
    };

    DECLARE_PTR_AND_REF(DeviceObject);

    class STORMKIT_API PhysicalDevice: public InstanceObject {
      public:
        static constexpr auto DEBUG_TYPE = DebugObjectType::Physical_Device;

        ~PhysicalDevice();

        PhysicalDevice(const PhysicalDevice&)                    = delete;
        auto operator=(const PhysicalDevice&) -> PhysicalDevice& = delete;

        PhysicalDevice(PhysicalDevice&&) noexcept;
        auto operator=(PhysicalDevice&&) noexcept -> PhysicalDevice&;

        [[nodiscard]] auto checkExtensionSupport(std::string_view extension) const noexcept -> bool;
        [[nodiscard]] auto
            checkExtensionSupport(std::span<const std::string_view> extensions) const noexcept
            -> bool;
        [[nodiscard]] auto
            checkExtensionSupport(std::span<const core::CZString> extensions) const noexcept
            -> bool;

        [[nodiscard]] auto info() const noexcept -> const PhysicalDeviceInfo&;
        [[nodiscard]] auto capabilities() const noexcept -> const RenderCapabilities&;
        [[nodiscard]] auto memoryProperties() const noexcept -> std::span<const MemoryPropertyFlag>;

        [[nodiscard]] auto queueFamilies() const noexcept -> std::span<const QueueFamily>;

        [[nodiscard]] auto createLogicalDevice() const -> Device;
        [[nodiscard]] auto allocateLogicalDevice() const -> std::unique_ptr<Device>;
        [[nodiscard]] auto allocateRefCountedLogicalDevice() const -> std::shared_ptr<Device>;

        [[nodiscard]] operator VkPhysicalDevice() const noexcept;
        [[nodiscard]] VkPhysicalDevice vkHandle() const noexcept;

      private:
        PhysicalDevice(VkPhysicalDevice physical_device, const Instance& instance);

        VkPhysicalDevice m_physical_device = VK_NULL_HANDLE;

        PhysicalDeviceInfo m_device_info;
        RenderCapabilities m_capabilities;
        std::vector<MemoryPropertyFlag> m_memory_properties;

        std::vector<QueueFamily> m_queue_families;
        VkPhysicalDeviceMemoryProperties m_vk_memory_properties;

        std::vector<std::string> m_extensions;

        friend class Instance;
    };
} // namespace stormkit::gpu

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::gpu {
    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::waitForFence(const Fence& fence,
                                     std::chrono::milliseconds timeout) const noexcept -> void {
        core::expects(m_device != VK_NULL_HANDLE);

        waitForFences(core::makeConstRefStaticArray(fence), true, timeout);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::rasterQueueEntry() const noexcept -> const QueueEntry& {
        return m_raster_queue;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::asyncTransfertQueueEntry() const noexcept -> const QueueEntry& {
        core::expects(m_async_transfert_queue != std::nullopt);

        return *m_async_transfert_queue;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::asyncComputeQueueEntry() const noexcept -> const QueueEntry& {
        core::expects(m_async_compute_queue != std::nullopt);

        return *m_async_compute_queue;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::hasAsyncTransfertQueue() const noexcept -> bool {
        return m_async_transfert_queue != std::nullopt;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::hasAsyncComputeQueue() const noexcept -> bool {
        return m_async_compute_queue != std::nullopt;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::physicalDevice() const noexcept -> const PhysicalDevice& {
        return *m_physical_device;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline Device::operator VkDevice() const noexcept {
        return vkHandle();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::vkHandle() const noexcept -> VkDevice {
        core::expects(m_device != VK_NULL_HANDLE);

        return m_device;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::vmaAllocator() const noexcept -> VmaAllocator {
        core::expects(m_vma_allocator != VK_NULL_HANDLE);

        return m_vma_allocator;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto Device::table() const noexcept -> const VolkDeviceTable& {
        return m_device_table;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class T>
    auto Device::setObjectName(const T& object, std::string_view name) const -> void {
        setObjectName(reinterpret_cast<core::UInt64>(object.vkHandle()), T::DEBUG_TYPE, name);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline DeviceObject::DeviceObject(const Device& device) noexcept : m_device { &device } {
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline DeviceObject::~DeviceObject() noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    inline DeviceObject::DeviceObject(const DeviceObject&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto DeviceObject::operator=(const DeviceObject&) noexcept -> DeviceObject& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    inline DeviceObject::DeviceObject(DeviceObject&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto DeviceObject::operator=(DeviceObject&&) noexcept -> DeviceObject& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto DeviceObject::device() const noexcept -> const Device& {
        core::expects(m_device);

        return *m_device;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto PhysicalDevice::info() const noexcept -> const PhysicalDeviceInfo& {
        return m_device_info;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto PhysicalDevice::capabilities() const noexcept -> const RenderCapabilities& {
        return m_capabilities;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto PhysicalDevice::memoryProperties() const noexcept
        -> std::span<const MemoryPropertyFlag> {
        return m_memory_properties;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto PhysicalDevice::queueFamilies() const noexcept -> std::span<const QueueFamily> {
        return m_queue_families;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline PhysicalDevice::operator VkPhysicalDevice() const noexcept {
        return vkHandle();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    inline auto PhysicalDevice::vkHandle() const noexcept -> VkPhysicalDevice {
        return m_physical_device;
    }
} // namespace stormkit::gpu
