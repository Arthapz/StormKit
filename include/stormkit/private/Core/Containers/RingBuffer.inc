// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution
export namespace stormkit::core {
    template<class T>
    class RingBuffer {
      public:
        using ValueType  = T;
        using ExtentType = RangeExtent;

        using value_type = ValueType;
        using size_type  = ExtentType;

        RingBuffer(ExtentType capacity);

        RingBuffer(const RingBuffer& copy);
        auto operator=(const RingBuffer& copy) -> RingBuffer&;

        RingBuffer(RingBuffer&& moved) noexcept;
        auto operator=(RingBuffer&& moved) noexcept -> RingBuffer&;

        ~RingBuffer() noexcept;

        auto clear() noexcept -> void;

        [[nodiscard]] auto empty() const noexcept -> bool;
        [[nodiscard]] auto full() const noexcept -> bool;
        [[nodiscard]] auto size() const noexcept -> ExtentType;
        [[nodiscard]] auto capacity() const noexcept -> ExtentType;

        auto push(ValueType value) noexcept(std::is_nothrow_constructible_v<ValueType, ValueType&&>)
            -> bool;

        template<class... Args>
        auto emplace(Args&&... values) noexcept(
            std::is_nothrow_constructible_v<ValueType, Args&&...>) -> void;

        auto next() noexcept -> void;

        auto pop() noexcept -> void;

        template<class Self>
        [[nodiscard]] auto get(this Self& self) noexcept -> auto&&;

        [[nodiscard]] auto data() const noexcept -> std::span<const ValueType>;

      private:
        template<class Self>
        [[nodiscard]] auto getPtr(this Self& self, ExtentType pos) noexcept -> auto&&;

        ExtentType m_capacity = 0;
        ExtentType m_count    = 0;

        std::vector<Byte> m_buffer;

        ExtentType m_write = 0;
        ExtentType m_read  = 0;
    };
} // namespace stormkit::core

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    RingBuffer<T>::RingBuffer(ExtentType capacity) : m_capacity { capacity } {
        m_buffer.resize(m_capacity * sizeof(ValueType));
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    RingBuffer<T>::RingBuffer(const RingBuffer& copy) {
        m_capacity = copy.m_capacity;
        m_count    = copy.m_count;
        m_write    = copy.m_write;
        m_read     = copy.m_read;

        m_buffer.resize(m_capacity * sizeof(ValueType));
        if (not empty()) {
            for (auto i = m_read; i < m_write;) {
                new (&m_buffer[i * sizeof(ValueType)]) T { *copy.getPtr(i) };

                i += 1;
                if (i >= m_capacity) i -= m_capacity;
            }
        }
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    auto RingBuffer<T>::operator=(const RingBuffer& copy) -> RingBuffer& {
        if (&copy == this) return *this;

        m_capacity = copy.m_capacity;
        m_count    = copy.m_count;
        m_write    = copy.m_write;
        m_read     = copy.m_read;

        m_buffer.resize(m_capacity * sizeof(ValueType));
        if (not empty())
            for (auto i = m_read; i < m_write;) {
                new (&m_buffer[i * sizeof(ValueType)]) T { *copy.getPtr(i) };

                i += 1;
                if (i >= m_capacity) i -= m_capacity;
            }

        return *this;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    RingBuffer<T>::RingBuffer(RingBuffer&& moved) noexcept {
        m_buffer = std::exchange(moved.m_buffer, std::vector<Byte> {});

        m_capacity = std::exchange(moved.m_capacity, 0);
        m_count    = std::exchange(moved.m_count, 0);
        m_write    = std::exchange(moved.m_write, 0);
        m_read     = std::exchange(moved.m_read, 0);
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    auto RingBuffer<T>::operator=(RingBuffer&& moved) noexcept -> RingBuffer& {
        if (&moved == this) return *this;

        m_buffer = std::exchange(moved.m_buffer, std::vector<Byte> {});

        m_capacity = std::exchange(moved.m_capacity, 0);
        m_count    = std::exchange(moved.m_count, 0);
        m_write    = std::exchange(moved.m_write, 0);
        m_read     = std::exchange(moved.m_read, 0);

        return *this;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    RingBuffer<T>::~RingBuffer() noexcept {
        clear();
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    auto RingBuffer<T>::clear() noexcept -> void {
        while (not empty()) pop();
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    auto RingBuffer<T>::empty() const noexcept -> bool {
        return m_count == 0;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    auto RingBuffer<T>::full() const noexcept -> bool {
        return m_count == m_capacity;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    auto RingBuffer<T>::size() const noexcept -> ExtentType {
        return m_count;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    auto RingBuffer<T>::capacity() const noexcept -> ExtentType {
        return m_capacity;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    auto RingBuffer<T>::push(ValueType value) noexcept(
        std::is_nothrow_constructible_v<ValueType, ValueType&&>) -> bool {
        emplace(std::move(value));
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    template<class... Args>
    auto RingBuffer<T>::emplace(Args&&... values) noexcept(
        std::is_nothrow_constructible_v<ValueType, Args&&...>) -> void {
        if (m_count == m_capacity) pop();

        new (&m_buffer[m_write * sizeof(ValueType)]) ValueType { std::forward<Args>(values)... };

        m_write += 1;
        if (m_write >= m_capacity) m_write -= m_capacity;

        m_count++;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    auto RingBuffer<T>::next() noexcept -> void {
        m_read += 1;
        if (m_read >= m_capacity) m_read -= m_capacity;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    auto RingBuffer<T>::pop() noexcept -> void {
        expects(not empty());

        getPtr(m_write)->~ValueType();

        --m_count;
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    template<class Self>
    auto RingBuffer<T>::get(this Self& self) noexcept -> auto&& {
        expects(not self.empty());

        return self.getPtr(self.m_read);
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    auto RingBuffer<T>::data() const noexcept -> std::span<const ValueType> {
        return std::span<const ValueType> { getPtr(0), m_capacity };
    }

    ////////////////////////////////////////
    ////////////////////////////////////////
    template<class T>
    template<class Self>
    auto RingBuffer<T>::getPtr(this Self& self, ExtentType pos) noexcept -> auto&& {
        using OutPtr    = std::conditional_t<std::is_const_v<Self>, const T*, T*>;
        const auto addr = std::to_address(self.m_buffer[pos * sizeof(ValueType)]);

        return std::launder(std::bit_cast<OutPtr>(addr));
    }
} // namespace stormkit::core
