// Copyright (C) 2023 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution
export namespace stormkit::core {
    template<class T>
    class Singleton {
      public:
        template<class... Args>
        static auto instance(Args&&... args) noexcept(std::is_nothrow_constructible_v<T>) -> T&;

        Singleton(Singleton&&)      = delete;
        Singleton(const Singleton&) = delete;

        auto operator=(Singleton&&) -> Singleton&      = delete;
        auto operator=(const Singleton&) -> Singleton& = delete;

      protected:
        Singleton() noexcept  = default;
        ~Singleton() noexcept = default;

      private:
        static auto onceFlag() noexcept -> std::once_flag&;

        static inline std::unique_ptr<T> m_instance = nullptr;
    };
} // namespace stormkit::core

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::core {
    /////////////////////////////////////
    /////////////////////////////////////
    template<class T>
    template<class... Args>
    auto Singleton<T>::instance(Args&&... args) noexcept(std::is_nothrow_constructible_v<T>) -> T& {
        auto lambdas = [](Args&&... args) mutable {
            m_instance = std::make_unique<T>(std::forward<Args>(args)...);
        };

        std::call_once(onceFlag(), lambdas, std::forward<Args>(args)...);

        return *m_instance;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class T>
    auto Singleton<T>::onceFlag() noexcept -> std::once_flag& {
        static auto once_flag = std::once_flag {};
        return once_flag;
    }
} // namespace stormkit::core
